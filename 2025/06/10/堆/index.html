<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>堆 | mint1.</title><meta name="author" content="mint"><meta name="copyright" content="mint"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="堆概述什么是堆在程序运行过程中，堆可以提供动态分布的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器。  堆管理器处于用户程序与内核中间，主要做以下工作： 1.响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序，同时为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，">
<meta property="og:type" content="article">
<meta property="og:title" content="堆">
<meta property="og:url" content="http://mint-sec.github.io/2025/06/10/%E5%A0%86/index.html">
<meta property="og:site_name" content="mint1.">
<meta property="og:description" content="堆概述什么是堆在程序运行过程中，堆可以提供动态分布的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器。  堆管理器处于用户程序与内核中间，主要做以下工作： 1.响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序，同时为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://mint-sec.github.io/images/Decoration/%E9%9B%85.jpg">
<meta property="article:published_time" content="2025-06-10T01:48:17.000Z">
<meta property="article:modified_time" content="2025-06-11T06:36:25.047Z">
<meta property="article:author" content="mint">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="堆">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://mint-sec.github.io/images/Decoration/%E9%9B%85.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://mint-sec.github.io/2025/06/10/%E5%A0%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":3,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '堆',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-11 14:36:25'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/null/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/Decoration/%E9%9B%85.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="mint1."><span class="site-name">mint1.</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">堆</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-10T01:48:17.000Z" title="发表于 2025-06-10 09:48:17">2025-06-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-11T06:36:25.047Z" title="更新于 2025-06-11 14:36:25">2025-06-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>44分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="堆"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="堆概述"><a href="#堆概述" class="headerlink" title="堆概述"></a>堆概述</h1><h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p>在程序运行过程中，堆可以提供动态分布的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器。</p>
<blockquote>
<p>堆管理器处于用户程序与内核中间，主要做以下工作：</p>
<p>1.响应用户的申请内存请求，向操作系统申请内存，然后将其返回给用户程序，同时为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存，然后让堆管理通过某种算法管理这块内存。只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互。</p>
<p>2.管理用户所释放的内存。一般来说用户释放的内存并不是直接返还给操作系统的，而是由堆管理器进行管理。这些释放的内存可以来响应用户新申请的内存请求。</p>
</blockquote>
<p>Linux 中早期的堆分配与回收由 Doug Lea 实现，但它在并行处理多个线程时，会共享进程的堆内存空间。因此，为了安全性，一个线程使用堆时，会进行加锁。然而，与此同时，加锁会导致其它线程无法使用堆，降低了内存分配和回收的高效性。同时，如果在多线程使用时，没能正确控制，也可能影响内存分配和回收的正确性。Wolfram Gloger 在 Doug Lea 的基础上进行改进使其可以支持多线程，这个堆分配器就是 ptmalloc 。在 glibc-2.3.x. 之后，glibc 中集成了 ptmalloc2。</p>
<p>目前 Linux 标准发行版中使用的堆分配器是 glibc 中的堆分配器：ptmalloc2。ptmalloc2 主要是通过 malloc&#x2F;free 函数来分配和释放内存块。</p>
<p>需要注意的是，在内存分配与使用的过程中，Linux 有这样的一个基本内存管理思想，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p>
<h2 id="堆的基本操作"><a href="#堆的基本操作" class="headerlink" title="堆的基本操作"></a>堆的基本操作</h2><p>这里我们主要介绍</p>
<ul>
<li>基本的堆操作，包括堆的分配，回收，堆分配背后的系统覅用</li>
<li>介绍堆目前的多线程支持</li>
</ul>
<h3 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h3><p>在 glibc 的 <a target="_blank" rel="noopener" href="https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L448">malloc.c</a> 中，malloc 的说明如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span></span><br><span class="line"><span class="comment">  if no space is available. Additionally, on failure, errno is</span></span><br><span class="line"><span class="comment">  set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span></span><br><span class="line"><span class="comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span></span><br><span class="line"><span class="comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span></span><br><span class="line"><span class="comment">  with negative arguments are interpreted as requests for huge amounts</span></span><br><span class="line"><span class="comment">  of space, which will often fail. The maximum supported value of n</span></span><br><span class="line"><span class="comment">  differs across systems, but is in all cases less than the maximum</span></span><br><span class="line"><span class="comment">  representable value of a size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>可以看出，malloc 函数返回对应大小字节的内存块的指针。此外，该函数还对一些异常情况进行了处理</p>
<ul>
<li>当 n&#x3D;0 时，返回当前系统允许的堆的最小内存块。</li>
<li>当 n 为负数时，由于在大多数系统上，<strong>size_t 是无符号数（这一点非常重要）</strong>，所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。</li>
</ul>
<h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>在 glibc 的 <a target="_blank" rel="noopener" href="https://github.com/iromise/glibc/blob/master/malloc/malloc.c#L465">malloc.c</a> 中，free 的说明如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  malloc(size_t n)</span></span><br><span class="line"><span class="comment">  Returns a pointer to a newly allocated chunk of at least n bytes, or null</span></span><br><span class="line"><span class="comment">  if no space is available. Additionally, on failure, errno is</span></span><br><span class="line"><span class="comment">  set to ENOMEM on ANSI C systems.</span></span><br><span class="line"><span class="comment">  If n is zero, malloc returns a minumum-sized chunk. (The minimum</span></span><br><span class="line"><span class="comment">  size is 16 bytes on most 32bit systems, and 24 or 32 bytes on 64bit</span></span><br><span class="line"><span class="comment">  systems.)  On most systems, size_t is an unsigned type, so calls</span></span><br><span class="line"><span class="comment">  with negative arguments are interpreted as requests for huge amounts</span></span><br><span class="line"><span class="comment">  of space, which will often fail. The maximum supported value of n</span></span><br><span class="line"><span class="comment">  differs across systems, but is in all cases less than the maximum</span></span><br><span class="line"><span class="comment">  representable value of a size_t.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>可以看出，free 函数会释放由 p 所指向的内存块。这个内存块有可能是通过 malloc 函数得到的，也有可能是通过相关的函数 realloc 得到的。</p>
<p>此外，该函数也同样对异常情况进行了处理</p>
<ul>
<li><strong>当 p 为空指针时，函数不执行任何操作。</strong></li>
<li>当 p 已经被释放之后，再次释放会出现乱七八糟的效果，这其实就是 <code>double free</code>。</li>
<li>除了被禁用 (mallopt) 的情况下，当释放很大的内存空间时，程序会将这些内存空间还给系统，以便于减小程序所使用的内存空间。</li>
</ul>
<h3 id="内存分配背后的系统调用"><a href="#内存分配背后的系统调用" class="headerlink" title="内存分配背后的系统调用"></a>内存分配背后的系统调用</h3><p>在前面提到的函数中，无论是 malloc 函数还是 free 函数，我们动态申请和释放内存时，都经常会使用，但是它们并不是真正与系统交互的函数。这些函数背后的系统调用主要是 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/sbrk.2.html">(s)brk</a> 函数以及 <a target="_blank" rel="noopener" href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap, munmap</a> 函数。</p>
<p>如下图所示，我们主要考虑对堆进行申请内存块的操作。</p>
<p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_11-08-50.png" alt="1"></p>
<h4 id="s-brk"><a href="#s-brk" class="headerlink" title="(s)brk"></a>(s)brk</h4><p>对于堆的操作，操作系统提供了brk函数，glibc库提供了sbrk函数，我们可以通过增加brk的大小来向操作系统申请内存</p>
<p>初始时，堆的起始地址<code>start_brk</code>以及堆的当前末尾<code>brk</code>指向同一地址。根据是否开启ASLR，两者的具体位置会有所不同</p>
<ul>
<li>不开启 ASLR 保护时，start_brk 以及 brk 会指向 data&#x2F;bss 段的结尾。</li>
<li>开启 ASLR 保护时，start_brk 以及 brk 也会指向同一位置，只是这个位置是在 data&#x2F;bss 段结尾后的随机偏移处。</li>
</ul>
<p>具体效果如下图：</p>
<p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_11-54-13.png" alt="1"></p>
<p>接下来实际操作来深入理解通过改变brk的大小来分配或释放堆</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* sbrk and brk example */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">void</span> *curr_brk, *tmp_brk = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to sbrk example:%d\n&quot;</span>, getpid());</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* sbrk(0) gives current program break location */</span></span><br><span class="line">        tmp_brk = curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program Break Location1:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* brk(addr) increments/decrements program break location */</span></span><br><span class="line">        brk(curr_brk+<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program break Location2:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        brk(tmp_brk);</span><br><span class="line"></span><br><span class="line">        curr_brk = sbrk(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Program Break Location3:%p\n&quot;</span>, curr_brk);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序用于演示程序如何手动控制 <strong>“程序中断点（Program Break）”</strong>（堆内存的边界），理解堆内存动态分配的底层原理。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curr_brk：记录当前程序中断点地址。</span><br><span class="line">tmp_brk：临时保存初始中断点地址，用于后续恢复。</span><br><span class="line">sbrk(0) 作用：返回当前程序中断点的地址（堆内存的 “边界”，堆向上生长的终点）。</span><br><span class="line">getpid()：获取当前进程 ID，方便调试时区分不同进程。</span><br><span class="line">brk 函数作用：手动设置程序中断点的位置。传入新地址 curr_brk+4096 表示扩展堆内存</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是，在每一次执行完操作后，都执行了 getchar() 函数，这是为了我们方便我们查看程序真正的映射。</p>
<p>gcc编译链接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o sbrk sbrk.c</span><br></pre></td></tr></table></figure>

<p>gdb调试sbrk程序观察堆边界变化情况</p>
<p>这里我们可以通过两种方式来查看内存分配情况</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vmmap</span><br><span class="line"><span class="built_in">cat</span> /proc/进程号/maps</span><br></pre></td></tr></table></figure>

<p><strong>在第一次调用brk之前</strong></p>
<p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_12-07-10.png" alt="1"></p>
<p>可以看到并没有出现堆，结合输出可以发现</p>
<p>start_brk &#x3D; brk &#x3D; end_data &#x3D; 0x555555559000</p>
<p><strong>调用完第一个printf之后</strong></p>
<p>出现了堆段，brk &#x3D; 0x5555557a000</p>
<p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_12-14-21.png" alt="1"></p>
<p>觉得应该是在printf函数内部改变了brk的大小</p>
<p>此时调用sbrk(0)可以发现rax存储了此时的brk</p>
<p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_12-16-58.png" alt="1"></p>
<p>接下来我们尝试将brk变大，来扩展堆内存空间</p>
<p><strong>扩展</strong></p>
<p><code>  brk(curr_brk+4096);</code>扩大一页内存</p>
<p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_12-19-14.png" alt="1"></p>
<p>可以看到此时brk变为了0x55555557b000堆空间得到了拓展</p>
<p>接下来将brk变小释放刚刚扩展的堆空间</p>
<p><strong>释放</strong></p>
<p><code> brk(tmp_brk);</code>将brk变回初始的0x55555557a000</p>
<p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_12-23-43.png" alt="1"></p>
<p>可以看到此时brk变为了0x55555557a000刚刚扩展的部分得到了释放</p>
<h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p>malloc 会使用 <a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/mm/mmap.c?v=3.8#L1285">mmap</a> 来创建独立的匿名映射段。匿名映射的目的主要是可以申请以 0 填充的内存，并且这块内存仅被调用进程所使用。</p>
<p>同样的我们通过一个程序来深入理解</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Private anonymous mapping example using mmap syscall */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="type">static</span> <span class="keyword">inline</span> <span class="title function_">errExit</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* msg)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s failed. Exiting the process\n&quot;</span>, msg);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to private anonymous mapping example::PID:%d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before mmap\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="type">char</span>* addr = <span class="literal">NULL</span>;</span><br><span class="line">        addr = mmap(<span class="literal">NULL</span>, (<span class="type">size_t</span>)<span class="number">132</span>*<span class="number">1024</span>, PROT_READ|PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (addr == MAP_FAILED)</span><br><span class="line">                errExit(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After mmap\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Unmap mapped region. */</span></span><br><span class="line">        ret = munmap(addr, (<span class="type">size_t</span>)<span class="number">132</span>*<span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret == <span class="number">-1</span>)</span><br><span class="line">                errExit(<span class="string">&quot;munmap&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After munmap\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gcc编译链接</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o mmap mmap.c</span><br></pre></td></tr></table></figure>

<p>调用mmap前的内存段</p>
<p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_12-40-08.png" alt="1"></p>
<p>可以看到调用mmap后内存段的变大了</p>
<p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_12-36-50.png" alt="1"></p>
<p>调用munmap后内存段恢复</p>
<p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_12-38-34.png" alt="1"></p>
<h3 id="多线程支持"><a href="#多线程支持" class="headerlink" title="多线程支持"></a>多线程支持</h3><blockquote>
<p>在原来的 dlmalloc 实现中，当两个线程同时要申请内存时，只有一个线程可以进入临界区申请内存，而另外一个线程则必须等待直到临界区中不再有线程。这是因为所有的线程共享一个堆。在 glibc 的 ptmalloc 实现中，比较好的一点就是支持了多线程的快速访问。在新的实现中，所有的线程共享多个堆。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Per thread arena example. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span>* <span class="title function_">threadFunc</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in thread 1\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="type">char</span>* addr = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in thread 1\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in thread 1\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">pthread_t</span> t1;</span><br><span class="line">        <span class="type">void</span>* s;</span><br><span class="line">        <span class="type">int</span> ret;</span><br><span class="line">        <span class="type">char</span>* addr;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Welcome to per thread arena example::%d\n&quot;</span>,getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Before malloc in main thread\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        addr = (<span class="type">char</span>*) <span class="built_in">malloc</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After malloc and before free in main thread\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        <span class="built_in">free</span>(addr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;After free in main thread\n&quot;</span>);</span><br><span class="line">        getchar();</span><br><span class="line">        ret = pthread_create(&amp;t1, <span class="literal">NULL</span>, threadFunc, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread creation error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = pthread_join(t1, &amp;s);</span><br><span class="line">        <span class="keyword">if</span>(ret)</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;Thread join error\n&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第一次申请之前</strong>， 没有任何任何堆段。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc <span class="keyword">in</span> main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ <span class="built_in">cat</span> /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<p><strong>第一次申请后</strong>， 从下面的输出可以看出，堆段被建立了，并且它就紧邻着数据段，这说明 malloc 的背后是用 brk 函数来实现的。同时，需要注意的是，我们虽然只是申请了 1000 个字节，但是我们却得到了 0x0806c000-0x0804b000&#x3D;0x21000 个字节的堆。<strong>这说明虽然程序可能只是向操作系统申请很小的内存，但是为了方便，操作系统会把很大的内存分配给程序。这样的话，就避免了多次内核态与用户态的切换，提高了程序的效率。</strong>我们称这一块连续的内存区域为 arena。此外，我们称由主线程申请的内存为 main_arena。后续的申请的内存会一直从这个 arena 中获取，直到空间不足。当 arena 空间不足时，它可以通过增加 brk 的方式来增加堆的空间。类似地，arena 也可以通过减小 brk 来缩小自己的空间。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc <span class="keyword">in</span> main thread</span><br><span class="line">After malloc and before free <span class="keyword">in</span> main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ <span class="built_in">cat</span> /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<p><strong>在主线程释放内存后</strong>，我们从下面的输出可以看出，其对应的 arena 并没有进行回收，而是交由 glibc 来进行管理。当后面程序再次申请内存时，在 glibc 中管理的内存充足的情况下，glibc 就会根据堆分配的算法来给程序分配相应的内存。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc <span class="keyword">in</span> main thread</span><br><span class="line">After malloc and before free <span class="keyword">in</span> main thread</span><br><span class="line">After free <span class="keyword">in</span> main thread</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/lsploits/hof/ptmalloc.ppt/mthread$ <span class="built_in">cat</span> /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7e05000-b7e07000 rw-p 00000000 00:00 0</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<p><strong>在第一个线程 malloc 之前</strong>，我们可以看到并没有出现与线程 1 相关的堆，但是出现了与线程 1 相关的栈。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc <span class="keyword">in</span> main thread</span><br><span class="line">After malloc and before free <span class="keyword">in</span> main thread</span><br><span class="line">After free <span class="keyword">in</span> main thread</span><br><span class="line">Before malloc <span class="keyword">in</span> thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ <span class="built_in">cat</span> /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0</span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<p><strong>第一个线程 malloc 后</strong>， 我们可以从下面输出看出线程 1 的堆段被建立了。而且它所在的位置为内存映射段区域，同样大小也是 132KB(b7500000-b7521000)。因此这表明该线程申请的堆时，背后对应的函数为 mmap 函数。同时，我们可以看出实际真的分配给程序的内存为 1M(b7500000-b7600000)。而且，只有 132KB 的部分具有可读可写权限，这一块连续的区域成为 thread arena。</p>
<p>注意：</p>
<blockquote>
<p>当用户请求的内存大于 128KB 时，并且没有任何 arena 有足够的空间时，那么系统就会执行 mmap 函数来分配相应的内存空间。这与这个请求来自于主线程还是从线程无关。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc <span class="keyword">in</span> main thread</span><br><span class="line">After malloc and before free <span class="keyword">in</span> main thread</span><br><span class="line">After free <span class="keyword">in</span> main thread</span><br><span class="line">Before malloc <span class="keyword">in</span> thread 1</span><br><span class="line">After malloc and before free <span class="keyword">in</span> thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ <span class="built_in">cat</span> /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7500000-b7521000 rw-p 00000000 00:00 0</span><br><span class="line">b7521000-b7600000 ---p 00000000 00:00 0</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0</span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>

<p><strong>在第一个线程释放内存后</strong>， 我们可以从下面的输出看到，这样释放内存同样不会把内存重新给系统。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ ./mthread</span><br><span class="line">Welcome to per thread arena example::6501</span><br><span class="line">Before malloc <span class="keyword">in</span> main thread</span><br><span class="line">After malloc and before free <span class="keyword">in</span> main thread</span><br><span class="line">After free <span class="keyword">in</span> main thread</span><br><span class="line">Before malloc <span class="keyword">in</span> thread 1</span><br><span class="line">After malloc and before free <span class="keyword">in</span> thread 1</span><br><span class="line">After free <span class="keyword">in</span> thread 1</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$ <span class="built_in">cat</span> /proc/6501/maps</span><br><span class="line">08048000-08049000 r-xp 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">08049000-0804a000 r--p 00000000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804a000-0804b000 rw-p 00001000 08:01 539625     /home/sploitfun/ptmalloc.ppt/mthread/mthread</span><br><span class="line">0804b000-0806c000 rw-p 00000000 00:00 0          [heap]</span><br><span class="line">b7500000-b7521000 rw-p 00000000 00:00 0</span><br><span class="line">b7521000-b7600000 ---p 00000000 00:00 0</span><br><span class="line">b7604000-b7605000 ---p 00000000 00:00 0</span><br><span class="line">b7605000-b7e07000 rw-p 00000000 00:00 0          [stack:6594]</span><br><span class="line">...</span><br><span class="line">sploitfun@sploitfun-VirtualBox:~/ptmalloc.ppt/mthread$</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="堆相关数据结构"><a href="#堆相关数据结构" class="headerlink" title="堆相关数据结构"></a>堆相关数据结构</h1><p>堆的操作就这么复杂，那么在 glibc 内部必然也有精心设计的数据结构来管理它。与堆相应的数据结构主要分为</p>
<ul>
<li>宏观结构，包含堆的宏观信息，可以通过这些数据结构索引堆的基本信息。</li>
<li>微观结构，用于具体处理堆的分配与回收中的内存块。</li>
</ul>
<h2 id="微观结构"><a href="#微观结构" class="headerlink" title="微观结构"></a>微观结构</h2><p>这里首先介绍堆的一些主要内部结构，<strong>堆的漏洞利用与这些结构密切相关</strong>。</p>
<h3 id="malloc-chunk"><a href="#malloc-chunk" class="headerlink" title="malloc_chunk"></a>malloc_chunk</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在程序的执行过程中，我们称由malloc申请的内存为<code>chunk</code>。这块内存在ptmalloc内部用malloc_chunk结构体来表示。当程序申请的<code>chunk</code>被free后，会被加入到相应的空闲管理列表中。</p>
<p><strong>无论一个<code>chunk</code>的大小如何，处于分配状态还是释放状态，它们都使用一个统一的结构。</strong>虽然它们使用了同一个数据结构，但是根据是否被释放，它们的表现形式会有所不同。</p>
<p>malloc_chunk 的结构体如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  This struct declaration is misleading (but accurate and necessary).</span></span><br><span class="line"><span class="comment">  It declares a &quot;view&quot; into memory allowing access to necessary</span></span><br><span class="line"><span class="comment">  fields at known offsets from a given base. See explanation below.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* 前一个chunk的大小（仅当前一个chunk空闲时有效） */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* 当前chunk的总大小（包含头部和数据区） */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* 双向链表指针：指向下一个空闲chunk */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span>         <span class="comment">/* 双向链表指针：指向前一个空闲chunk */</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* 仅用于大内存块：维护更大尺寸的chunk链表 */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一些必要的宏定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* INTERNAL_SIZE_T is the word-size used for internal bookkeeping of</span></span><br><span class="line"><span class="comment">   chunk sizes.</span></span><br><span class="line"><span class="comment">   The default version is the same as size_t.</span></span><br><span class="line"><span class="comment">   While not strictly necessary, it is best to define this as an</span></span><br><span class="line"><span class="comment">   unsigned type, even if size_t is a signed type. This may avoid some</span></span><br><span class="line"><span class="comment">   artificial size limitations on some systems.</span></span><br><span class="line"><span class="comment">   On a 64-bit machine, you may be able to reduce malloc overhead by</span></span><br><span class="line"><span class="comment">   defining INTERNAL_SIZE_T to be a 32 bit `unsigned int&#x27; at the</span></span><br><span class="line"><span class="comment">   expense of not being able to handle more than 2^32 of malloced</span></span><br><span class="line"><span class="comment">   space. If this limitation is acceptable, you are encouraged to set</span></span><br><span class="line"><span class="comment">   this unless you are on a platform requiring 16byte alignments. In</span></span><br><span class="line"><span class="comment">   this case the alignment requirements turn out to negate any</span></span><br><span class="line"><span class="comment">   potential advantages of decreasing size_t word size.</span></span><br><span class="line"><span class="comment">   Implementors: Beware of the possible combinations of:</span></span><br><span class="line"><span class="comment">     - INTERNAL_SIZE_T might be signed or unsigned, might be 32 or 64 bits,</span></span><br><span class="line"><span class="comment">       and might be the same width as int or as long</span></span><br><span class="line"><span class="comment">     - size_t might have different width and signedness as INTERNAL_SIZE_T</span></span><br><span class="line"><span class="comment">     - int and long might be 32 or 64 bits, and might be the same width</span></span><br><span class="line"><span class="comment">   To deal with this, most comparisons and difference computations</span></span><br><span class="line"><span class="comment">   among INTERNAL_SIZE_Ts should cast them to unsigned long, being</span></span><br><span class="line"><span class="comment">   aware of the fact that casting an unsigned int to a wider long does</span></span><br><span class="line"><span class="comment">   not sign-extend. (This also makes checking for negative numbers</span></span><br><span class="line"><span class="comment">   awkward.) Some of these casts result in harmless compiler warnings</span></span><br><span class="line"><span class="comment">   on some systems.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> INTERNAL_SIZE_T</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> INTERNAL_SIZE_T size_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding word size.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_SZ (sizeof (INTERNAL_SIZE_T))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding bit mask value.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGN_MASK (MALLOC_ALIGNMENT - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* MALLOC_ALIGNMENT is the minimum alignment for malloc&#x27;ed chunks.  It</span></span><br><span class="line"><span class="comment">   must be a power of two at least 2 * SIZE_SZ, even on machines for</span></span><br><span class="line"><span class="comment">   which smaller alignments would suffice. It may be defined as larger</span></span><br><span class="line"><span class="comment">   than this though. Note however that code and data structures are</span></span><br><span class="line"><span class="comment">   optimized for the case of 8-byte alignment.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT (2 * SIZE_SZ &lt; __alignof__ (long double) \</span></span><br><span class="line"><span class="meta">              ? __alignof__ (long double) : 2 * SIZE_SZ)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>一般来说， <code>size_t</code> 被定义为 <code>unsigned long</code> ，其在 64 位中是 64 位无符号整数，32 位中是 32 位无符号整数。</p>
</blockquote>
<p>接下来逐个解释chunk结构体的各个字段</p>
<p><strong>结构体设计的 “误导性”</strong></p>
<p>注释提到该结构体是一种 “视图（view）”，原因在于：</p>
<ul>
<li><p><strong>双重角色</strong>：同一个结构体既要表示<strong>已分配的内存块</strong>，也要表示<strong>空闲的内存块</strong>。</p>
</li>
<li><p>字段复用</p>
<p>：</p>
<ul>
<li>当 chunk 被分配时，<code>fd</code> 和 <code>bk</code> 指针不使用（被应用程序数据覆盖）。</li>
<li>仅当 chunk 空闲时，<code>fd</code> 和 <code>bk</code> 才构成双向链表，用于快速查找可用内存。</li>
</ul>
</li>
<li><p><strong><code>prev_size</code></strong></p>
<ul>
<li>若物理相邻的前一个 chunk 是空闲的，则存储其大小（包括chunk头）。</li>
<li>若物理相邻的前一个 chunk 已分配，则该字段被前一个 chunk 的数据覆盖（节省空间）。</li>
</ul>
</li>
<li><p>**<code>size</code>**该chunk的大小，大小必须是<code>MALLOC_ALIGNMENT</code>的整数倍。如果申请的内存大小不是<code>MALLOC_ALIGNMENT</code>的整数倍，会被转换为满足大小的最小的<code>MALLOC_ALIGNMENT</code>的倍数，这通过<code>request2size()</code>宏完成。32位系统中，<code>MALLOC_ALIGNMENT</code>可能是 4 或 8 ；64位系统中，<code>MALLOC_ALIGNMENT</code>是 8 。该字段的低三个比特位对<code>chunk</code>的大小没有影响为标志位，他们从高到低分别表示：</p>
<ul>
<li>NON_MAIN_ARENA，记录当前<code>chunk</code>是否不属于主线程，1表示不属于，0表示属于。</li>
<li>IS_MAPPED，记录当前<code>chunk</code>是否是由mmap分配的。</li>
<li>PREV_INUSE，记录前一个<code>chunk</code>块是否被分配。一般来说，堆中第一个被分配的内存块的size字段的p位都会设置为1，以便于防止访问前面的非法内存。当一个<code>chunk</code>的size的p位为0时，我们能通过<code>prev_size</code>字段来获取上一个<code>chunk</code>的大小以及地址。这也方便进行空闲<code>chunk</code>之间的合并</li>
</ul>
</li>
<li><p><strong><code>fd,bk</code></strong> <code>chunk</code>处于分配状态时，从fd字段开始是用户的数据。<code>chunk</code>空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下</p>
<pre><code>- fd 指向下一个（非物理相邻）空闲的`chunk`
- bk 指向上一个（非物理相邻）空闲的`chunk`
- 通过 fd 和 bk 可以将空闲的`chunk`块加入到空闲的`chunk`块链表进行统一管理
</code></pre>
</li>
<li><p><strong><code>fd_nextsize，bk_nextsize</code></strong> 只有chunk空闲时才使用，不过其用于较大的<code>chunk</code>（<code>large chunk</code>大内存块）</p>
<pre><code>- fd_nextsize 指向前一个与当前 `chunk` **大小不同**的第一个空闲块，不包含 bin 的头指针
- bk_nextsize 指向后一个与当前`chunk`**大小不同**的第一个空闲块，不包含 bin 的头指针
- 一般空闲的`large chunk`在fd的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适chunk时挨个遍历 ，加速寻找过程
</code></pre>
</li>
</ul>
<blockquote>
<p>自 glibc 2.26 版本起，在 32 位 glibc 中，<code>MALLOC_ALIGNMENT</code> 宏的定义在编译时优先选择 <code>sysdeps/i386/malloc-alignment.h</code> 当中的定义，该值定义为一个常量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MALLOC_ALIGNMENT 16</span></span><br></pre></td></tr></table></figure>

<p>因此，对于自 2.26 版本起始的 32 位 glibc，其 <code>MALLOC_ALIGNMENT</code> 并非基于 <code>SIZE_SZ</code> 计算的 <code>8</code> ，而是和 64 位 glibc 所用值相同的 <code>16</code>。</p>
</blockquote>
<p>一个已经分配的<code>chunk</code>的样子如下，我们称前两个字段为<code>chunk header</code>，后面的部分称为<code>user data</code>。每次malloc申请得到的内存指针，其实指向<code>user data</code>的起始处。</p>
<p>当一个 <code>chunk</code> 处于使用状态时，它的下一个 <code>chunk</code> 的 prev_size 域无效，所以下一个 <code>chunk</code> 的该部分也可以被当前 chunk 使用。<strong>这就是 chunk 中的空间复用。</strong></p>
<p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_15-32-02.png" alt="1"></p>
<p>被释放的 <code>chunk</code> 被记录在链表中（可能是循环双向链表，也可能是单向链表）。具体结构如下</p>
<p><img src="/../images/%E5%A0%86/Snipaste_2025-06-10_15-34-07.png" alt="1"></p>
<p>可以发现，如果一个 <code>chunk</code> 处于 free 状态，那么会有两个位置记录其相应的大小</p>
<ol>
<li>本身的 size 字段会记录，</li>
<li>它后面的 <code>chunk</code> 会记录。</li>
</ol>
<p><strong>一般情况下</strong>，物理相邻的两个空闲 <code>chunk</code> 会被合并为一个 <code>chunk</code> 。堆管理器会通过 prev_size 字段以及 size 字段合并两个物理相邻的空闲 <code>chunk</code> 块。</p>
<h4 id="chunk-相关宏"><a href="#chunk-相关宏" class="headerlink" title="chunk 相关宏"></a>chunk 相关宏</h4><blockquote>
<p>介绍一些宏定义里用到的内存计算指令</p>
<p>按位取反（~）</p>
<p>~7 &#x3D; 0xFFFFFFF8</p>
<p>47 &amp; ~7 &#x3D; 47 &amp; 0xFFFFFFF8 &#x3D; 40（将数值 <strong>47</strong> 向下舍入到 <strong>8 字节对齐</strong> 的边界，即找到 <strong>≤47</strong> 且为 <strong>8 的倍数</strong> 的最大数值）</p>
<p>&amp;<strong>按位与（Bitwise AND）运算</strong>，用于将数值 <strong>47</strong> 对齐到 <strong>8 字节边界</strong></p>
</blockquote>
<p>这里主要介绍<code>chunk</code>的大小、对齐检查以及一些转换的宏 </p>
<p><strong>chunk 与 mem 指针头部的转换</strong></p>
<p>mem 指向用户得到的内存的起始位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*从 malloc 头部（chunk）到用户指针（mem）的转换，以及反向转换。*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p) ((void *) ((char *) (p) + 2 * SIZE_SZ))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem2chunk(mem) ((mchunkptr)((char *) (mem) -2 * SIZE_SZ))</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>chunk2mem(p)</code>：将 <code>chunk</code> 指针（指向 <code>malloc_chunk</code> 结构体）转换为用户实际可用的内存指针（跳过 <code>prev_size</code> 和 <code>size</code> 字段，指向用户数据区起始位置）。</li>
<li><code>mem2chunk(mem)</code>：将用户内存指针反向转换为 <code>chunk</code> 指针（回溯两个 <code>SIZE_SZ</code> 大小的偏移，指向 <code>malloc_chunk</code> 结构体起始位置）。</li>
<li><strong>关键</strong>：<code>SIZE_SZ</code> 为 <code>INTERNAL_SIZE_T</code> 的字节数（32 位系统为 4，64 位为 8），因此偏移量为 <code>2 * SIZE_SZ</code>（即 <code>prev_size</code> 和 <code>size</code> 字段总长度）。</li>
</ul>
<p><strong>最小的<code>chunk</code>大小</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 最小可能的 chunk 大小。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_CHUNK_SIZE (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用 <code>offsetof</code> 计算 <code>malloc_chunk</code> 结构体中 <code>fd_nextsize</code> 字段的偏移量，即 <code>chunk</code> 至少需包含 <code>prev_size</code>、<code>size</code>、<code>fd</code>、<code>bk</code> 字段（<code>fd_nextsize</code> 为 large bin 专用，最小块不包含）。</li>
<li><strong>实际含义</strong>：最小 <code>chunk</code> 大小为 <code>2 * SIZE_SZ（prev_size + size） + 2 * sizeof(void*)（fd + bk）</code>，确保双向链表基本结构。</li>
</ul>
<p><strong>最小申请的堆内存大小</strong></p>
<p>用户最小申请的内存大小必须是 2*SIZE_SE 的最下整数倍</p>
<p>注：就目前而看 MIN_CHUNK_SIZE 和 MINSIZE 大小是一致的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* malloc 能申请的最小大小为对齐后的最小块 */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINSIZE                                                                \</span></span><br><span class="line"><span class="meta">    (unsigned long) (((MIN_CHUNK_SIZE + MALLOC_ALIGN_MASK) &amp;                   \</span></span><br><span class="line"><span class="meta">                      ~MALLOC_ALIGN_MASK))</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>MALLOC_ALIGN_MASK</code> 为对齐掩码（值为 <code>MALLOC_ALIGNMENT - 1</code>，如 64 位系统为 <code>0xf</code>）。</li>
<li>计算逻辑：将 <code>MIN_CHUNK_SIZE</code> 向上对齐到 <code>MALLOC_ALIGNMENT</code> 的倍数，确保内存地址对齐（如 64 位系统对齐 16 字节）。</li>
<li><strong>示例</strong>：若 <code>MIN_CHUNK_SIZE</code> 为 <code>0x20</code>（32 字节），<code>MALLOC_ALIGNMENT</code> 为 16，则 <code>MINSIZE</code> 为 <code>0x20</code>（已对齐）。</li>
</ul>
<p><strong>检查分配给用户的内存是否对齐</strong></p>
<p>2 * SIZE_SZ 大小对齐</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 检查 m 是否符合对齐要求 */</span></span><br><span class="line"><span class="comment">// MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m) (((unsigned long) (m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> misaligned_chunk(p)                                                    \</span></span><br><span class="line"><span class="meta">    ((uintptr_t)(MALLOC_ALIGNMENT == 2 * SIZE_SZ ? (p) : chunk2mem(p)) &amp;       \</span></span><br><span class="line"><span class="meta">     MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure>

<p><strong>请求字节数判断</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  检查请求是否过大，导致在填充和对齐后其值会绕零回环（即溢出）。为简化其他代码逻辑，边界值被设得足够低，确保加上最小尺寸（MINSIZE）后也不会发生绕零回环。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                              \</span></span><br><span class="line"><span class="meta">    ((unsigned long) (req) &gt;= (unsigned long) (INTERNAL_SIZE_T)(-2 * MINSIZE))</span></span><br></pre></td></tr></table></figure>

<p><strong>将用户请求内存大小转为实际分配内存大小</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将用户请求的字节数转换为可用的块大小（内部版本） */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req)                                                      \</span></span><br><span class="line"><span class="meta">    (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)                           \</span></span><br><span class="line"><span class="meta">         ? MINSIZE                                                             \</span></span><br><span class="line"><span class="meta">         : ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  相同，但同时执行参数检查 */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> checked_request2size(req, sz)                                          \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE(req)) &#123;                                           \</span></span><br><span class="line"><span class="meta">        __set_errno(ENOMEM);                                                   \</span></span><br><span class="line"><span class="meta">        return 0;                                                              \</span></span><br><span class="line"><span class="meta">    &#125;                                                                          \</span></span><br><span class="line"><span class="meta">    (sz) = request2size(req);</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>步骤 1</strong>：判断请求大小 <code>req</code> 加上 <code>SIZE_SZ</code>（预留 <code>size</code> 字段空间）和对齐掩码后的总大小是否小于 <code>MINSIZE</code>。</li>
<li><strong>步骤 2</strong>：若小于，直接返回 <code>MINSIZE</code>（强制分配最小块）；否则，通过掩码对齐到 <code>MALLOC_ALIGNMENT</code> 的倍数。</li>
<li><strong>核心逻辑</strong>：确保用户数据区大小为 <code>req</code>，但整个 <code>chunk</code> 需包含头部（<code>prev_size</code> 和 <code>size</code>）并满足对齐要求。</li>
</ul>
<p>当一个 <code>chunk</code> 处于已分配状态时，它的物理相邻的下一个 <code>chunk</code> 的 prev_size 字段必然是无效的，故而这个字段就可以被当前这个 <code>chunk</code> 使用。这就是 ptmalloc 中 <code>chunk</code> 间的复用。具体流程如下</p>
<ol>
<li>首先，利用 REQUEST_OUT_OF_RANGE 判断是否可以分配用户请求的字节大小的 chunk。</li>
<li>其次，需要注意的是用户请求的字节是用来存储数据的，即 <code>chunk header</code> 后面的部分。与此同时，由于 chunk 间复用，所以可以使用下一个 <code>chunk</code> 的 prev_size 字段。因此，这里只需要再添加 SIZE_SZ 大小即可以完全存储内容。</li>
<li>由于系统中所允许的申请的 <code>chunk</code> 最小是 MINSIZE，所以与其进行比较。如果不满足最低要求，那么就需要直接分配 MINSIZE 字节。</li>
<li>如果大于的话，因为系统中申请的 <code>chunk</code> 需要 2 * SIZE_SZ 对齐，所以这里需要加上 MALLOC_ALIGN_MASK 以便于对齐。</li>
</ol>
<p><strong>标记位相关</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 当相邻的前一个内存块（chunk）被使用时，size字段会与PREV_INUSE进行按位或操作 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_INUSE 0x1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 提取前一个内存块的使用状态位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_inuse(p) ((p)-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果内存块是通过mmap()分配的，size字段会与IS_MMAPPED进行按位或操作 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IS_MMAPPED 0x2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检查内存块是否通过mmap()分配 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;mchunk_size &amp; IS_MMAPPED)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果内存块来自非主分配区（non-main arena），size字段会与NON_MAIN_ARENA进行按位或操作。</span></span><br><span class="line"><span class="comment">   该标志仅在必要时，在将内存块交给用户前设置。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NON_MAIN_ARENA 0x4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 检查内存块是否来自主分配区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_main_arena(p) (((p)-&gt;mchunk_size &amp; NON_MAIN_ARENA) == 0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将内存块标记为非主分配区 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_non_main_arena(p) ((p)-&gt;mchunk_size |= NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   提取内存块大小时需要屏蔽的位</span></span><br><span class="line"><span class="comment">   注意：在设计上，对于不应该出现mmap内存块的宏，IS_MMAPPED标志不会从size字段中屏蔽。</span></span><br><span class="line"><span class="comment">   这可以在有人意外扩展或修改此malloc实现时，通过核心转储（core dump）提供有效提示。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br></pre></td></tr></table></figure>

<p>**获取 chunk size **</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取内存块大小（忽略使用标志位） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize(p) (chunksize_nomask(p) &amp; ~(SIZE_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 与 chunksize 功能类似，但不屏蔽 SIZE_BITS 标志位  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunksize_nomask(p) ((p)-&gt;mchunk_size)</span></span><br></pre></td></tr></table></figure>

<p><strong>获取下一个物理相邻的 chunk</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 指向下一个物理相邻的 chunk 指针。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_chunk(p) ((mchunkptr)(((char *) (p)) + chunksize(p)))</span></span><br></pre></td></tr></table></figure>

<p>通过 <code>chunksize(p)</code> 获取当前块总大小（含头部），计算下一块起始地址（当前地址 + 块大小）</p>
<p><strong>获取前一个 chunk 的信息</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 获取 p 下方块的大小，仅当前一块空闲时有效。  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_size(p) ((p)-&gt;mchunk_prev_size)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置 p 下方块的大小。仅当 !prev_inuse(P) 时有效。  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_prev_size(p, sz) ((p)-&gt;mchunk_prev_size = (sz))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指向物理上前一个 malloc_chunk 的指针。仅当 !prev_inuse(P) 时有效  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> prev_chunk(p) ((mchunkptr)(((char *) (p)) - prev_size(p)))</span></span><br></pre></td></tr></table></figure>

<p><strong>当前 chunk 使用状态相关操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 提取 p 的使用状态位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)                                                               \</span></span><br><span class="line"><span class="meta">    ((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 提取 p 的使用状态位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)                                                               \</span></span><br><span class="line"><span class="meta">    ((((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 清除块的使用状态标记，不干扰其他标志 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse(p)                                                         \</span></span><br><span class="line"><span class="meta">    ((mchunkptr)(((char *) (p)) + chunksize(p)))-&gt;mchunk_size &amp;= ~(PREV_INUSE)</span></span><br></pre></td></tr></table></figure>

<p><strong>设置 chunk 的 size 字段</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 设置头部的大小，不干扰其使用标志位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head_size(p, s)                                                    \</span></span><br><span class="line"><span class="meta">    ((p)-&gt;mchunk_size = (((p)-&gt;mchunk_size &amp; SIZE_BITS) | (s)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置头部的大小/使用标志字段 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_head(p, s) ((p)-&gt;mchunk_size = (s))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置尾部的大小（仅当内存块未被使用时） */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_foot(p, s)                                                         \</span></span><br><span class="line"><span class="meta">    (((mchunkptr)((char *) (p) + (s)))-&gt;mchunk_prev_size = (s))</span></span><br></pre></td></tr></table></figure>

<p><strong>获取指定偏移的 chunk</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 将 ptr + offset 位置的空间视为一个 chunk */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk_at_offset(p, s) ((mchunkptr)(((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure>

<p><strong>指定偏移处 chunk 使用状态相关操作</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 检查 p + s 位置的内存块的使用状态位 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inuse_bit_at_offset(p, s)                                              \</span></span><br><span class="line"><span class="meta">    (((mchunkptr)(((char *) (p)) + (s)))-&gt;mchunk_size &amp; PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置 p + s 位置的内存块为已使用状态 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_inuse_bit_at_offset(p, s)                                          \</span></span><br><span class="line"><span class="meta">    (((mchunkptr)(((char *) (p)) + (s)))-&gt;mchunk_size |= PREV_INUSE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 清除 p + s 位置的内存块的使用状态标志 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_inuse_bit_at_offset(p, s)                                        \</span></span><br><span class="line"><span class="meta">    (((mchunkptr)(((char *) (p)) + (s)))-&gt;mchunk_size &amp;= ~(PREV_INUSE))</span></span><br></pre></td></tr></table></figure>

<h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><ul>
<li><code>bin</code> 本质是双向链表，用于链接空闲的<code>chunk</code>。每 bin的 header 包含两个指针：<ul>
<li><code>fd</code>（forward）：指向下一个空闲 <code>chunk</code>。</li>
<li><code>bk</code>（backward）：指向前一个空闲 <code>chunk</code>。</li>
</ul>
</li>
<li>由于 <code>malloc_chunk</code> 结构体中天然包含 <code>fd</code> 和 <code>bk</code> 字段（仅在空闲时使用），<code>bin</code> 的 header 可以直接作为链表的 “虚拟头结点”，方便插入、删除操作。</li>
</ul>
<p>我们曾经说过，用户释放掉的 <code>chunk</code> 不会马上归还给系统，ptmalloc 会统一管理 heap 和 mmap 映射区域中的空闲的 chunk。当用户再一次请求分配内存时，ptmalloc 分配器会试图在空闲的 chunk 中挑选一块合适的给用户。这样可以避免频繁的系统调用，降低内存分配的开销。</p>
<p>在具体的实现中，ptmalloc采用分箱式方法(bin)对空闲的<code>chunk</code>进行管理。首先，它会根据空闲的<code>chunk</code>的大小以及使用状态将<code>chunk</code>初步分为4类：fast bins，small bins，large bins，unsorted bin。在每类bin的内部仍然会有多个互不相关的链表来保存不同大小的chunk。</p>
<p>对于small bins，large bins，unsorted bin来说，ptmalloc将它们维护在同一个数组中。这些 bin 对应的数据结构在 malloc_state 中，如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NBINS 128</span></span><br><span class="line"><span class="comment">/*  如上文所述打包的常规 bins */</span></span><br><span class="line">mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ];</span><br></pre></td></tr></table></figure>

<p><code>bins</code> 主要用于索引不同 bin 的 fd 和 bk。</p>
<p>为了简化在双链接列表中的使用，每个 bin 的header都设置为 malloc_chunk 类型。这样可以避免 header 类型及其特殊处理。但是，为了节省空间和提高局部性，只分配 bin 的fd&#x2F;bk 指针，然后使用repositioning tricks 将这些指针视为一个<code>malloc_chunk*</code>的字段。</p>
<p>以32位系统为例，bins前4项的含义如下</p>
<table>
<thead>
<tr>
<th align="left">含义</th>
<th align="left">bin1 的 fd&#x2F;bin2 的 prev_size</th>
<th align="left">bin1 的 bk&#x2F;bin2 的 size</th>
<th align="left">bin2 的 fd&#x2F;bin3 的 prev_size</th>
<th align="left">bin2 的 bk&#x2F;bin3 的 size</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bin 下标</td>
<td align="left">0</td>
<td align="left">1</td>
<td align="left">2</td>
<td align="left">3</td>
</tr>
</tbody></table>
<p>可以看到，bin2 的 prev_size、size 和 bin1 的 fd、bks是重合的。由于我们只会使用 fd 和 bk 来索引链表，所以该重合部分的数据其实记录的是 bin1 的 fd 、bk。也就是说，虽然后一个 bin 和前一个 bin 共用部分数据，但是其实记录的仍然是前一个 bin 的链表数据。通过这样的复用，可以节省空间。</p>
<p>数组中的 bin 依次如下</p>
<p>1.第一个为 unsorted bin（未排序的箱子），这里面的<code>chunk</code>没有进行排序，存储的<code>chunk</code>比较杂。</p>
<p>2.索引从2到63的 bin 称为 small bin，同一个 small bin 链表中的<code>chunk</code>的大小相同。两个相邻索引的 small bin 链表中的<code>chunk</code>大小相差的字节数为<strong>2个机器字长</strong>，即32位相差8字节，64位相差16字节。</p>
<p>3.small bins 后面的 bin 被称作 large bins。large bins中的每一个 bin 都包含一定范围内的 chunk，其中的 chunk 按 fd 指针的顺序从大到小排列。相同大小的chunk同样按照最近使用顺序排列。</p>
<p>此外，上述这些 bin 的排布都会遵循一个原则: <strong>任意两个物理相邻的空闲 chunk 不能在一起</strong></p>
<blockquote>
<p><strong>示例</strong>：若内存中有块 A（已用）、块 B（空闲）、块 C（空闲），则块 B 和 C 因物理相邻违反规则，需通过分配其他数据或合并为一个大块来调整。</p>
</blockquote>
<p>需要注意的是，并不是所有的<code>chunk</code>被释放后就立即被放到 bin 中。ptmalloc 为了提高分配的速度，会把一些小的<code>chunk</code>先放到 fast bins 的容器内。而且，fastbin容器中的<code>chunk</code>的使用标记总是被置位的，所以不满足上面的原则。</p>
<p>bin 通用的宏如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> bin_at(m, i)                                                           \</span></span><br><span class="line"><span class="meta">    (mbinptr)(((char *) &amp;((m)-&gt;bins[ ((i) -1) * 2 ])) -                        \</span></span><br><span class="line"><span class="meta">              offsetof(struct malloc_chunk, fd))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="comment">//获取下一个bin的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_bin(b) ((mbinptr)((char *) (b) + (sizeof(mchunkptr) &lt;&lt; 1)))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="comment">// 这两个宏可以用来遍历bin</span></span><br><span class="line"><span class="comment">// 获取 bin 的位于链表头的 chunk</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> first(b) ((b)-&gt;fd)</span></span><br><span class="line"><span class="comment">// 获取 bin 的位于链表尾的 chunk</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> last(b) ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure>

<h4 id="Fast-Bin"><a href="#Fast-Bin" class="headerlink" title="Fast Bin"></a>Fast Bin</h4><p>大多数程序经常会申请以及释放一些比较小的内存块。如果将一些较小的<code>chunk</code>释放之后发现存在与之相邻的空闲的<code>chunk</code>并将它们进行合并，那么当下一次再次申请相应大小的<code>chunk</code>时，就需要对<code>chunk</code>进行分割，这样就大大降低了堆的利用效率。<strong>因为我们把大部分时间花在了合并、分割以及中间检查的过程中</strong>。因此，prmalloc中专门设计了 fast bin，对应的变量就是malloc state 中的 fastbinsY</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">*/快速链表</span><br><span class="line">一个存储最近释放的小块内存的链表数组。快速链表不是双向链表。将它们单向链接会更快，而且由于内存块永远不会从这些链表的中间移除，所以双向链接没有必要。此外，与常规链表不同，它们甚至不以先进先出（FIFO）顺序处理（它们使用更快的后进先出（LIFO）顺序），因为在通常使用快速链表的临时环境中，顺序并不是很重要。</span><br><span class="line">快速链表中的内存块保持其使用位被设置，因此它们不能与其他空闲内存块合并。malloc_consolidate 函数会释放快速链表中的所有内存块，并将它们与其他空闲内存块合并*/</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mfastbinptr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    This is in malloc_state.</span></span><br><span class="line"><span class="comment">    /* Fastbins */</span></span><br><span class="line">    mfastbinptr fastbinsY[ NFASTBINS ];</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>为了更加高效地利用 fast bin，glibc采用单向链表对其中的每个bin进行组织，并且每个bin采取LIFO策略(后进先出)，最近释放的<code>chunk</code>会更早的被分配，所以会更加适合于局部性。也就是说，当用户需要的<code>chunk</code>的大小小于 fastbin 的最大大小时，ptmalloc会首先判断 fastbin 中相应的 bin 中是否有对应大小的空闲块，如果有的话，就会直接从这个 bin 中获取 chunk。如果没有的话，ptmalloc才会做接下来的一系列操作。</p>
<p>默认情况下(32位系统为例)，fast bin中默认支持最大的<code>chunk</code>的数据空间大小为64字节。但是其可以支持的<code>chunk</code>的数据空间最大为0x80字节。除此之外，fast bin 最多可以支持的 bin 的个数为10个，从数据空间为8字节开始一直到80字节(这里说的大小是数据空间的大小，也就是除去prev_size和size字段部分的大小)</p>
<p>定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NFASTBINS (fastbin_index(request2size(MAX_FAST_SIZE)) + 1)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DEFAULT_MXFAST</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MXFAST (64 * SIZE_SZ / 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 我们支持的最大快速堆块请求大小 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_FAST_SIZE (80 * SIZE_SZ / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   由于max_fast的最低2位在尺寸比较中无关紧要，因此被用作标志位。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   max_fast中存储的FASTCHUNKS_BIT标志表示可能存在一些快速箱块（fastbin chunk）。</span></span><br><span class="line"><span class="comment">   当有块进入任何快速箱时，该标志设为真；仅在malloc_consolidate函数中清除该标志。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   真值取反设计是为了在启动时have_fastchunks默认为真（因为静态变量初始化为零），简化初始化检查。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 判断分配区是否存在快速箱块，1表示不存在</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FASTCHUNKS_BIT (1U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> have_fastchunks(M) (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_fastchunks(M) catomic_or(&amp;(M)-&gt;flags, FASTCHUNKS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_fastchunks(M) catomic_and(&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   NONCONTIGUOUS_BIT标志表示MORECORE不会返回连续内存区域。</span></span><br><span class="line"><span class="comment">   否则，在可能的情况下，会利用连续性合并连续MORECORE调用的结果。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   初始值来自MORECORE_CONTIGUOUS，但如果使用mmap作为sbrk的替代方案，该值会动态改变。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 判断MORECORE是否返回连续内存区域：</span></span><br><span class="line"><span class="comment">// 主分配区的MORECORE对应sbrk()，默认返回连续虚拟地址空间；</span></span><br><span class="line"><span class="comment">// 非主分配区使用mmap()分配大块内存并切分，而mmap默认不保证地址连续，因此非主分配区默认非连续。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NONCONTIGUOUS_BIT (2U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> contiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> noncontiguous(M) (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) != 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_noncontiguous(M) ((M)-&gt;flags |= NONCONTIGUOUS_BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_contiguous(M) ((M)-&gt;flags &amp;= ~NONCONTIGUOUS_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   若检测到分配区（arena）存在内存损坏，则设置ARENA_CORRUPTION_BIT标志。</span></span><br><span class="line"><span class="comment">   此类分配区不再用于分配内存块，且检测到损坏前已分配的块不会被释放。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARENA_CORRUPTION_BIT (4U)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> arena_is_corrupt(A) (((A)-&gt;flags &amp; ARENA_CORRUPTION_BIT))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_arena_corrupt(A) ((A)-&gt;flags |= ARENA_CORRUPTION_BIT)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   设置max_fast的值：</span></span><br><span class="line"><span class="comment">   - 若参数为0，则使用极小值（避免影响正常分配）。</span></span><br><span class="line"><span class="comment">   - 前置条件：当前无快速箱块存在。</span></span><br><span class="line"><span class="comment">   - 设置该值时会清除fastchunk标志，但保留非连续标志（noncontiguous bit）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_max_fast(s)                                                        \</span></span><br><span class="line"><span class="meta">    global_max_fast =                                                          \</span></span><br><span class="line"><span class="meta">        (((s) == 0) ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_max_fast() global_max_fast</span></span><br></pre></td></tr></table></figure>

<p>ptmalloc 默认情况下会调用 set_max_fast(s) 将全局变量 global_max_fast 设置为 DEFAULT_MXFAST，也就是设置 fast bins 中 <code>chunk</code> 的最大值。当 MAX_FAST_SIZE 被设置为 0 时，系统就不会支持 fast bins 。</p>
<p><strong>fastbin 的索引</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[ idx ])</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="comment">// chunk size=2*size_sz*(2+idx)</span></span><br><span class="line"><span class="comment">// 这里要减2，否则的话，前两个bin没有办法索引到。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fastbin_index(sz)                                                      \</span></span><br><span class="line"><span class="meta">    ((((unsigned int) (sz)) &gt;&gt; (SIZE_SZ == 8 ? 4 : 3)) - 2)</span></span><br></pre></td></tr></table></figure>

<p><strong>需要特别注意的是，fastbin 范围的 <code>chunk</code> 的 inuse 始终被置为 1。因此它们不会和其它被释放的 <code>chunk</code> 合并。</strong></p>
<p>但是当释放的 <code>chunk</code> 与该 <code>chunk</code> 相邻的空闲 <code>chunk</code> 合并后的大小大于 FASTBIN_CONSOLIDATION_THRESHOLD 时，内存碎片可能比较多了，我们就需要把 fast bins 中的 chunk 都进行合并，以减少内存碎片对系统的影响。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">   FASTBIN_CONSOLIDATION_THRESHOLD是free()函数中一个块的大小，当达到这个大小，就会触发对可能相邻的快速链表块进行自动合并。这是一种启发式方法，所以具体的值并没有太大影响。它被定义为默认修剪阈值的一半，这是一种折中的启发式策略，即只有在可能导致修剪的情况下才尝试合并。然而，它不能动态调整，因为即使不使用修剪，合并也能减少大块周围的碎片。</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">#define FASTBIN_CONSOLIDATION_THRESHOLD (65536UL)</span><br></pre></td></tr></table></figure>

<p><strong>malloc_consolidate 函数可以将 fastbin 中所有能和其它 <code>chunk</code> 合并的 <code>chunk</code> 合并在一起。具体地参见后续的详细函数的分析。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   快速链表（fastbins）中的块会保持其已使用位（inuse bit）被设置，因此它们不能与其他空闲块合并。malloc_consolidate 函数会释放快速链表中的所有块，并将它们与其他空闲块合并。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="small-bin"><a href="#small-bin" class="headerlink" title="small bin"></a>small bin</h4><p>small bins中每个<code>chunk</code>的大小与其所在的 bin 的index的关系为: chunk_size &#x3D; 2 * SIZE_SZ*index，具体如下</p>
<table>
<thead>
<tr>
<th align="left">下标</th>
<th align="left">SIZE_SZ&#x3D;4（32 位）</th>
<th align="left">SIZE_SZ&#x3D;8（64 位）</th>
</tr>
</thead>
<tbody><tr>
<td align="left">2</td>
<td align="left">16</td>
<td align="left">32</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">24</td>
<td align="left">48</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">32</td>
<td align="left">64</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">40</td>
<td align="left">80</td>
</tr>
<tr>
<td align="left">x</td>
<td align="left">2*4*x</td>
<td align="left">2*8*x</td>
</tr>
<tr>
<td align="left">63</td>
<td align="left">504</td>
<td align="left">1008</td>
</tr>
</tbody></table>
<p>small bins 中一共有62个循环双向链表，每个链表中存储的<code>chunk</code>大小都一致。比如对于32位系统来说，下标2对应的双向链表中存储的<code>chunk</code>大小均为16字节。每个链表都有链表头节点，这样可以方便对于链表内部结点的管理。此外，**small bins中每个 bin 对应的链表采用 FIFO 的规则(先进先出)**，所以同一个链表中先被释放的<code>chunk</code>会先被分配出去</p>
<p>small bin 相关的宏如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NSMALLBINS 64</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_WIDTH MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="comment">// 是否需要对small bin的下标进行纠正</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIN_LARGE_SIZE ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"><span class="comment">//判断chunk的大小是否在small bin范围内</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in_smallbin_range(sz)                                                  \</span></span><br><span class="line"><span class="meta">    ((unsigned long) (sz) &lt; (unsigned long) MIN_LARGE_SIZE)</span></span><br><span class="line"><span class="comment">// 根据chunk的大小得到small bin对应的索引。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> smallbin_index(sz)                                                     \</span></span><br><span class="line"><span class="meta">    ((SMALLBIN_WIDTH == 16 ? (((unsigned) (sz)) &gt;&gt; 4)                          \</span></span><br><span class="line"><span class="meta">                           : (((unsigned) (sz)) &gt;&gt; 3)) +                       \</span></span><br><span class="line"><span class="meta">     SMALLBIN_CORRECTION)</span></span><br></pre></td></tr></table></figure>

<p><strong>或许，大家会很疑惑，那 fast bin 与 small bin 中 <code>chunk</code> 的大小会有很大一部分重合啊，那 small bin 中对应大小的 bin 是不是就没有什么作用啊？</strong> 其实不然，fast bin 中的 <code>chunk</code> 是有可能被放到 small bin 中去的，我们在后面分析具体的源代码时会有深刻的体会。</p>
<h4 id="Large-Bin"><a href="#Large-Bin" class="headerlink" title="Large Bin"></a>Large Bin</h4><p>large bins 中一共包括 63 个 bin，每个 bin 中的 <code>chunk</code> 的大小不一致，而是处于一定区间范围内。此外，这 63 个 bin 被分成了 6 组，每组 bin 中的 <code>chunk</code> 大小之间的公差一致，具体如下：</p>
<table>
<thead>
<tr>
<th align="left">组</th>
<th align="left">数量</th>
<th align="left">公差</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">32</td>
<td align="left">64B</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">16</td>
<td align="left">512B</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">8</td>
<td align="left">4096B</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">4</td>
<td align="left">32768B</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">2</td>
<td align="left">262144B</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">1</td>
<td align="left">不限制</td>
</tr>
</tbody></table>
<p>这里我们以32位平台的large bin 为例，第一个large bin 的其实<code>chunk</code>大小为512字节，位于第一组，所以该bin可以存储的<code>chunk</code>的大小范围为[512,512+64）。</p>
<p>关于large bin 的宏如下，这里我们以32位平台下，第一个large bin 的起始<code>chunk</code>大小为例，为512字节</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32(sz)                                                  \</span></span><br><span class="line"><span class="meta">    (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 38)                                     \</span></span><br><span class="line"><span class="meta">         ? 56 + (((unsigned long) (sz)) &gt;&gt; 6)                                  \</span></span><br><span class="line"><span class="meta">         : ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20)                               \</span></span><br><span class="line"><span class="meta">               ? 91 + (((unsigned long) (sz)) &gt;&gt; 9)                            \</span></span><br><span class="line"><span class="meta">               : ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10)                        \</span></span><br><span class="line"><span class="meta">                     ? 110 + (((unsigned long) (sz)) &gt;&gt; 12)                    \</span></span><br><span class="line"><span class="meta">                     : ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4)                   \</span></span><br><span class="line"><span class="meta">                           ? 119 + (((unsigned long) (sz)) &gt;&gt; 15)              \</span></span><br><span class="line"><span class="meta">                           : ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2)             \</span></span><br><span class="line"><span class="meta">                                 ? 124 + (((unsigned long) (sz)) &gt;&gt; 18)        \</span></span><br><span class="line"><span class="meta">                                 : 126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_32_big(sz)                                              \</span></span><br><span class="line"><span class="meta">    (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 45)                                     \</span></span><br><span class="line"><span class="meta">         ? 49 + (((unsigned long) (sz)) &gt;&gt; 6)                                  \</span></span><br><span class="line"><span class="meta">         : ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20)                               \</span></span><br><span class="line"><span class="meta">               ? 91 + (((unsigned long) (sz)) &gt;&gt; 9)                            \</span></span><br><span class="line"><span class="meta">               : ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10)                        \</span></span><br><span class="line"><span class="meta">                     ? 110 + (((unsigned long) (sz)) &gt;&gt; 12)                    \</span></span><br><span class="line"><span class="meta">                     : ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4)                   \</span></span><br><span class="line"><span class="meta">                           ? 119 + (((unsigned long) (sz)) &gt;&gt; 15)              \</span></span><br><span class="line"><span class="meta">                           : ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2)             \</span></span><br><span class="line"><span class="meta">                                 ? 124 + (((unsigned long) (sz)) &gt;&gt; 18)        \</span></span><br><span class="line"><span class="meta">                                 : 126)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX 目前尚不清楚，保持桶的宽度不变是否合适，还是也应该按系数 2 进行缩放。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index_64(sz)                                                  \</span></span><br><span class="line"><span class="meta">    (((((unsigned long) (sz)) &gt;&gt; 6) &lt;= 48)                                     \</span></span><br><span class="line"><span class="meta">         ? 48 + (((unsigned long) (sz)) &gt;&gt; 6)                                  \</span></span><br><span class="line"><span class="meta">         : ((((unsigned long) (sz)) &gt;&gt; 9) &lt;= 20)                               \</span></span><br><span class="line"><span class="meta">               ? 91 + (((unsigned long) (sz)) &gt;&gt; 9)                            \</span></span><br><span class="line"><span class="meta">               : ((((unsigned long) (sz)) &gt;&gt; 12) &lt;= 10)                        \</span></span><br><span class="line"><span class="meta">                     ? 110 + (((unsigned long) (sz)) &gt;&gt; 12)                    \</span></span><br><span class="line"><span class="meta">                     : ((((unsigned long) (sz)) &gt;&gt; 15) &lt;= 4)                   \</span></span><br><span class="line"><span class="meta">                           ? 119 + (((unsigned long) (sz)) &gt;&gt; 15)              \</span></span><br><span class="line"><span class="meta">                           : ((((unsigned long) (sz)) &gt;&gt; 18) &lt;= 2)             \</span></span><br><span class="line"><span class="meta">                                 ? 124 + (((unsigned long) (sz)) &gt;&gt; 18)        \</span></span><br><span class="line"><span class="meta">                                 : 126)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> largebin_index(sz)                                                     \</span></span><br><span class="line"><span class="meta">    (SIZE_SZ == 8 ? largebin_index_64(sz) : MALLOC_ALIGNMENT == 16             \</span></span><br><span class="line"><span class="meta">                                                ? largebin_index_32_big(sz)    \</span></span><br><span class="line"><span class="meta">                                                : largebin_index_32(sz))</span></span><br></pre></td></tr></table></figure>

<h4 id="Unsorted-Bin"><a href="#Unsorted-Bin" class="headerlink" title="Unsorted Bin"></a>Unsorted Bin</h4><p>unsorted bin 可以视为空闲 <code>chunk</code> 回归其所属 bin 之前的缓冲区。</p>
<p>其在 glibc 中具体的说明如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   未排序块</span></span><br><span class="line"><span class="comment">所有因块分割产生的剩余部分，以及所有返回的块，</span></span><br><span class="line"><span class="comment">首先会被放入 “未排序” 桶中。然后，在 malloc 为它们提供一次在入桶前被使用的机会后，这些块会被放入常规桶中。所以，基本上，未排序块列表就像一个队列，块在 free（以及 malloc_consolidate）操作中被放入该列表，而在 malloc 操作中被取出（要么被使用，要么被放入桶中）。未排序块永远不会设置 NON_MAIN_ARENA 标志，所以在进行大小比较时无需考虑该标志。</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 ptmalloc 内存管理机制中，<code>NON_MAIN_ARENA</code> flag 是<code>malloc_chunk</code>结构体中<code>size</code>字段的一个标志位，用于表示当前<code>chunk</code>是否属于主线程的分配区（<code>main arena</code>）</p>
</blockquote>
<p>从下面的宏我们可以看出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 无法索引的 1 号 bin 用于存放未排序的块。 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> unsorted_chunks(M) (bin_at(M, 1))</span></span><br></pre></td></tr></table></figure>

<p>unsorted bin 处于我们之前所说的 bin 数组下标 1 处。故而 unsorted bin 只有一个链表。unsorted bin 中的空闲 <code>chunk</code> 处于乱序状态，主要有两个来源</p>
<ul>
<li>当一个较大的 <code>chunk</code> 被分割成两半后，如果剩下的部分大于 MINSIZE，就会被放到 unsorted bin 中。</li>
<li>释放一个不属于 fast bin 的 chunk，并且该 <code>chunk</code> 不和 top <code>chunk</code> 紧邻时，该 <code>chunk</code> 会被首先放到 unsorted bin 中。关于 top <code>chunk</code> 的解释，请参考下面的介绍。</li>
</ul>
<p>此外，Unsorted Bin 在使用的过程中，采用的遍历顺序是 FIFO 。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://mint-sec.github.io">mint</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://mint-sec.github.io/2025/06/10/%E5%A0%86/">http://mint-sec.github.io/2025/06/10/%E5%A0%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://mint-sec.github.io" target="_blank">mint1.</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><a class="post-meta__tags" href="/tags/%E5%A0%86/">堆</a></div><div class="post_share"><div class="social-share" data-image="/images/Decoration/%E9%9B%85.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2025/06/07/polar2025%E5%A4%8F%E5%AD%A3%E8%B5%9B/" title="polar2025夏季赛复现"><img class="cover" src="/images/Decoration/%E9%9B%85.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">polar2025夏季赛复现</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/03/20/GDB%E8%B0%83%E8%AF%95/" title="GDB调试"><img class="cover" src="/images/Decoration/%E9%9B%85.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-20</div><div class="title">GDB调试</div></div></a></div><div><a href="/2025/05/20/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/" title="IDA动态调试"><img class="cover" src="/images/Decoration/%E9%9B%85.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-05-20</div><div class="title">IDA动态调试</div></div></a></div><div><a href="/2024/12/09/ctfshow%E5%89%8D%E7%BD%AE/" title="ctfshow_pwn前置杂记"><img class="cover" src="/images/Decoration/%E9%9B%85.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-09</div><div class="title">ctfshow_pwn前置杂记</div></div></a></div><div><a href="/2025/01/16/git%E5%AD%A6%E4%B9%A0/" title="Git学习"><img class="cover" src="/images/Decoration/%E9%9B%85.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-16</div><div class="title">Git学习</div></div></a></div><div><a href="/2024/12/01/pwntools/" title="pwntools"><img class="cover" src="/images/Decoration/%E9%9B%85.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-01</div><div class="title">pwntools</div></div></a></div><div><a href="/2024/11/30/ret2libc/" title="ret2libc"><img class="cover" src="/images/Decoration/%E9%9B%85.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-30</div><div class="title">ret2libc</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">mint</div><div class="author-info__description">pwn小白</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/null/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mint-sec"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">this is my blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">堆概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%A0%86"><span class="toc-number">1.1.</span> <span class="toc-text">什么是堆</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.</span> <span class="toc-text">堆的基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc"><span class="toc-number">1.2.1.</span> <span class="toc-text">malloc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free"><span class="toc-number">1.2.2.</span> <span class="toc-text">free</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E8%83%8C%E5%90%8E%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">内存分配背后的系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#s-brk"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">(s)brk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mmap"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">mmap</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%94%AF%E6%8C%81"><span class="toc-number">1.2.4.</span> <span class="toc-text">多线程支持</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A0%86%E7%9B%B8%E5%85%B3%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">堆相关数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E8%A7%82%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">微观结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-chunk"><span class="toc-number">2.1.1.</span> <span class="toc-text">malloc_chunk</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#chunk-%E7%9B%B8%E5%85%B3%E5%AE%8F"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">chunk 相关宏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bin"><span class="toc-number">2.1.2.</span> <span class="toc-text">bin</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Fast-Bin"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">Fast Bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#small-bin"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">small bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Large-Bin"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">Large Bin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Unsorted-Bin"><span class="toc-number">2.1.2.5.</span> <span class="toc-text">Unsorted Bin</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/10/%E5%A0%86/" title="堆"><img src="/images/Decoration/%E9%9B%85.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="堆"/></a><div class="content"><a class="title" href="/2025/06/10/%E5%A0%86/" title="堆">堆</a><time datetime="2025-06-10T01:48:17.000Z" title="发表于 2025-06-10 09:48:17">2025-06-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/07/polar2025%E5%A4%8F%E5%AD%A3%E8%B5%9B/" title="polar2025夏季赛复现"><img src="/images/Decoration/%E9%9B%85.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="polar2025夏季赛复现"/></a><div class="content"><a class="title" href="/2025/06/07/polar2025%E5%A4%8F%E5%AD%A3%E8%B5%9B/" title="polar2025夏季赛复现">polar2025夏季赛复现</a><time datetime="2025-06-07T11:09:07.000Z" title="发表于 2025-06-07 19:09:07">2025-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/07/H&amp;NCTFwp/" title="H&amp;NCTFwp"><img src="/images/Decoration/%E9%9B%85.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="H&amp;NCTFwp"/></a><div class="content"><a class="title" href="/2025/06/07/H&amp;NCTFwp/" title="H&amp;NCTFwp">H&amp;NCTFwp</a><time datetime="2025-06-07T03:22:44.000Z" title="发表于 2025-06-07 11:22:44">2025-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/25/LitCTFwp/" title="LitCTF wp（更新中）"><img src="/images/Decoration/%E9%9B%85.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LitCTF wp（更新中）"/></a><div class="content"><a class="title" href="/2025/05/25/LitCTFwp/" title="LitCTF wp（更新中）">LitCTF wp（更新中）</a><time datetime="2025-05-25T03:03:43.000Z" title="发表于 2025-05-25 11:03:43">2025-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/20/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/" title="IDA动态调试"><img src="/images/Decoration/%E9%9B%85.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IDA动态调试"/></a><div class="content"><a class="title" href="/2025/05/20/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/" title="IDA动态调试">IDA动态调试</a><time datetime="2025-05-20T06:08:43.000Z" title="发表于 2025-05-20 14:08:43">2025-05-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/Decoration/%E9%9B%85.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By mint</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script>
  document.addEventListener('DOMContentLoaded', function() {
    // 汉化统计信息
    const replacements = {
      'Article': '文章',
      'Total Count': '总字数',
      'UV': '访客数',
      'PV': '访问量',
      'Last Update': '最后更新',
      'Just now': '刚刚',
      'Archives': '归档',
      'Tags': '标签', 
      'Categories': '分类',
      'Recent Post': '最新文章',
      'Announcement': '公告',
      'Info': '信息',
      'Follow Me': '关注我',
      'January': '一月',
      'February': '二月',
      'March': '三月',
      'April': '四月',
      'May': '五月',
      'June': '六月',
      'July': '七月',
      'August': '八月',
      'September': '九月',
      'October': '十月',
      'November': '十一月',
      'December': '十二月'
    };
    
    
    function replaceText(node) {
      if (node.nodeType === Node.TEXT_NODE) {
        Object.entries(replacements).forEach(([en, zh]) => {
          node.textContent = node.textContent.replace(en, zh);
        });
      } else {
        node.childNodes.forEach(replaceText);
      }
    }

    replaceText(document.body);
  });
</script>
<script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.13.0"></script></div></div></body></html>